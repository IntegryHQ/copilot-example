/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/manager.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyLmNqcz85Mjc2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9jYWxsYmFja3MvbWFuYWdlci5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/caches/base.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryCache = exports.BaseCache = exports.serializeGeneration = exports.deserializeStoredGeneration = exports.getCacheKey = void 0;\nconst hash_js_1 = __webpack_require__(/*! ../utils/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * This cache key should be consistent across all versions of LangChain.\n * It is currently NOT consistent across versions of LangChain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * separate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of LangChain.\n */\nconst getCacheKey = (...strings) => (0, hash_js_1.insecureHash)(strings.join(\"_\"));\nexports.getCacheKey = getCacheKey;\nfunction deserializeStoredGeneration(storedGeneration) {\n    if (storedGeneration.message !== undefined) {\n        return {\n            text: storedGeneration.text,\n            message: (0, utils_js_1.mapStoredMessageToChatMessage)(storedGeneration.message),\n        };\n    }\n    else {\n        return { text: storedGeneration.text };\n    }\n}\nexports.deserializeStoredGeneration = deserializeStoredGeneration;\nfunction serializeGeneration(generation) {\n    const serializedValue = {\n        text: generation.text,\n    };\n    if (generation.message !== undefined) {\n        serializedValue.message = generation.message.toDict();\n    }\n    return serializedValue;\n}\nexports.serializeGeneration = serializeGeneration;\n/**\n * Base class for all caches. All caches should extend this class.\n */\nclass BaseCache {\n}\nexports.BaseCache = BaseCache;\nconst GLOBAL_MAP = new Map();\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nclass InMemoryCache extends BaseCache {\n    constructor(map) {\n        super();\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cache = map ?? new Map();\n    }\n    /**\n     * Retrieves data from the cache using a prompt and an LLM key. If the\n     * data is not found, it returns null.\n     * @param prompt The prompt used to find the data.\n     * @param llmKey The LLM key used to find the data.\n     * @returns The data corresponding to the prompt and LLM key, or null if not found.\n     */\n    lookup(prompt, llmKey) {\n        return Promise.resolve(this.cache.get((0, exports.getCacheKey)(prompt, llmKey)) ?? null);\n    }\n    /**\n     * Updates the cache with new data using a prompt and an LLM key.\n     * @param prompt The prompt used to store the data.\n     * @param llmKey The LLM key used to store the data.\n     * @param value The data to be stored.\n     */\n    async update(prompt, llmKey, value) {\n        this.cache.set((0, exports.getCacheKey)(prompt, llmKey), value);\n    }\n    /**\n     * Returns a global instance of InMemoryCache using a predefined global\n     * map as the initial cache.\n     * @returns A global instance of InMemoryCache.\n     */\n    static global() {\n        return new InMemoryCache(GLOBAL_MAP);\n    }\n}\nexports.InMemoryCache = InMemoryCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FjaGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLG1DQUFtQyxHQUFHLG1CQUFtQjtBQUNuSSxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FjaGVzL2Jhc2UuY2pzPzcxMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluTWVtb3J5Q2FjaGUgPSBleHBvcnRzLkJhc2VDYWNoZSA9IGV4cG9ydHMuc2VyaWFsaXplR2VuZXJhdGlvbiA9IGV4cG9ydHMuZGVzZXJpYWxpemVTdG9yZWRHZW5lcmF0aW9uID0gZXhwb3J0cy5nZXRDYWNoZUtleSA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9oYXNoLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHMuY2pzXCIpO1xuLyoqXG4gKiBUaGlzIGNhY2hlIGtleSBzaG91bGQgYmUgY29uc2lzdGVudCBhY3Jvc3MgYWxsIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqIEl0IGlzIGN1cnJlbnRseSBOT1QgY29uc2lzdGVudCBhY3Jvc3MgdmVyc2lvbnMgb2YgTGFuZ0NoYWluLlxuICpcbiAqIEEgaHVnZSBiZW5lZml0IG9mIGhhdmluZyBhIHJlbW90ZSBjYWNoZSAobGlrZSByZWRpcykgaXMgdGhhdCB5b3UgY2FuXG4gKiBhY2Nlc3MgdGhlIGNhY2hlIGZyb20gZGlmZmVyZW50IHByb2Nlc3Nlcy9tYWNoaW5lcy4gVGhlIGFsbG93cyB5b3UgdG9cbiAqIHNlcGFyYXRlIGNvbmNlcm5zIGFuZCBzY2FsZSBob3Jpem9udGFsbHkuXG4gKlxuICogVE9ETzogTWFrZSBjYWNoZSBrZXkgY29uc2lzdGVudCBhY3Jvc3MgdmVyc2lvbnMgb2YgTGFuZ0NoYWluLlxuICovXG5jb25zdCBnZXRDYWNoZUtleSA9ICguLi5zdHJpbmdzKSA9PiAoMCwgaGFzaF9qc18xLmluc2VjdXJlSGFzaCkoc3RyaW5ncy5qb2luKFwiX1wiKSk7XG5leHBvcnRzLmdldENhY2hlS2V5ID0gZ2V0Q2FjaGVLZXk7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0b3JlZEdlbmVyYXRpb24oc3RvcmVkR2VuZXJhdGlvbikge1xuICAgIGlmIChzdG9yZWRHZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RvcmVkR2VuZXJhdGlvbi50ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZTogKDAsIHV0aWxzX2pzXzEubWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UpKHN0b3JlZEdlbmVyYXRpb24ubWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBzdG9yZWRHZW5lcmF0aW9uLnRleHQgfTtcbiAgICB9XG59XG5leHBvcnRzLmRlc2VyaWFsaXplU3RvcmVkR2VuZXJhdGlvbiA9IGRlc2VyaWFsaXplU3RvcmVkR2VuZXJhdGlvbjtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUdlbmVyYXRpb24oZ2VuZXJhdGlvbikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IHtcbiAgICAgICAgdGV4dDogZ2VuZXJhdGlvbi50ZXh0LFxuICAgIH07XG4gICAgaWYgKGdlbmVyYXRpb24ubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5tZXNzYWdlID0gZ2VuZXJhdGlvbi5tZXNzYWdlLnRvRGljdCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZFZhbHVlO1xufVxuZXhwb3J0cy5zZXJpYWxpemVHZW5lcmF0aW9uID0gc2VyaWFsaXplR2VuZXJhdGlvbjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNhY2hlcy4gQWxsIGNhY2hlcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmNsYXNzIEJhc2VDYWNoZSB7XG59XG5leHBvcnRzLkJhc2VDYWNoZSA9IEJhc2VDYWNoZTtcbmNvbnN0IEdMT0JBTF9NQVAgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEEgY2FjaGUgZm9yIHN0b3JpbmcgTExNIGdlbmVyYXRpb25zIHRoYXQgc3RvcmVzIGRhdGEgaW4gbWVtb3J5LlxuICovXG5jbGFzcyBJbk1lbW9yeUNhY2hlIGV4dGVuZHMgQmFzZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG1hcCA/PyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkYXRhIGZyb20gdGhlIGNhY2hlIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LiBJZiB0aGVcbiAgICAgKiBkYXRhIGlzIG5vdCBmb3VuZCwgaXQgcmV0dXJucyBudWxsLlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGxsbUtleSBUaGUgTExNIGtleSB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvbXB0IGFuZCBMTE0ga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsb29rdXAocHJvbXB0LCBsbG1LZXkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNhY2hlLmdldCgoMCwgZXhwb3J0cy5nZXRDYWNoZUtleSkocHJvbXB0LCBsbG1LZXkpKSA/PyBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FjaGUgd2l0aCBuZXcgZGF0YSB1c2luZyBhIHByb21wdCBhbmQgYW4gTExNIGtleS5cbiAgICAgKiBAcGFyYW0gcHJvbXB0IFRoZSBwcm9tcHQgdXNlZCB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gbGxtS2V5IFRoZSBMTE0ga2V5IHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBkYXRhIHRvIGJlIHN0b3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocHJvbXB0LCBsbG1LZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KCgwLCBleHBvcnRzLmdldENhY2hlS2V5KShwcm9tcHQsIGxsbUtleSksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGdsb2JhbCBpbnN0YW5jZSBvZiBJbk1lbW9yeUNhY2hlIHVzaW5nIGEgcHJlZGVmaW5lZCBnbG9iYWxcbiAgICAgKiBtYXAgYXMgdGhlIGluaXRpYWwgY2FjaGUuXG4gICAgICogQHJldHVybnMgQSBnbG9iYWwgaW5zdGFuY2Ugb2YgSW5NZW1vcnlDYWNoZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2xvYmFsKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluTWVtb3J5Q2FjaGUoR0xPQkFMX01BUCk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbk1lbW9yeUNhY2hlID0gSW5NZW1vcnlDYWNoZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseCallbackHandler = void 0;\nconst uuid = __importStar(__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\"));\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0, serializable_js_1.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"raiseError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.ignoreCustomEvent =\n                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n            this.raiseError = input.raiseError ?? this.raiseError;\n            this.awaitHandlers =\n                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return serializable_js_1.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return serializable_js_1.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid.v4()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\nexports.BaseCallbackHandler = BaseCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsOERBQU07QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLGlGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvYmFzZS5janM/NmJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQ2FsbGJhY2tIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgdXVpZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidXVpZFwiKSk7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgc2V0IG9mIG9wdGlvbmFsIG1ldGhvZHMgdGhhdCBjYW4gYmVcbiAqIG92ZXJyaWRkZW4gaW4gZGVyaXZlZCBjbGFzc2VzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBleGVjdXRpb24gb2YgYSBMYW5nQ2hhaW4gYXBwbGljYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xufVxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBjYWxsYmFjayBoYW5kbGVycyBpbiB0aGUgTGFuZ0NoYWluXG4gKiBmcmFtZXdvcmsuIEl0IHByb3ZpZGVzIGEgc2V0IG9mIG9wdGlvbmFsIG1ldGhvZHMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlblxuICogaW4gZGVyaXZlZCBjbGFzc2VzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhXG4gKiBMYW5nQ2hhaW4gYXBwbGljYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJjYWxsYmFja3NcIiwgdGhpcy5uYW1lXTtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICAoMCwgc2VyaWFsaXphYmxlX2pzXzEuZ2V0X2xjX3VuaXF1ZV9uYW1lKSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUxMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUNoYWluXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQWdlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVSZXRyaWV2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVDdXN0b21FdmVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJhaXNlRXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhd2FpdEhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJMQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkRcIikgPT09IFwiZmFsc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBpbnB1dCB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUxMTSA9IGlucHV0Lmlnbm9yZUxMTSA/PyB0aGlzLmlnbm9yZUxMTTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ2hhaW4gPSBpbnB1dC5pZ25vcmVDaGFpbiA/PyB0aGlzLmlnbm9yZUNoYWluO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVBZ2VudCA9IGlucHV0Lmlnbm9yZUFnZW50ID8/IHRoaXMuaWdub3JlQWdlbnQ7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZVJldHJpZXZlciA9IGlucHV0Lmlnbm9yZVJldHJpZXZlciA/PyB0aGlzLmlnbm9yZVJldHJpZXZlcjtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ3VzdG9tRXZlbnQgPVxuICAgICAgICAgICAgICAgIGlucHV0Lmlnbm9yZUN1c3RvbUV2ZW50ID8/IHRoaXMuaWdub3JlQ3VzdG9tRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IgPSBpbnB1dC5yYWlzZUVycm9yID8/IHRoaXMucmFpc2VFcnJvcjtcbiAgICAgICAgICAgIHRoaXMuYXdhaXRIYW5kbGVycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yIHx8IChpbnB1dC5fYXdhaXRIYW5kbGVyID8/IHRoaXMuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVfanNfMS5TZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZV9qc18xLlNlcmlhbGl6YWJsZS5wcm90b3R5cGUudG9KU09OTm90SW1wbGVtZW50ZWQuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NZXRob2RzKG1ldGhvZHMpIHtcbiAgICAgICAgY2xhc3MgSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHV1aWQudjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgbWV0aG9kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIYW5kbGVyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ2FsbGJhY2tIYW5kbGVyID0gQmFzZUNhbGxiYWNrSGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.traceAsGroup = exports.TraceGroup = exports.ensureHandler = exports.CallbackManager = exports.CallbackManagerForToolRun = exports.CallbackManagerForChainRun = exports.CallbackManagerForLLMRun = exports.CallbackManagerForRetrieverRun = exports.BaseRunManager = exports.BaseCallbackManager = exports.parseCallbackConfigArg = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst console_js_1 = __webpack_require__(/*! ../tracers/console.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst tracer_langchain_js_1 = __webpack_require__(/*! ../tracers/tracer_langchain.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\");\nconst promises_js_1 = __webpack_require__(/*! ./promises.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\");\nconst callbacks_js_1 = __webpack_require__(/*! ../utils/callbacks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../tracers/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\nexports.parseCallbackConfigArg = parseCallbackConfigArg;\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\nexports.BaseCallbackManager = BaseCallbackManager;\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.BaseRunManager = BaseRunManager;\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForRetrieverRun = CallbackManagerForRetrieverRun;\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForLLMRun = CallbackManagerForLLMRun;\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForChainRun = CallbackManagerForChainRun;\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForToolRun = CallbackManagerForToolRun;\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0, utils_js_1.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0, uuid_1.v4)(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends base_js_1.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0, uuid_1.v4)()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            (0, callbacks_js_1.isTracingEnabled)();\n        const tracingEnabled = tracingV2Enabled ||\n            ((0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === console_js_1.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new console_js_1.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new tracer_langchain_js_1.LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                    // handoff between langchain and langsmith/traceable\n                    // override the parent run ID\n                    callbackManager._parentRunId =\n                        tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.id ??\n                            callbackManager._parentRunId;\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nexports.CallbackManager = CallbackManager;\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return base_js_1.BaseCallbackHandler.fromMethods(handler);\n}\nexports.ensureHandler = ensureHandler;\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(`What is the answer to {question}?`);\n *\n * // Example of using LLMChain to process a series of questions\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Process questions using the chain\n * const processQuestions = async (questions) => {\n *   for (const question of questions) {\n *     const result = await chain.call({ question });\n *     console.log(result);\n *   }\n * };\n *\n * // Example questions\n * const questions = [\n *   \"What is your name?\",\n *   \"What is your quest?\",\n *   \"What is your favorite color?\",\n * ];\n *\n * // Run the example\nconst logFunction = handler.raiseError ? console.error : console.warn;\n* processQuestions(questions).catch(consolelogFunction;\n *\n * ```\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new tracer_langchain_js_1.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\nexports.TraceGroup = TraceGroup;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\nexports.traceAsGroup = traceAsGroup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLHNDQUFzQyxHQUFHLHNCQUFzQixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QjtBQUN4VSxlQUFlLG1CQUFPLENBQUMsOERBQU07QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3ZFLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFnQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLGdCQUFnQixJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsMEJBQTBCLE1BQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixrQkFBa0IsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHNCQUFzQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG1CQUFtQixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixzQkFBc0IsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixxQkFBcUIsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QiwwQkFBMEIsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvbWFuYWdlci5janM/OGE1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJhY2VBc0dyb3VwID0gZXhwb3J0cy5UcmFjZUdyb3VwID0gZXhwb3J0cy5lbnN1cmVIYW5kbGVyID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXIgPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JMTE1SdW4gPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biA9IGV4cG9ydHMuQmFzZVJ1bk1hbmFnZXIgPSBleHBvcnRzLkJhc2VDYWxsYmFja01hbmFnZXIgPSBleHBvcnRzLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcgPSB2b2lkIDA7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uc29sZV9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvY29uc29sZS5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL3V0aWxzLmNqc1wiKTtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2Vudi5janNcIik7XG5jb25zdCB0cmFjZXJfbGFuZ2NoYWluX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmNqc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9taXNlcy5janNcIik7XG5jb25zdCBjYWxsYmFja3NfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jYWxsYmFja3MuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvYmFzZS5janNcIik7XG5mdW5jdGlvbiBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnKGFyZykge1xuICAgIGlmICghYXJnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8IFwibmFtZVwiIGluIGFyZykge1xuICAgICAgICByZXR1cm4geyBjYWxsYmFja3M6IGFyZyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcgPSBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnO1xuLyoqXG4gKiBNYW5hZ2UgY2FsbGJhY2tzIGZyb20gZGlmZmVyZW50IGNvbXBvbmVudHMgb2YgTGFuZ0NoYWluLlxuICovXG5jbGFzcyBCYXNlQ2FsbGJhY2tNYW5hZ2VyIHtcbiAgICBzZXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0SGFuZGxlcnMoW2hhbmRsZXJdKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDYWxsYmFja01hbmFnZXIgPSBCYXNlQ2FsbGJhY2tNYW5hZ2VyO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW4gbWFuYWdlciBpbiBMYW5nQ2hhaW4uXG4gKi9cbmNsYXNzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihydW5JZCwgaGFuZGxlcnMsIGluaGVyaXRhYmxlSGFuZGxlcnMsIHRhZ3MsIGluaGVyaXRhYmxlVGFncywgbWV0YWRhdGEsIGluaGVyaXRhYmxlTWV0YWRhdGEsIF9wYXJlbnRSdW5JZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcnVuSWRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBoYW5kbGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVIYW5kbGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZVRhZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVNZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBfcGFyZW50UnVuSWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBwYXJlbnRSdW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFJ1bklkO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUZXh0KHRleHQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRleHQ/Lih0ZXh0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUZXh0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRhdGEsIF9ydW5JZCwgX3RhZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX21ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgdGhpcy5ydW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDdXN0b21FdmVudDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlUnVuTWFuYWdlciA9IEJhc2VSdW5NYW5hZ2VyO1xuLyoqXG4gKiBNYW5hZ2VzIGNhbGxiYWNrcyBmb3IgcmV0cmlldmVyIHJ1bnMuXG4gKi9cbmNsYXNzIENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVuZD8uKGRvY3VtZW50cywgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyRXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuID0gQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuO1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGFzeW5jIGhhbmRsZUxMTU5ld1Rva2VuKHRva2VuLCBpZHgsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTU5ld1Rva2VuPy4odG9rZW4sIGlkeCA/PyB7IHByb21wdDogMCwgY29tcGxldGlvbjogMCB9LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTU5ld1Rva2VuOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuID0gQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuO1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yQ2hhaW5SdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FcnJvcihlcnIsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVBZ2VudEFjdGlvbj8uKGFjdGlvbiwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQWdlbnRBY3Rpb246ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQWdlbnRFbmQoYWN0aW9uKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRFbmQ/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUFnZW50RW5kOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biA9IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuO1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbEVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBoYW5kbGVUb29sRW5kKG91dHB1dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gPSBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuO1xuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0ID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiV2hhdCBpcyB0aGUgYW5zd2VyIHRvIHtxdWVzdGlvbn0/XCIpO1xuICpcbiAqIC8vIEV4YW1wbGUgb2YgdXNpbmcgTExNQ2hhaW4gd2l0aCBPcGVuQUkgYW5kIGEgc2ltcGxlIHByb21wdFxuICogY29uc3QgY2hhaW4gPSBuZXcgTExNQ2hhaW4oe1xuICogICBsbG06IG5ldyBDaGF0T3BlbkFJKHsgdGVtcGVyYXR1cmU6IDAuOSB9KSxcbiAqICAgcHJvbXB0LFxuICogfSk7XG4gKlxuICogLy8gUnVubmluZyB0aGUgY2hhaW4gd2l0aCBhIHNpbmdsZSBxdWVzdGlvblxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uY2FsbCh7XG4gKiAgIHF1ZXN0aW9uOiBcIldoYXQgaXMgdGhlIGFpcnNwZWVkIHZlbG9jaXR5IG9mIGFuIHVubGFkZW4gc3dhbGxvdz9cIixcbiAqIH0pO1xuICogY29uc29sZS5sb2coXCJUaGUgYW5zd2VyIGlzOlwiLCByZXN1bHQpO1xuICogYGBgXG4gKi9cbmNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlVHJhY2VyKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yTExNU3RhcnQobGxtLCBbcHJvbXB0XSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFtwcm9tcHRdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgW21lc3NhZ2VHcm91cF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuaGFuZGxlTExNU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gKDAsIHV0aWxzX2pzXzEuZ2V0QnVmZmVyU3RyaW5nKShtZXNzYWdlR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFttZXNzYWdlU3RyaW5nXSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckxMTVJ1bihydW5JZF8sIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCA9ICgwLCB1dWlkXzEudjQpKCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlVHJhY2VyKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluU3RhcnQ/LihjaGFpbiwgaW5wdXRzLCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuVHlwZSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCA9ICgwLCB1dWlkXzEudjQpKCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VUcmFjZXIpKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbFN0YXJ0Py4odG9vbCwgaW5wdXQsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQgPSAoMCwgdXVpZF8xLnY0KSgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyU3RhcnQ/LihyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDdXN0b21FdmVudChldmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZGF0YSwgcnVuSWQsIF90YWdzLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9tZXRhZGF0YSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUN1c3RvbUV2ZW50Py4oZXZlbnROYW1lLCBkYXRhLCBydW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDdXN0b21FdmVudDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgfVxuICAgIHNldEhhbmRsZXJzKGhhbmRsZXJzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYWdzKHRhZ3MsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGFncyh0YWdzKTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgdGhpcy50YWdzLnB1c2goLi4udGFncyk7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVRhZ3ModGFncykge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdzLmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IHRoaXMuaW5oZXJpdGFibGVUYWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICB9XG4gICAgYWRkTWV0YWRhdGEobWV0YWRhdGEsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB7IC4uLnRoaXMubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEgPSB7IC4uLnRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhW2tleV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShhZGRpdGlvbmFsSGFuZGxlcnMgPSBbXSwgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuaW5jbHVkZXMoaGFuZGxlcik7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5pbmNsdWRlcyh0YWcpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBpbmhlcml0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gT2JqZWN0LmtleXModGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKS5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh7IFtrZXldOiB0aGlzLm1ldGFkYXRhW2tleV0gfSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBhZGRpdGlvbmFsSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgY29waWVzIG9mIGNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclxuICAgICAgICAgICAgbWFuYWdlci5oYW5kbGVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGgpID0+IGgubmFtZSA9PT0gXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIilcbiAgICAgICAgICAgICAgICAuc29tZSgoaCkgPT4gaC5uYW1lID09PSBoYW5kbGVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgY2xhc3MgSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgdXVpZF8xLnY0KSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBoYW5kbGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihuZXcgSGFuZGxlcigpKTtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjb25maWd1cmUoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgYXN5bmMgbWV0aG9kIGluIGZhdm9yIG9mIHRoaXMgb25lLlxuICAgIHN0YXRpYyBfY29uZmlndXJlU3luYyhpbmhlcml0YWJsZUhhbmRsZXJzLCBsb2NhbEhhbmRsZXJzLCBpbmhlcml0YWJsZVRhZ3MsIGxvY2FsVGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgbG9jYWxNZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgY2FsbGJhY2tNYW5hZ2VyO1xuICAgICAgICBpZiAoaW5oZXJpdGFibGVIYW5kbGVycyB8fCBsb2NhbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmhlcml0YWJsZUhhbmRsZXJzKSB8fCAhaW5oZXJpdGFibGVIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuc2V0SGFuZGxlcnMoaW5oZXJpdGFibGVIYW5kbGVycz8ubWFwKGVuc3VyZUhhbmRsZXIpID8/IFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IGluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBjYWxsYmFja01hbmFnZXIuY29weShBcnJheS5pc0FycmF5KGxvY2FsSGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgPyBsb2NhbEhhbmRsZXJzLm1hcChlbnN1cmVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIDogbG9jYWxIYW5kbGVycz8uaGFuZGxlcnMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlRW5hYmxlZCA9ICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9WRVJCT1NFXCIpID09PSBcInRydWVcIiB8fFxuICAgICAgICAgICAgb3B0aW9ucz8udmVyYm9zZTtcbiAgICAgICAgY29uc3QgdHJhY2luZ1YyRW5hYmxlZCA9IHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpPy50cmFjaW5nRW5hYmxlZCB8fFxuICAgICAgICAgICAgKDAsIGNhbGxiYWNrc19qc18xLmlzVHJhY2luZ0VuYWJsZWQpKCk7XG4gICAgICAgIGNvbnN0IHRyYWNpbmdFbmFibGVkID0gdHJhY2luZ1YyRW5hYmxlZCB8fFxuICAgICAgICAgICAgKCgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBjb25zb2xlX2pzXzEuQ29uc29sZUNhbGxiYWNrSGFuZGxlci5wcm90b3R5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zb2xlSGFuZGxlciA9IG5ldyBjb25zb2xlX2pzXzEuQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKGNvbnNvbGVIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2luZ1YyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFjZXJWMiA9IG5ldyB0cmFjZXJfbGFuZ2NoYWluX2pzXzEuTGFuZ0NoYWluVHJhY2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKHRyYWNlclYyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZG9mZiBiZXR3ZWVuIGxhbmdjaGFpbiBhbmQgbGFuZ3NtaXRoL3RyYWNlYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgcGFyZW50IHJ1biBJRFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuX3BhcmVudFJ1bklkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpPy5pZCA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5fcGFyZW50UnVuSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZVRhZ3MgfHwgbG9jYWxUYWdzKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MoaW5oZXJpdGFibGVUYWdzID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhsb2NhbFRhZ3MgPz8gW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVNZXRhZGF0YSB8fCBsb2NhbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGluaGVyaXRhYmxlTWV0YWRhdGEgPz8ge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShsb2NhbE1ldGFkYXRhID8/IHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrTWFuYWdlcjtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlciA9IENhbGxiYWNrTWFuYWdlcjtcbmZ1bmN0aW9uIGVuc3VyZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmIChcIm5hbWVcIiBpbiBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZV9qc18xLkJhc2VDYWxsYmFja0hhbmRsZXIuZnJvbU1ldGhvZHMoaGFuZGxlcik7XG59XG5leHBvcnRzLmVuc3VyZUhhbmRsZXIgPSBlbnN1cmVIYW5kbGVyO1xuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0ID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGBXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9gKTtcbiAqXG4gKiAvLyBFeGFtcGxlIG9mIHVzaW5nIExMTUNoYWluIHRvIHByb2Nlc3MgYSBzZXJpZXMgb2YgcXVlc3Rpb25zXG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBQcm9jZXNzIHF1ZXN0aW9ucyB1c2luZyB0aGUgY2hhaW5cbiAqIGNvbnN0IHByb2Nlc3NRdWVzdGlvbnMgPSBhc3luYyAocXVlc3Rpb25zKSA9PiB7XG4gKiAgIGZvciAoY29uc3QgcXVlc3Rpb24gb2YgcXVlc3Rpb25zKSB7XG4gKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uY2FsbCh7IHF1ZXN0aW9uIH0pO1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgIH1cbiAqIH07XG4gKlxuICogLy8gRXhhbXBsZSBxdWVzdGlvbnNcbiAqIGNvbnN0IHF1ZXN0aW9ucyA9IFtcbiAqICAgXCJXaGF0IGlzIHlvdXIgbmFtZT9cIixcbiAqICAgXCJXaGF0IGlzIHlvdXIgcXVlc3Q/XCIsXG4gKiAgIFwiV2hhdCBpcyB5b3VyIGZhdm9yaXRlIGNvbG9yP1wiLFxuICogXTtcbiAqXG4gKiAvLyBSdW4gdGhlIGV4YW1wbGVcbmNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yID8gY29uc29sZS5lcnJvciA6IGNvbnNvbGUud2FybjtcbiogcHJvY2Vzc1F1ZXN0aW9ucyhxdWVzdGlvbnMpLmNhdGNoKGNvbnNvbGVsb2dGdW5jdGlvbjtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgVHJhY2VHcm91cCB7XG4gICAgY29uc3RydWN0b3IoZ3JvdXBOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyb3VwTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ3JvdXBOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYW5hZ2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIoZ3JvdXBfbmFtZSwgaW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNiID0gbmV3IHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNtID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShbY2JdKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNtPy5oYW5kbGVDaGFpblN0YXJ0KHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiBbXCJsYW5nY2hhaW5cIiwgXCJjYWxsYmFja3NcIiwgXCJncm91cHNcIiwgZ3JvdXBfbmFtZV0sXG4gICAgICAgIH0sIGlucHV0cyA/PyB7fSk7XG4gICAgICAgIGlmICghcnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBydW4gZ3JvdXAgY2FsbGJhY2sgbWFuYWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KGlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRUcmFjZUdyb3VwQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuZ3JvdXBOYW1lLCBpbnB1dHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVuTWFuYWdlci5nZXRDaGlsZCgpO1xuICAgIH1cbiAgICBhc3luYyBlcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmQob3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVuZChvdXRwdXQgPz8ge30pO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFjZUdyb3VwID0gVHJhY2VHcm91cDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIHRyYWNlQXNHcm91cChncm91cE9wdGlvbnMsIGVuY2xvc2VkQ29kZSwgLi4uYXJncykge1xuICAgIGNvbnN0IHRyYWNlR3JvdXAgPSBuZXcgVHJhY2VHcm91cChncm91cE9wdGlvbnMubmFtZSwgZ3JvdXBPcHRpb25zKTtcbiAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBhd2FpdCB0cmFjZUdyb3VwLnN0YXJ0KHsgLi4uYXJncyB9KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmNsb3NlZENvZGUoY2FsbGJhY2tNYW5hZ2VyLCAuLi5hcmdzKTtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lbmQoX2NvZXJjZVRvRGljdChyZXN1bHQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVycm9yKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5leHBvcnRzLnRyYWNlQXNHcm91cCA9IHRyYWNlQXNHcm91cDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.cjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.awaitAllCallbacks = exports.consumeCallback = void 0;\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue = \"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        await promiseFn();\n    }\n    else {\n        if (typeof queue === \"undefined\") {\n            queue = createQueue();\n        }\n        void queue.add(promiseFn);\n    }\n}\nexports.consumeCallback = consumeCallback;\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nfunction awaitAllCallbacks() {\n    return typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve();\n}\nexports.awaitAllCallbacks = awaitAllCallbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHVCQUF1QjtBQUNuRCxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmNqcz9hMzdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hd2FpdEFsbENhbGxiYWNrcyA9IGV4cG9ydHMuY29uc3VtZUNhbGxiYWNrID0gdm9pZCAwO1xuY29uc3QgcF9xdWV1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwLXF1ZXVlXCIpKTtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gcF9xdWV1ZV8xLmRlZmF1bHQgPyBwX3F1ZXVlXzEuZGVmYXVsdC5kZWZhdWx0IDogcF9xdWV1ZV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb25zdW1lIGEgcHJvbWlzZSwgZWl0aGVyIGFkZGluZyBpdCB0byB0aGUgcXVldWUgb3Igd2FpdGluZyBmb3IgaXQgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHByb21pc2VGbiBQcm9taXNlIHRvIGNvbnN1bWVcbiAqIEBwYXJhbSB3YWl0IFdoZXRoZXIgdG8gd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBvciByZXNvbHZlIGltbWVkaWF0ZWx5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayhwcm9taXNlRm4sIHdhaXQpIHtcbiAgICBpZiAod2FpdCA9PT0gdHJ1ZSkge1xuICAgICAgICBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcXVldWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gY3JlYXRlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2b2lkIHF1ZXVlLmFkZChwcm9taXNlRm4pO1xuICAgIH1cbn1cbmV4cG9ydHMuY29uc3VtZUNhbGxiYWNrID0gY29uc3VtZUNhbGxiYWNrO1xuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIGluIHRoZSBxdWV1ZSB0byByZXNvbHZlLiBJZiB0aGUgcXVldWUgaXNcbiAqIHVuZGVmaW5lZCwgaXQgaW1tZWRpYXRlbHkgcmVzb2x2ZXMgYSBwcm9taXNlLlxuICovXG5mdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXVlICE9PSBcInVuZGVmaW5lZFwiID8gcXVldWUub25JZGxlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmV4cG9ydHMuYXdhaXRBbGxDYWxsYmFja3MgPSBhd2FpdEFsbENhbGxiYWNrcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Document = void 0;\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The ID field is optional at the moment.\n        // It will likely become required in a future major release after\n        // it has been adopted by enough vectorstore implementations.\n        /**\n         * An optional identifier for the document.\n         *\n         * Ideally this should be unique across the document collection and formatted\n         * as a UUID, but this will not be enforced.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent =\n            fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n        this.metadata = fields.metadata ?? {};\n        this.id = fields.id;\n    }\n}\nexports.Document = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2RvY3VtZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9kb2N1bWVudHMvZG9jdW1lbnQuY2pzPzFhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvY3VtZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggYSBkb2N1bWVudC5cbiAqL1xuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYWdlQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSUQgZmllbGQgaXMgb3B0aW9uYWwgYXQgdGhlIG1vbWVudC5cbiAgICAgICAgLy8gSXQgd2lsbCBsaWtlbHkgYmVjb21lIHJlcXVpcmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UgYWZ0ZXJcbiAgICAgICAgLy8gaXQgaGFzIGJlZW4gYWRvcHRlZCBieSBlbm91Z2ggdmVjdG9yc3RvcmUgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgaWRlbnRpZmllciBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZGVhbGx5IHRoaXMgc2hvdWxkIGJlIHVuaXF1ZSBhY3Jvc3MgdGhlIGRvY3VtZW50IGNvbGxlY3Rpb24gYW5kIGZvcm1hdHRlZFxuICAgICAgICAgKiBhcyBhIFVVSUQsIGJ1dCB0aGlzIHdpbGwgbm90IGJlIGVuZm9yY2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYWdlQ29udGVudCA9XG4gICAgICAgICAgICBmaWVsZHMucGFnZUNvbnRlbnQgIT09IHVuZGVmaW5lZCA/IGZpZWxkcy5wYWdlQ29udGVudC50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IGZpZWxkcy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG59XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./document.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsd0ZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmNqcz8yNTc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZG9jdW1lbnQuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1lcnMuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MappingDocumentTransformer = exports.BaseDocumentTransformer = void 0;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends base_js_1.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\nexports.BaseDocumentTransformer = BaseDocumentTransformer;\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\nexports.MappingDocumentTransformer = MappingDocumentTransformer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL3RyYW5zZm9ybWVycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsK0JBQStCO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL3RyYW5zZm9ybWVycy5janM/NGRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXIgPSBleHBvcnRzLkJhc2VEb2N1bWVudFRyYW5zZm9ybWVyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24gc3lzdGVtcy5cbiAqXG4gKiBBIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uIHN5c3RlbSB0YWtlcyBhbiBhcnJheSBvZiBEb2N1bWVudHMgYW5kIHJldHVybnMgYW5cbiAqIGFycmF5IG9mIHRyYW5zZm9ybWVkIERvY3VtZW50cy4gVGhlc2UgYXJyYXlzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGhhdmVcbiAqIHRoZSBzYW1lIGxlbmd0aC5cbiAqXG4gKiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIGEgdGV4dCBzcGxpdHRlciB0aGF0IHNwbGl0cyBhIGxhcmdlIGRvY3VtZW50IGludG9cbiAqIG1hbnkgc21hbGxlciBkb2N1bWVudHMuXG4gKi9cbmNsYXNzIEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgYmFzZV9qc18xLlJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImRvY3VtZW50c1wiLCBcInRyYW5zZm9ybWVyc1wiXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGludm9rZSB0aGUgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uIFRoaXMgbWV0aG9kIGNhbGxzIHRoZVxuICAgICAqIHRyYW5zZm9ybURvY3VtZW50cyBtZXRob2Qgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBkb2N1bWVudHMgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2YgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudHMuXG4gICAgICovXG4gICAgaW52b2tlKGlucHV0LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Eb2N1bWVudHMoaW5wdXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgPSBCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lcjtcbi8qKlxuICogQ2xhc3MgZm9yIGRvY3VtZW50IHRyYW5zZm9ybWVycyB0aGF0IHJldHVybiBleGFjdGx5IG9uZSB0cmFuc2Zvcm1lZCBkb2N1bWVudFxuICogZm9yIGVhY2ggaW5wdXQgZG9jdW1lbnQuXG4gKi9cbmNsYXNzIE1hcHBpbmdEb2N1bWVudFRyYW5zZm9ybWVyIGV4dGVuZHMgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIge1xuICAgIGFzeW5jIHRyYW5zZm9ybURvY3VtZW50cyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgbmV3RG9jdW1lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZERvY3VtZW50ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgbmV3RG9jdW1lbnRzLnB1c2godHJhbnNmb3JtZWREb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RvY3VtZW50cztcbiAgICB9XG59XG5leHBvcnRzLk1hcHBpbmdEb2N1bWVudFRyYW5zZm9ybWVyID0gTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/embeddings.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Embeddings = void 0;\nconst async_caller_js_1 = __webpack_require__(/*! ./utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nclass Embeddings {\n    constructor(params) {\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n}\nexports.Embeddings = Embeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDBCQUEwQixtQkFBTyxDQUFDLGtHQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZW1iZWRkaW5ncy5janM/MGI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmNqc1wiKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBlbWJlZGRpbmcgZG9jdW1lbnRzIGFuZFxuICogcXVlcmllcyB1c2luZyBMYW5nQ2hhaW4uXG4gKi9cbmNsYXNzIEVtYmVkZGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzeW5jIGNhbGxlciBzaG91bGQgYmUgdXNlZCBieSBzdWJjbGFzc2VzIHRvIG1ha2UgYW55IGFzeW5jIGNhbGxzLFxuICAgICAgICAgKiB3aGljaCB3aWxsIHRodXMgYmVuZWZpdCBmcm9tIHRoZSBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyX2pzXzEuQXN5bmNDYWxsZXIocGFyYW1zID8/IHt9KTtcbiAgICB9XG59XG5leHBvcnRzLkVtYmVkZGluZ3MgPSBFbWJlZGRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/errors/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-param-reassign */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addLangChainErrorFields = void 0;\nfunction addLangChainErrorFields(error, lc_error_code) {\n    error.lc_error_code = lc_error_code;\n    error.message = `${error.message}\\n\\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/\\n`;\n    return error;\n}\nexports.addLangChainErrorFields = addLangChainErrorFields;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXJyb3JzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxnRkFBZ0YsY0FBYztBQUNuSTtBQUNBO0FBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2Vycm9ycy9pbmRleC5janM/NGM0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZExhbmdDaGFpbkVycm9yRmllbGRzID0gdm9pZCAwO1xuZnVuY3Rpb24gYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMoZXJyb3IsIGxjX2Vycm9yX2NvZGUpIHtcbiAgICBlcnJvci5sY19lcnJvcl9jb2RlID0gbGNfZXJyb3JfY29kZTtcbiAgICBlcnJvci5tZXNzYWdlID0gYCR7ZXJyb3IubWVzc2FnZX1cXG5cXG5Ucm91Ymxlc2hvb3RpbmcgVVJMOiBodHRwczovL2pzLmxhbmdjaGFpbi5jb20vZG9jcy90cm91Ymxlc2hvb3RpbmcvZXJyb3JzLyR7bGNfZXJyb3JfY29kZX0vXFxuYDtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLmFkZExhbmdDaGFpbkVycm9yRmllbGRzID0gYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/base.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseLanguageModel = exports.BaseLangChain = exports.calculateMaxTokens = exports.isOpenAITool = exports.getModelContextSize = exports.getEmbeddingContextSize = exports.getModelNameForTiktoken = void 0;\nconst base_js_1 = __webpack_require__(/*! ../caches/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst tiktoken_js_1 = __webpack_require__(/*! ../utils/tiktoken.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n// https://www.npmjs.com/package/js-tiktoken\nconst getModelNameForTiktoken = (modelName) => {\n    if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n        return \"gpt-3.5-turbo-16k\";\n    }\n    if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n        return \"gpt-3.5-turbo\";\n    }\n    if (modelName.startsWith(\"gpt-4-32k\")) {\n        return \"gpt-4-32k\";\n    }\n    if (modelName.startsWith(\"gpt-4-\")) {\n        return \"gpt-4\";\n    }\n    if (modelName.startsWith(\"gpt-4o\")) {\n        return \"gpt-4o\";\n    }\n    return modelName;\n};\nexports.getModelNameForTiktoken = getModelNameForTiktoken;\nconst getEmbeddingContextSize = (modelName) => {\n    switch (modelName) {\n        case \"text-embedding-ada-002\":\n            return 8191;\n        default:\n            return 2046;\n    }\n};\nexports.getEmbeddingContextSize = getEmbeddingContextSize;\nconst getModelContextSize = (modelName) => {\n    switch ((0, exports.getModelNameForTiktoken)(modelName)) {\n        case \"gpt-3.5-turbo-16k\":\n            return 16384;\n        case \"gpt-3.5-turbo\":\n            return 4096;\n        case \"gpt-4-32k\":\n            return 32768;\n        case \"gpt-4\":\n            return 8192;\n        case \"text-davinci-003\":\n            return 4097;\n        case \"text-curie-001\":\n            return 2048;\n        case \"text-babbage-001\":\n            return 2048;\n        case \"text-ada-001\":\n            return 2048;\n        case \"code-davinci-002\":\n            return 8000;\n        case \"code-cushman-001\":\n            return 2048;\n        default:\n            return 4097;\n    }\n};\nexports.getModelContextSize = getModelContextSize;\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nfunction isOpenAITool(tool) {\n    if (typeof tool !== \"object\" || !tool)\n        return false;\n    if (\"type\" in tool &&\n        tool.type === \"function\" &&\n        \"function\" in tool &&\n        typeof tool.function === \"object\" &&\n        tool.function &&\n        \"name\" in tool.function &&\n        \"parameters\" in tool.function) {\n        return true;\n    }\n    return false;\n}\nexports.isOpenAITool = isOpenAITool;\nconst calculateMaxTokens = async ({ prompt, modelName, }) => {\n    let numTokens;\n    try {\n        numTokens = (await (0, tiktoken_js_1.encodingForModel)((0, exports.getModelNameForTiktoken)(modelName))).encode(prompt).length;\n    }\n    catch (error) {\n        console.warn(\"Failed to calculate number of tokens, falling back to approximate count\");\n        // fallback to approximate calculation if tiktoken is not available\n        // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n        numTokens = Math.ceil(prompt.length / 4);\n    }\n    const maxTokens = (0, exports.getModelContextSize)(modelName);\n    return maxTokens - numTokens;\n};\nexports.calculateMaxTokens = calculateMaxTokens;\nconst getVerbosity = () => false;\n/**\n * Base class for language models, chains, tools.\n */\nclass BaseLangChain extends base_js_2.Runnable {\n    get lc_attributes() {\n        return {\n            callbacks: undefined,\n            verbose: undefined,\n        };\n    }\n    constructor(params) {\n        super(params);\n        /**\n         * Whether to print out response text.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verbose = params.verbose ?? getVerbosity();\n        this.callbacks = params.callbacks;\n        this.tags = params.tags ?? [];\n        this.metadata = params.metadata ?? {};\n    }\n}\nexports.BaseLangChain = BaseLangChain;\n/**\n * Base class for language models.\n */\nclass BaseLanguageModel extends BaseLangChain {\n    /**\n     * Keys that the language model accepts as call options.\n     */\n    get callKeys() {\n        return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n    }\n    constructor({ callbacks, callbackManager, ...params }) {\n        const { cache, ...rest } = params;\n        super({\n            callbacks: callbacks ?? callbackManager,\n            ...rest,\n        });\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_encoding\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof cache === \"object\") {\n            this.cache = cache;\n        }\n        else if (cache) {\n            this.cache = base_js_1.InMemoryCache.global();\n        }\n        else {\n            this.cache = undefined;\n        }\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n    async getNumTokens(content) {\n        // TODO: Figure out correct value.\n        if (typeof content !== \"string\") {\n            return 0;\n        }\n        // fallback to approximate calculation if tiktoken is not available\n        let numTokens = Math.ceil(content.length / 4);\n        if (!this._encoding) {\n            try {\n                this._encoding = await (0, tiktoken_js_1.encodingForModel)(\"modelName\" in this\n                    ? (0, exports.getModelNameForTiktoken)(this.modelName)\n                    : \"gpt2\");\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        if (this._encoding) {\n            try {\n                numTokens = this._encoding.encode(content).length;\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        return numTokens;\n    }\n    static _convertInputToPromptValue(input) {\n        if (typeof input === \"string\") {\n            return new prompt_values_js_1.StringPromptValue(input);\n        }\n        else if (Array.isArray(input)) {\n            return new prompt_values_js_1.ChatPromptValue(input.map(utils_js_1.coerceMessageLikeToMessage));\n        }\n        else {\n            return input;\n        }\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * Create a unique cache key for a specific call to a specific language model.\n     * @param callOptions Call options for the model\n     * @returns A unique cache key.\n     */\n    _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const params = {\n            ...this._identifyingParams(),\n            ...callOptions,\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== undefined);\n        const serializedEntries = filteredEntries\n            .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n            .sort()\n            .join(\",\");\n        return serializedEntries;\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * @deprecated\n     * Load an LLM from a json-like object describing it.\n     */\n    static async deserialize(_data) {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n}\nexports.BaseLanguageModel = BaseLanguageModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLCtCQUErQjtBQUN2TSxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDOUMsMkJBQTJCLG1CQUFPLENBQUMseUZBQXNCO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1Q0FBdUM7QUFDekQsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJLEdBQUcsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzPzU5MmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VMYW5ndWFnZU1vZGVsID0gZXhwb3J0cy5CYXNlTGFuZ0NoYWluID0gZXhwb3J0cy5jYWxjdWxhdGVNYXhUb2tlbnMgPSBleHBvcnRzLmlzT3BlbkFJVG9vbCA9IGV4cG9ydHMuZ2V0TW9kZWxDb250ZXh0U2l6ZSA9IGV4cG9ydHMuZ2V0RW1iZWRkaW5nQ29udGV4dFNpemUgPSBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL2NhY2hlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IHByb21wdF92YWx1ZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm9tcHRfdmFsdWVzLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHMuY2pzXCIpO1xuY29uc3QgYXN5bmNfY2FsbGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvYXN5bmNfY2FsbGVyLmNqc1wiKTtcbmNvbnN0IHRpa3Rva2VuX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdGlrdG9rZW4uY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbi8vIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2pzLXRpa3Rva2VuXG5jb25zdCBnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbiA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtMy41LXR1cmJvLTE2a1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtMy41LXR1cmJvLTE2a1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtMy41LXR1cmJvLVwiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtMy41LXR1cmJvXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00LTMya1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNC0zMmtcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTQtXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00XCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00b1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNG9cIjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsTmFtZTtcbn07XG5leHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuID0gZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW47XG5jb25zdCBnZXRFbWJlZGRpbmdDb250ZXh0U2l6ZSA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBzd2l0Y2ggKG1vZGVsTmFtZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgxOTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMjA0NjtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRFbWJlZGRpbmdDb250ZXh0U2l6ZSA9IGdldEVtYmVkZGluZ0NvbnRleHRTaXplO1xuY29uc3QgZ2V0TW9kZWxDb250ZXh0U2l6ZSA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBzd2l0Y2ggKCgwLCBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuKShtb2RlbE5hbWUpKSB7XG4gICAgICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTE2a1wiOlxuICAgICAgICAgICAgcmV0dXJuIDE2Mzg0O1xuICAgICAgICBjYXNlIFwiZ3B0LTMuNS10dXJib1wiOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTY7XG4gICAgICAgIGNhc2UgXCJncHQtNC0zMmtcIjpcbiAgICAgICAgICAgIHJldHVybiAzMjc2ODtcbiAgICAgICAgY2FzZSBcImdwdC00XCI6XG4gICAgICAgICAgICByZXR1cm4gODE5MjtcbiAgICAgICAgY2FzZSBcInRleHQtZGF2aW5jaS0wMDNcIjpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgICAgICBjYXNlIFwidGV4dC1jdXJpZS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwidGV4dC1iYWJiYWdlLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWFkYS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwiY29kZS1kYXZpbmNpLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgwMDA7XG4gICAgICAgIGNhc2UgXCJjb2RlLWN1c2htYW4tMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgIH1cbn07XG5leHBvcnRzLmdldE1vZGVsQ29udGV4dFNpemUgPSBnZXRNb2RlbENvbnRleHRTaXplO1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgbWF0Y2hlcyB0aGUgT3BlbkFJIHRvb2wgZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdG9vbCBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaW5wdXQgaXMgYW4gT3BlbkFJIHRvb2wgZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNPcGVuQUlUb29sKHRvb2wpIHtcbiAgICBpZiAodHlwZW9mIHRvb2wgIT09IFwib2JqZWN0XCIgfHwgIXRvb2wpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gdG9vbCAmJlxuICAgICAgICB0b29sLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgaW4gdG9vbCAmJlxuICAgICAgICB0eXBlb2YgdG9vbC5mdW5jdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0b29sLmZ1bmN0aW9uICYmXG4gICAgICAgIFwibmFtZVwiIGluIHRvb2wuZnVuY3Rpb24gJiZcbiAgICAgICAgXCJwYXJhbWV0ZXJzXCIgaW4gdG9vbC5mdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc09wZW5BSVRvb2wgPSBpc09wZW5BSVRvb2w7XG5jb25zdCBjYWxjdWxhdGVNYXhUb2tlbnMgPSBhc3luYyAoeyBwcm9tcHQsIG1vZGVsTmFtZSwgfSkgPT4ge1xuICAgIGxldCBudW1Ub2tlbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgbnVtVG9rZW5zID0gKGF3YWl0ICgwLCB0aWt0b2tlbl9qc18xLmVuY29kaW5nRm9yTW9kZWwpKCgwLCBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuKShtb2RlbE5hbWUpKSkuZW5jb2RlKHByb21wdCkubGVuZ3RoO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIik7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcHJveGltYXRlIGNhbGN1bGF0aW9uIGlmIHRpa3Rva2VuIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgLy8gZWFjaCB0b2tlbiBpcyB+NCBjaGFyYWN0ZXJzOiBodHRwczovL2hlbHAub3BlbmFpLmNvbS9lbi9hcnRpY2xlcy80OTM2ODU2LXdoYXQtYXJlLXRva2Vucy1hbmQtaG93LXRvLWNvdW50LXRoZW0jXG4gICAgICAgIG51bVRva2VucyA9IE1hdGguY2VpbChwcm9tcHQubGVuZ3RoIC8gNCk7XG4gICAgfVxuICAgIGNvbnN0IG1heFRva2VucyA9ICgwLCBleHBvcnRzLmdldE1vZGVsQ29udGV4dFNpemUpKG1vZGVsTmFtZSk7XG4gICAgcmV0dXJuIG1heFRva2VucyAtIG51bVRva2Vucztcbn07XG5leHBvcnRzLmNhbGN1bGF0ZU1heFRva2VucyA9IGNhbGN1bGF0ZU1heFRva2VucztcbmNvbnN0IGdldFZlcmJvc2l0eSA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYW5ndWFnZSBtb2RlbHMsIGNoYWlucywgdG9vbHMuXG4gKi9cbmNsYXNzIEJhc2VMYW5nQ2hhaW4gZXh0ZW5kcyBiYXNlX2pzXzIuUnVubmFibGUge1xuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2ZXJib3NlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBwcmludCBvdXQgcmVzcG9uc2UgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmJvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gcGFyYW1zLnZlcmJvc2UgPz8gZ2V0VmVyYm9zaXR5KCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgdGhpcy50YWdzID0gcGFyYW1zLnRhZ3MgPz8gW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgPz8ge307XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTGFuZ0NoYWluID0gQmFzZUxhbmdDaGFpbjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGFuZ3VhZ2UgbW9kZWxzLlxuICovXG5jbGFzcyBCYXNlTGFuZ3VhZ2VNb2RlbCBleHRlbmRzIEJhc2VMYW5nQ2hhaW4ge1xuICAgIC8qKlxuICAgICAqIEtleXMgdGhhdCB0aGUgbGFuZ3VhZ2UgbW9kZWwgYWNjZXB0cyBhcyBjYWxsIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGNhbGxLZXlzKCkge1xuICAgICAgICByZXR1cm4gW1wic3RvcFwiLCBcInRpbWVvdXRcIiwgXCJzaWduYWxcIiwgXCJ0YWdzXCIsIFwibWV0YWRhdGFcIiwgXCJjYWxsYmFja3NcIl07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgY2FsbGJhY2tzLCBjYWxsYmFja01hbmFnZXIsIC4uLnBhcmFtcyB9KSB7XG4gICAgICAgIGNvbnN0IHsgY2FjaGUsIC4uLnJlc3QgfSA9IHBhcmFtcztcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBjYWxsYmFja3MgPz8gY2FsbGJhY2tNYW5hZ2VyLFxuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW5jb2RpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gYmFzZV9qc18xLkluTWVtb3J5Q2FjaGUuZ2xvYmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IGFzeW5jX2NhbGxlcl9qc18xLkFzeW5jQ2FsbGVyKHBhcmFtcyA/PyB7fSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE51bVRva2Vucyhjb250ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgY29ycmVjdCB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHByb3hpbWF0ZSBjYWxjdWxhdGlvbiBpZiB0aWt0b2tlbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGxldCBudW1Ub2tlbnMgPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyA0KTtcbiAgICAgICAgaWYgKCF0aGlzLl9lbmNvZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGF3YWl0ICgwLCB0aWt0b2tlbl9qc18xLmVuY29kaW5nRm9yTW9kZWwpKFwibW9kZWxOYW1lXCIgaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBleHBvcnRzLmdldE1vZGVsTmFtZUZvclRpa3Rva2VuKSh0aGlzLm1vZGVsTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiBcImdwdDJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VuY29kaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG51bVRva2VucyA9IHRoaXMuX2VuY29kaW5nLmVuY29kZShjb250ZW50KS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRva2VucztcbiAgICB9XG4gICAgc3RhdGljIF9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbXB0X3ZhbHVlc19qc18xLlN0cmluZ1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9tcHRfdmFsdWVzX2pzXzEuQ2hhdFByb21wdFZhbHVlKGlucHV0Lm1hcCh1dGlsc19qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGlmeWluZyBwYXJhbWV0ZXJzIG9mIHRoZSBMTE0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfaWRlbnRpZnlpbmdQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdW5pcXVlIGNhY2hlIGtleSBmb3IgYSBzcGVjaWZpYyBjYWxsIHRvIGEgc3BlY2lmaWMgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIGNhbGxPcHRpb25zIENhbGwgb3B0aW9ucyBmb3IgdGhlIG1vZGVsXG4gICAgICogQHJldHVybnMgQSB1bmlxdWUgY2FjaGUga2V5LlxuICAgICAqL1xuICAgIF9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChcbiAgICAvLyBUT0RPOiBGaXggd2hlbiB3ZSByZW1vdmUgdGhlIFJ1bm5hYmxlTGFtYmRhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHNoaW0uXG4gICAgeyBjb25maWcsIC4uLmNhbGxPcHRpb25zIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIC4uLmNhbGxPcHRpb25zLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVudHJpZXMgPSBmaWx0ZXJlZEVudHJpZXNcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZEVudHJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIExvYWQgYW4gTExNIGZyb20gYSBqc29uLWxpa2Ugb2JqZWN0IGRlc2NyaWJpbmcgaXQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSAudG9KU09OKCkgaW5zdGVhZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VMYW5ndWFnZU1vZGVsID0gQmFzZUxhbmd1YWdlTW9kZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/chat_models.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleChatModel = exports.BaseChatModel = exports.createChatMessageChunkEncoderStream = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst event_stream_js_1 = __webpack_require__(/*! ../tracers/event_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ../runnables/passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nconst is_zod_schema_js_1 = __webpack_require__(/*! ../utils/types/is_zod_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs\");\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nfunction createChatMessageChunkEncoderStream() {\n    const textEncoder = new TextEncoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                ? chunk.content\n                : JSON.stringify(chunk.content)));\n        },\n    });\n}\nexports.createChatMessageChunkEncoderStream = createChatMessageChunkEncoderStream;\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nclass BaseChatModel extends base_js_1.BaseLanguageModel {\n    constructor(fields) {\n        super(fields);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"chat_models\", this._llmType()]\n        });\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    /**\n     * Invokes the chat model with a single input.\n     * @param input The input for the language model.\n     * @param options The call options.\n     * @returns A Promise that resolves to a BaseMessageChunk.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseChatModel._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        const chatGeneration = result.generations[0][0];\n        // TODO: Remove cast after figuring out inheritance\n        return chatGeneration.message;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_messages, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks ===\n            BaseChatModel.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseChatModel._convertInputToPromptValue(input);\n            const messages = prompt.toChatMessages();\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const inheritableMetadata = {\n                ...runnableConfig.metadata,\n                ...this.getLsParams(callOptions),\n            };\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [messages], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generationChunk;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let llmOutput;\n            try {\n                for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    chunk.message.response_metadata = {\n                        ...chunk.generationInfo,\n                        ...chunk.message.response_metadata,\n                    };\n                    yield chunk.message;\n                    if (!generationChunk) {\n                        generationChunk = chunk;\n                    }\n                    else {\n                        generationChunk = generationChunk.concat(chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                // TODO: Remove cast after figuring out inheritance\n                generations: [[generationChunk]],\n                llmOutput,\n            })));\n        }\n    }\n    getLsParams(options) {\n        const providerName = this.getName().startsWith(\"Chat\")\n            ? this.getName().replace(\"Chat\", \"\")\n            : this.getName();\n        return {\n            ls_model_type: \"chat\",\n            ls_stop: options.stop,\n            ls_provider: providerName,\n        };\n    }\n    /** @ignore */\n    async _generateUncached(messages, parsedOptions, handledOptions) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const inheritableMetadata = {\n            ...handledOptions.metadata,\n            ...this.getLsParams(parsedOptions),\n        };\n        // create callback manager and start run\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        const generations = [];\n        const llmOutputs = [];\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find((handler) => {\n            return (0, event_stream_js_1.isStreamEventsHandler)(handler) || (0, log_stream_js_1.isLogStreamHandler)(handler);\n        });\n        if (hasStreamingHandler &&\n            baseMessages.length === 1 &&\n            this._streamResponseChunks !==\n                BaseChatModel.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let llmOutput;\n                for await (const chunk of stream) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                generations.push([aggregated]);\n                await runManagers?.[0].handleLLMEnd({\n                    generations,\n                    llmOutput,\n                });\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            // generate results\n            const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n            // handle results\n            await Promise.all(results.map(async (pResult, i) => {\n                if (pResult.status === \"fulfilled\") {\n                    const result = pResult.value;\n                    for (const generation of result.generations) {\n                        if (generation.message.id == null) {\n                            const runId = runManagers?.at(0)?.runId;\n                            if (runId != null)\n                                generation.message._updateId(`run-${runId}`);\n                        }\n                        generation.message.response_metadata = {\n                            ...generation.generationInfo,\n                            ...generation.message.response_metadata,\n                        };\n                    }\n                    if (result.generations.length === 1) {\n                        result.generations[0].message.response_metadata = {\n                            ...result.llmOutput,\n                            ...result.generations[0].message.response_metadata,\n                        };\n                    }\n                    generations[i] = result.generations;\n                    llmOutputs[i] = result.llmOutput;\n                    return runManagers?.[i]?.handleLLMEnd({\n                        generations: [result.generations],\n                        llmOutput: result.llmOutput,\n                    });\n                }\n                else {\n                    // status === \"rejected\"\n                    await runManagers?.[i]?.handleLLMError(pResult.reason);\n                    return Promise.reject(pResult.reason);\n                }\n            }));\n        }\n        // create combined output\n        const output = {\n            generations,\n            llmOutput: llmOutputs.length\n                ? this._combineLLMOutput?.(...llmOutputs)\n                : undefined,\n        };\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const inheritableMetadata = {\n            ...handledOptions.metadata,\n            ...this.getLsParams(parsedOptions),\n        };\n        // create callback manager and start run\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n            cached: true,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n            // Join all content into one string for the prompt index\n            const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result;\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason);\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Generates chat based on the input messages.\n     * @param messages An array of arrays of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generate(messages, options, callbacks) {\n        // parse call options\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(baseMessages, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices } = await this._generateCached({\n            messages: baseMessages,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                // Join all content into one string for the prompt index\n                const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                return cache.update(prompt, llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _modelType() {\n        return \"base_chat_model\";\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this.invocationParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * Generates a prompt based on the input prompt values.\n     * @param promptValues An array of BasePromptValue instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n        return this.generate(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async call(messages, options, callbacks) {\n        const result = await this.generate([messages.map(index_js_1.coerceMessageLikeToMessage)], options, callbacks);\n        const generations = result.generations;\n        return generations[0][0].message;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model with a prompt value.\n     * @param promptValue The value of the prompt.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async callPrompt(promptValue, options, callbacks) {\n        const promptMessages = promptValue.toChatMessages();\n        return this.call(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on the input messages.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async predictMessages(messages, options, callbacks) {\n        return this.call(messages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on a text input.\n     * @param text The text input.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a string.\n     */\n    async predict(text, options, callbacks) {\n        const message = new index_js_1.HumanMessage(text);\n        const result = await this.call([message], options, callbacks);\n        if (typeof result.content !== \"string\") {\n            throw new Error(\"Cannot use predict when output is not a string.\");\n        }\n        return result.content;\n    }\n    withStructuredOutput(outputSchema, config) {\n        if (typeof this.bindTools !== \"function\") {\n            throw new Error(`Chat model must implement \".bindTools()\" to use withStructuredOutput.`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = schema.description ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0, is_zod_schema_js_1.isZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0, zod_to_json_schema_1.zodToJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const llm = this.bindTools(tools);\n        const outputParser = base_js_2.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = passthrough_js_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = passthrough_js_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return base_js_2.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.BaseChatModel = BaseChatModel;\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nclass SimpleChatModel extends BaseChatModel {\n    async _generate(messages, options, runManager) {\n        const text = await this._call(messages, options, runManager);\n        const message = new index_js_1.AIMessage(text);\n        if (typeof message.content !== \"string\") {\n            throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n        }\n        return {\n            generations: [\n                {\n                    text: message.content,\n                    message,\n                },\n            ],\n        };\n    }\n}\nexports.SimpleChatModel = SimpleChatModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRywyQ0FBMkM7QUFDN0YsNkJBQTZCLG1CQUFPLENBQUMscUZBQW9CO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsc0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDL0Qsd0JBQXdCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCx5QkFBeUIsbUJBQU8sQ0FBQyx5R0FBOEI7QUFDL0QsMkJBQTJCLG1CQUFPLENBQUMsaUhBQWtDO0FBQ3JFO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtNQUFrTSx1QkFBdUI7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLHVCQUF1QjtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxrQ0FBa0M7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLHVCQUF1QjtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQ0FBMEM7QUFDakYsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1DQUFtQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sYW5ndWFnZV9tb2RlbHMvY2hhdF9tb2RlbHMuY2pzP2Y2MDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUNoYXRNb2RlbCA9IGV4cG9ydHMuQmFzZUNoYXRNb2RlbCA9IGV4cG9ydHMuY3JlYXRlQ2hhdE1lc3NhZ2VDaHVua0VuY29kZXJTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCB6b2RfdG9fanNvbl9zY2hlbWFfMSA9IHJlcXVpcmUoXCJ6b2QtdG8tanNvbi1zY2hlbWFcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2luZGV4LmNqc1wiKTtcbmNvbnN0IG91dHB1dHNfanNfMSA9IHJlcXVpcmUoXCIuLi9vdXRwdXRzLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMiA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG5jb25zdCBldmVudF9zdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2V2ZW50X3N0cmVhbS5janNcIik7XG5jb25zdCBsb2dfc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9sb2dfc3RyZWFtLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5jb25zdCBwYXNzdGhyb3VnaF9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5janNcIik7XG5jb25zdCBpc196b2Rfc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdHlwZXMvaXNfem9kX3NjaGVtYS5janNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIGZvciBlbmNvZGluZyBjaGF0IG1lc3NhZ2UgY2h1bmtzLlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBCeXRlc091dHB1dFBhcnNlcn0gaW5zdGVhZFxuICogQHJldHVybnMgQSBUcmFuc2Zvcm1TdHJlYW0gaW5zdGFuY2UgdGhhdCBlbmNvZGVzIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYXRNZXNzYWdlQ2h1bmtFbmNvZGVyU3RyZWFtKCkge1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUodHlwZW9mIGNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGNodW5rLmNvbnRlbnRcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGNodW5rLmNvbnRlbnQpKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUNoYXRNZXNzYWdlQ2h1bmtFbmNvZGVyU3RyZWFtID0gY3JlYXRlQ2hhdE1lc3NhZ2VDaHVua0VuY29kZXJTdHJlYW07XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNoYXQgbW9kZWxzLiBJdCBleHRlbmRzIHRoZSBCYXNlTGFuZ3VhZ2VNb2RlbCBjbGFzcyBhbmRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgY2hhdCBiYXNlZCBvbiBpbnB1dCBtZXNzYWdlcy5cbiAqL1xuY2xhc3MgQmFzZUNoYXRNb2RlbCBleHRlbmRzIGJhc2VfanNfMS5CYXNlTGFuZ3VhZ2VNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIC8vIE9ubHkgZXZlciBpbnN0YW50aWF0ZWQgaW4gbWFpbiBMYW5nQ2hhaW5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJjaGF0X21vZGVsc1wiLCB0aGlzLl9sbG1UeXBlKCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0LCBrZWVwIGBzaWduYWxgIGluIGJvdGggcnVubmFibGVDb25maWcgYW5kIGNhbGxPcHRpb25zXG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gc3VwZXIuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNhbGxPcHRpb25zLnNpZ25hbCA9IHJ1bm5hYmxlQ29uZmlnLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBjaGF0IG1vZGVsIHdpdGggYSBzaW5nbGUgaW5wdXQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZUNodW5rLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHRWYWx1ZSA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlUHJvbXB0KFtwcm9tcHRWYWx1ZV0sIG9wdGlvbnMsIG9wdGlvbnM/LmNhbGxiYWNrcyk7XG4gICAgICAgIGNvbnN0IGNoYXRHZW5lcmF0aW9uID0gcmVzdWx0LmdlbmVyYXRpb25zWzBdWzBdO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdCBhZnRlciBmaWd1cmluZyBvdXQgaW5oZXJpdGFuY2VcbiAgICAgICAgcmV0dXJuIGNoYXRHZW5lcmF0aW9uLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfbWVzc2FnZXMsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzIGNoZWNrIHJlcXVpcmVkIHRvIGF2b2lkIGRvdWJsZSBjYWxsYmFja3Mgd2l0aCBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyA9PT1cbiAgICAgICAgICAgIEJhc2VDaGF0TW9kZWwucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdC50b0NoYXRNZXNzYWdlcygpO1xuICAgICAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ydW5uYWJsZUNvbmZpZy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdldExzUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocnVubmFibGVDb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgcnVubmFibGVDb25maWcudGFncywgdGhpcy50YWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgW21lc3NhZ2VzXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uQ2h1bms7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IGxsbU91dHB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgY2FsbE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuay5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdlbmVyYXRpb25DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uQ2h1bmsgPSBnZW5lcmF0aW9uQ2h1bmsuY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNBSU1lc3NhZ2VDaHVuaykoY2h1bmsubWVzc2FnZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgY2FzdCBhZnRlciBmaWd1cmluZyBvdXQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uQ2h1bmtdXSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExzUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gdGhpcy5nZXROYW1lKCkuc3RhcnRzV2l0aChcIkNoYXRcIilcbiAgICAgICAgICAgID8gdGhpcy5nZXROYW1lKCkucmVwbGFjZShcIkNoYXRcIiwgXCJcIilcbiAgICAgICAgICAgIDogdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsc19tb2RlbF90eXBlOiBcImNoYXRcIixcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBwcm92aWRlck5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2dlbmVyYXRlVW5jYWNoZWQobWVzc2FnZXMsIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QpID0+IG1lc3NhZ2VMaXN0Lm1hcChpbmRleF9qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5oYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0THNQYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSBjYWxsYmFjayBtYW5hZ2VyIGFuZCBzdGFydCBydW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBiYXNlTWVzc2FnZXMsIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnMucnVuTmFtZSk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IGxsbU91dHB1dHMgPSBbXTtcbiAgICAgICAgLy8gRXZlbiBpZiBzdHJlYW0gaXMgbm90IGV4cGxpY2l0bHkgY2FsbGVkLCBjaGVjayBpZiBtb2RlbCBpcyBpbXBsaWNpdGx5XG4gICAgICAgIC8vIGNhbGxlZCBmcm9tIHN0cmVhbUV2ZW50cygpIG9yIHN0cmVhbUxvZygpIHRvIGdldCBhbGwgc3RyZWFtZWQgZXZlbnRzLlxuICAgICAgICAvLyBCYWlsIG91dCBpZiBfc3RyZWFtUmVzcG9uc2VDaHVua3Mgbm90IG92ZXJyaWRkZW5cbiAgICAgICAgY29uc3QgaGFzU3RyZWFtaW5nSGFuZGxlciA9ICEhcnVuTWFuYWdlcnM/LlswXS5oYW5kbGVycy5maW5kKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV2ZW50X3N0cmVhbV9qc18xLmlzU3RyZWFtRXZlbnRzSGFuZGxlcikoaGFuZGxlcikgfHwgKDAsIGxvZ19zdHJlYW1fanNfMS5pc0xvZ1N0cmVhbUhhbmRsZXIpKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc1N0cmVhbWluZ0hhbmRsZXIgJiZcbiAgICAgICAgICAgIGJhc2VNZXNzYWdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzICE9PVxuICAgICAgICAgICAgICAgIEJhc2VDaGF0TW9kZWwucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhiYXNlTWVzc2FnZXNbMF0sIHBhcnNlZE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pO1xuICAgICAgICAgICAgICAgIGxldCBhZ2dyZWdhdGVkO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbGV0IGxsbU91dHB1dDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5JZCA9IHJ1bk1hbmFnZXJzPy5hdCgwKT8ucnVuSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLl91cGRhdGVJZChgcnVuLSR7cnVuSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGFnZ3JlZ2F0ZWQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzEuaXNBSU1lc3NhZ2VDaHVuaykoY2h1bmsubWVzc2FnZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlZCBlbXB0eSByZXNwb25zZSBmcm9tIGNoYXQgbW9kZWwgY2FsbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zLnB1c2goW2FnZ3JlZ2F0ZWRdKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlTExNRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmFzZU1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QsIGkpID0+IHRoaXMuX2dlbmVyYXRlKG1lc3NhZ2VMaXN0LCB7IC4uLnBhcnNlZE9wdGlvbnMsIHByb21wdEluZGV4OiBpIH0sIHJ1bk1hbmFnZXJzPy5baV0pKSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVzdWx0c1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoYXN5bmMgKHBSZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocFJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcFJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIHJlc3VsdC5nZW5lcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb24ubWVzc2FnZS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuSWQgPSBydW5NYW5hZ2Vycz8uYXQoMCk/LnJ1bklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZW5lcmF0aW9uLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdlbmVyYXRpb24ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5nZW5lcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZW5lcmF0aW9uc1swXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LmdlbmVyYXRpb25zWzBdLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0LmdlbmVyYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXRzW2ldID0gcmVzdWx0LmxsbU91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXJzPy5baV0/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW3Jlc3VsdC5nZW5lcmF0aW9uc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhdHVzID09PSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcnM/LltpXT8uaGFuZGxlTExNRXJyb3IocFJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocFJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgY29tYmluZWQgb3V0cHV0XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbGxtT3V0cHV0OiBsbG1PdXRwdXRzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gdGhpcy5fY29tYmluZUxMTU91dHB1dD8uKC4uLmxsbU91dHB1dHMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIG91dHB1dHNfanNfMS5SVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuTWFuYWdlcnNcbiAgICAgICAgICAgICAgICA/IHsgcnVuSWRzOiBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGVDYWNoZWQoeyBtZXNzYWdlcywgY2FjaGUsIGxsbVN0cmluZ0tleSwgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMsIH0pIHtcbiAgICAgICAgY29uc3QgYmFzZU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCkgPT4gbWVzc2FnZUxpc3QubWFwKGluZGV4X2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4udGhpcy5nZXRMc1BhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGNhbGxiYWNrIG1hbmFnZXIgYW5kIHN0YXJ0IHJ1blxuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoaGFuZGxlZE9wdGlvbnMuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgaGFuZGxlZE9wdGlvbnMudGFncywgdGhpcy50YWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYXRNb2RlbFN0YXJ0KHRoaXMudG9KU09OKCksIGJhc2VNZXNzYWdlcywgaGFuZGxlZE9wdGlvbnMucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucy5ydW5OYW1lKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgcmVzdWx0c1xuICAgICAgICBjb25zdCBtaXNzaW5nUHJvbXB0SW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGJhc2VNZXNzYWdlcy5tYXAoYXN5bmMgKGJhc2VNZXNzYWdlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gSm9pbiBhbGwgY29udGVudCBpbnRvIG9uZSBzdHJpbmcgZm9yIHRoZSBwcm9tcHQgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoYmFzZU1lc3NhZ2UpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5sb29rdXAocHJvbXB0LCBsbG1TdHJpbmdLZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIE1hcCBydW4gbWFuYWdlcnMgdG8gdGhlIHJlc3VsdHMgYmVmb3JlIGZpbHRlcmluZyBvdXQgbnVsbCByZXN1bHRzXG4gICAgICAgIC8vIE51bGwgcmVzdWx0cyBhcmUganVzdCBhYnNlbnQgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAubWFwKChyZXN1bHQsIGluZGV4KSA9PiAoeyByZXN1bHQsIHJ1bk1hbmFnZXI6IHJ1bk1hbmFnZXJzPy5baW5kZXhdIH0pKVxuICAgICAgICAgICAgLmZpbHRlcigoeyByZXN1bHQgfSkgPT4gKHJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgJiYgcmVzdWx0LnZhbHVlICE9IG51bGwpIHx8XG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIpO1xuICAgICAgICAvLyBIYW5kbGUgcmVzdWx0cyBhbmQgY2FsbCBydW4gbWFuYWdlcnNcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVkUmVzdWx0cy5tYXAoYXN5bmMgKHsgcmVzdWx0OiBwcm9taXNlUmVzdWx0LCBydW5NYW5hZ2VyIH0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlUmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb21pc2VSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4ocmVzdWx0WzBdLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtyZXN1bHRdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdHVzID09PSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihwcm9taXNlUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHByb21pc2VSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgUlVOX0tFWSBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvdXRwdXQgb2JqZWN0XG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgbm90IHNlcmlhbGl6ZWQgd2hlbiB0aGUgb3V0cHV0IGlzIHN0cmluZ2lmaWVkLCBhbmQgc28gdGhhdFxuICAgICAgICAvLyBpdCBpc250IGluY2x1ZGVkIHdoZW4gbGlzdGluZyB0aGUga2V5cyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dHB1dCwgb3V0cHV0c19qc18xLlJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBjaGF0IGJhc2VkIG9uIHRoZSBpbnB1dCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgYXJyYXlzIG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIExMTVJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIHBhcnNlIGNhbGwgb3B0aW9uc1xuICAgICAgICBsZXQgcGFyc2VkT3B0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSB7IHN0b3A6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QpID0+IG1lc3NhZ2VMaXN0Lm1hcChpbmRleF9qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChwYXJzZWRPcHRpb25zKTtcbiAgICAgICAgcnVubmFibGVDb25maWcuY2FsbGJhY2tzID0gcnVubmFibGVDb25maWcuY2FsbGJhY2tzID8/IGNhbGxiYWNrcztcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChiYXNlTWVzc2FnZXMsIGNhbGxPcHRpb25zLCBydW5uYWJsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGxtU3RyaW5nS2V5ID0gdGhpcy5fZ2V0U2VyaWFsaXplZENhY2hlS2V5UGFyYW1ldGVyc0ZvckNhbGwoY2FsbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb25zLCBtaXNzaW5nUHJvbXB0SW5kaWNlcyB9ID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVDYWNoZWQoe1xuICAgICAgICAgICAgbWVzc2FnZXM6IGJhc2VNZXNzYWdlcyxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgbGxtU3RyaW5nS2V5LFxuICAgICAgICAgICAgcGFyc2VkT3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBoYW5kbGVkT3B0aW9uczogcnVubmFibGVDb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGxtT3V0cHV0ID0ge307XG4gICAgICAgIGlmIChtaXNzaW5nUHJvbXB0SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IGJhc2VNZXNzYWdlc1tpXSksIGNhbGxPcHRpb25zLCBydW5uYWJsZUNvbmZpZyk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLmdlbmVyYXRpb25zLm1hcChhc3luYyAoZ2VuZXJhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHRJbmRleCA9IG1pc3NpbmdQcm9tcHRJbmRpY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1twcm9tcHRJbmRleF0gPSBnZW5lcmF0aW9uO1xuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIGNvbnRlbnQgaW50byBvbmUgc3RyaW5nIGZvciB0aGUgcHJvbXB0IGluZGV4XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShiYXNlTWVzc2FnZXNbcHJvbXB0SW5kZXhdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS51cGRhdGUocHJvbXB0LCBsbG1TdHJpbmdLZXksIGdlbmVyYXRpb24pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGxtT3V0cHV0ID0gcmVzdWx0cy5sbG1PdXRwdXQgPz8ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGlvbnMsIGxsbU91dHB1dCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbnZva2UgdGhlIG1vZGVsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnZvY2F0aW9uUGFyYW1zKF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgX21vZGVsVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZV9jaGF0X21vZGVsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5pbnZvY2F0aW9uUGFyYW1zKCksXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcHJvbXB0IGJhc2VkIG9uIHRoZSBpbnB1dCBwcm9tcHQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZXMgQW4gYXJyYXkgb2YgQmFzZVByb21wdFZhbHVlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIExMTVJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVByb21wdChwcm9tcHRWYWx1ZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IHByb21wdFZhbHVlcy5tYXAoKHByb21wdFZhbHVlKSA9PiBwcm9tcHRWYWx1ZS50b0NoYXRNZXNzYWdlcygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUocHJvbXB0TWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogTWFrZXMgYSBzaW5nbGUgY2FsbCB0byB0aGUgY2hhdCBtb2RlbC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZShbbWVzc2FnZXMubWFwKGluZGV4X2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpXSwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSByZXN1bHQuZ2VuZXJhdGlvbnM7XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uc1swXVswXS5tZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIE1ha2VzIGEgc2luZ2xlIGNhbGwgdG8gdGhlIGNoYXQgbW9kZWwgd2l0aCBhIHByb21wdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxQcm9tcHQocHJvbXB0VmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IHByb21wdFZhbHVlLnRvQ2hhdE1lc3NhZ2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwocHJvbXB0TWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogUHJlZGljdHMgdGhlIG5leHQgbWVzc2FnZSBiYXNlZCBvbiB0aGUgaW5wdXQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBQcmVkaWN0cyB0aGUgbmV4dCBtZXNzYWdlIGJhc2VkIG9uIGEgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHByZWRpY3QodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgaW5kZXhfanNfMS5IdW1hbk1lc3NhZ2UodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChbbWVzc2FnZV0sIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgcHJlZGljdCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRUb29scyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYXQgbW9kZWwgbXVzdCBpbXBsZW1lbnQgXCIuYmluZFRvb2xzKClcIiB0byB1c2Ugd2l0aFN0cnVjdHVyZWRPdXRwdXQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnPy5uYW1lO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHNjaGVtYS5kZXNjcmlwdGlvbiA/PyBcIkEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuXCI7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZz8ubWV0aG9kO1xuICAgICAgICBjb25zdCBpbmNsdWRlUmF3ID0gY29uZmlnPy5pbmNsdWRlUmF3O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImpzb25Nb2RlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFzZSB3aXRoU3RydWN0dXJlZE91dHB1dCBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIFwiZnVuY3Rpb25DYWxsaW5nXCIgYXMgYSBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG5hbWUgPz8gXCJleHRyYWN0XCI7XG4gICAgICAgIGxldCB0b29scztcbiAgICAgICAgaWYgKCgwLCBpc196b2Rfc2NoZW1hX2pzXzEuaXNab2RTY2hlbWEpKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiAoMCwgem9kX3RvX2pzb25fc2NoZW1hXzEuem9kVG9Kc29uU2NoZW1hKShzY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFwibmFtZVwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9IHNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsbG0gPSB0aGlzLmJpbmRUb29scyh0b29scyk7XG4gICAgICAgIGNvbnN0IG91dHB1dFBhcnNlciA9IGJhc2VfanNfMi5SdW5uYWJsZUxhbWJkYS5mcm9tKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dC50b29sX2NhbGxzIHx8IGlucHV0LnRvb2xfY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBjYWxscyBmb3VuZCBpbiB0aGUgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBpbnB1dC50b29sX2NhbGxzLmZpbmQoKHRjKSA9PiB0Yy5uYW1lID09PSBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0b29sQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdG9vbCBjYWxsIGZvdW5kIHdpdGggbmFtZSAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbENhbGwuYXJncztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jbHVkZVJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGxsbS5waXBlKG91dHB1dFBhcnNlcikud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZXJBc3NpZ24gPSBwYXNzdGhyb3VnaF9qc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBwYXJzZWQ6IChpbnB1dCwgY29uZmlnKSA9PiBvdXRwdXRQYXJzZXIuaW52b2tlKGlucHV0LnJhdywgY29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlck5vbmUgPSBwYXNzdGhyb3VnaF9qc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIHBhcnNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFdpdGhGYWxsYmFjayA9IHBhcnNlckFzc2lnbi53aXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIGZhbGxiYWNrczogW3BhcnNlck5vbmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhc2VfanNfMi5SdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhdzogbGxtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlZFdpdGhGYWxsYmFjayxcbiAgICAgICAgXSkud2l0aENvbmZpZyh7XG4gICAgICAgICAgICBydW5OYW1lOiBcIlN0cnVjdHVyZWRPdXRwdXRSdW5uYWJsZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDaGF0TW9kZWwgPSBCYXNlQ2hhdE1vZGVsO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMgQmFzZUNoYXRNb2RlbCBhbmQgcHJvdmlkZXMgYSBzaW1wbGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIF9nZW5lcmF0ZS5cbiAqL1xuY2xhc3MgU2ltcGxlQ2hhdE1vZGVsIGV4dGVuZHMgQmFzZUNoYXRNb2RlbCB7XG4gICAgYXN5bmMgX2dlbmVyYXRlKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLl9jYWxsKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBpbmRleF9qc18xLkFJTWVzc2FnZSh0ZXh0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZW5lcmF0ZSB3aXRoIGEgc2ltcGxlIGNoYXQgbW9kZWwgd2hlbiBvdXRwdXQgaXMgbm90IGEgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUNoYXRNb2RlbCA9IFNpbXBsZUNoYXRNb2RlbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/llms.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LLM = exports.BaseLLM = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst event_stream_js_1 = __webpack_require__(/*! ../tracers/event_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nclass BaseLLM extends base_js_1.BaseLanguageModel {\n    constructor({ concurrency, ...rest }) {\n        super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"llms\", this._llmType()]\n        });\n    }\n    /**\n     * This method takes an input and options, and returns a string. It\n     * converts the input to a prompt value and generates a result based on\n     * the prompt.\n     * @param input Input for the LLM.\n     * @param options Options for the LLM call.\n     * @returns A string result based on the prompt.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseLLM._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        return result.generations[0][0].text;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_input, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseLLM._convertInputToPromptValue(input);\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generation = new outputs_js_1.GenerationChunk({\n                text: \"\",\n            });\n            try {\n                for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {\n                    if (!generation) {\n                        generation = chunk;\n                    }\n                    else {\n                        generation = generation.concat(chunk);\n                    }\n                    if (typeof chunk.text === \"string\") {\n                        yield chunk.text;\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                generations: [[generation]],\n            })));\n        }\n    }\n    /**\n     * This method takes prompt values, options, and callbacks, and generates\n     * a result based on the prompts.\n     * @param promptValues Prompt values for the LLM.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns An LLMResult based on the prompts.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const prompts = promptValues.map((promptValue) => promptValue.toString());\n        return this.generate(prompts, options, callbacks);\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _flattenLLMResult(llmResult) {\n        const llmResults = [];\n        for (let i = 0; i < llmResult.generations.length; i += 1) {\n            const genList = llmResult.generations[i];\n            if (i === 0) {\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput: llmResult.llmOutput,\n                });\n            }\n            else {\n                const llmOutput = llmResult.llmOutput\n                    ? { ...llmResult.llmOutput, tokenUsage: {} }\n                    : undefined;\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput,\n                });\n            }\n        }\n        return llmResults;\n    }\n    /** @ignore */\n    async _generateUncached(prompts, parsedOptions, handledOptions) {\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find((handler) => {\n            return (0, event_stream_js_1.isStreamEventsHandler)(handler) || (0, log_stream_js_1.isLogStreamHandler)(handler);\n        });\n        let output;\n        if (hasStreamingHandler &&\n            prompts.length === 1 &&\n            this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                for await (const chunk of stream) {\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                output = { generations: [[aggregated]], llmOutput: {} };\n                await runManagers?.[0].handleLLMEnd(output);\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            try {\n                output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            const flattenedOutputs = this._flattenLLMResult(output);\n            await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n        }\n        const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runIds ? { runIds } : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId, }) {\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n            cached: true,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result;\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason);\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Run the LLM on the given prompts and input, handling caching.\n     */\n    async generate(prompts, options, callbacks) {\n        if (!Array.isArray(prompts)) {\n            throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n        }\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(prompts, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices } = await this._generateCached({\n            prompts,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n            runId: runnableConfig.runId,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                return cache.update(prompts[promptIndex], llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n     */\n    async call(prompt, options, callbacks) {\n        const { generations } = await this.generate([prompt], options, callbacks);\n        return generations[0][0].text;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method is similar to `call`, but it's used for making predictions\n     * based on the input text.\n     * @param text Input text for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A prediction based on the input text.\n     */\n    async predict(text, options, callbacks) {\n        return this.call(text, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method takes a list of messages, options, and callbacks, and\n     * returns a predicted message.\n     * @param messages A list of messages for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A predicted message based on the list of messages.\n     */\n    async predictMessages(messages, options, callbacks) {\n        const text = (0, index_js_1.getBufferString)(messages);\n        const prediction = await this.call(text, options, callbacks);\n        return new index_js_1.AIMessage(prediction);\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    _modelType() {\n        return \"base_llm\";\n    }\n}\nexports.BaseLLM = BaseLLM;\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nclass LLM extends BaseLLM {\n    async _generate(prompts, options, runManager) {\n        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n        return { generations };\n    }\n}\nexports.LLM = LLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxlQUFlO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3RDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUE2QjtBQUMvRCx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qyw4QkFBOEIsdUNBQXVDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLHVCQUF1QjtBQUM3TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtNQUFrTSx1QkFBdUI7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEIscUVBQXFFO0FBQ2pHLGtNQUFrTSx1QkFBdUI7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQ0FBMEM7QUFDakYsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1DQUFtQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0EseUNBQXlDLGFBQWEsbUJBQW1CLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLHlCQUF5QixnQ0FBZ0MsTUFBTTtBQUN2SyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzP2IyZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxMTSA9IGV4cG9ydHMuQmFzZUxMTSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvaW5kZXguY2pzXCIpO1xuY29uc3Qgb3V0cHV0c19qc18xID0gcmVxdWlyZShcIi4uL291dHB1dHMuY2pzXCIpO1xuY29uc3QgbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgZXZlbnRfc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzXCIpO1xuY29uc3QgbG9nX3N0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvbG9nX3N0cmVhbS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuLyoqXG4gKiBMTE0gV3JhcHBlci4gVGFrZXMgaW4gYSBwcm9tcHQgKG9yIHByb21wdHMpIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICovXG5jbGFzcyBCYXNlTExNIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VMYW5ndWFnZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmN1cnJlbmN5LCAuLi5yZXN0IH0pIHtcbiAgICAgICAgc3VwZXIoY29uY3VycmVuY3kgPyB7IG1heENvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSwgLi4ucmVzdCB9IDogcmVzdCk7XG4gICAgICAgIC8vIE9ubHkgZXZlciBpbnN0YW50aWF0ZWQgaW4gbWFpbiBMYW5nQ2hhaW5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJsbG1zXCIsIHRoaXMuX2xsbVR5cGUoKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGlucHV0IGFuZCBvcHRpb25zLCBhbmQgcmV0dXJucyBhIHN0cmluZy4gSXRcbiAgICAgKiBjb252ZXJ0cyB0aGUgaW5wdXQgdG8gYSBwcm9tcHQgdmFsdWUgYW5kIGdlbmVyYXRlcyBhIHJlc3VsdCBiYXNlZCBvblxuICAgICAqIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IGZvciB0aGUgTExNLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0VmFsdWUgPSBCYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVByb21wdChbcHJvbXB0VmFsdWVdLCBvcHRpb25zLCBvcHRpb25zPy5jYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdlbmVyYXRpb25zWzBdWzBdLnRleHQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfaW5wdXQsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBfc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0LCBrZWVwIGBzaWduYWxgIGluIGJvdGggcnVubmFibGVDb25maWcgYW5kIGNhbGxPcHRpb25zXG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gc3VwZXIuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNhbGxPcHRpb25zLnNpZ25hbCA9IHJ1bm5hYmxlQ29uZmlnLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzIGNoZWNrIHJlcXVpcmVkIHRvIGF2b2lkIGRvdWJsZSBjYWxsYmFja3Mgd2l0aCBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyA9PT0gQmFzZUxMTS5wcm90b3R5cGUuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHJ1bm5hYmxlQ29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlTExNU3RhcnQodGhpcy50b0pTT04oKSwgW3Byb21wdC50b1N0cmluZygpXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uID0gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhwcm9tcHQudG9TdHJpbmcoKSwgY2FsbE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb24uY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uXV0sXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIHByb21wdCB2YWx1ZXMsIG9wdGlvbnMsIGFuZCBjYWxsYmFja3MsIGFuZCBnZW5lcmF0ZXNcbiAgICAgKiBhIHJlc3VsdCBiYXNlZCBvbiB0aGUgcHJvbXB0cy5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWVzIFByb21wdCB2YWx1ZXMgZm9yIHRoZSBMTE0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQW4gTExNUmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlUHJvbXB0KHByb21wdFZhbHVlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdHMgPSBwcm9tcHRWYWx1ZXMubWFwKChwcm9tcHRWYWx1ZSkgPT4gcHJvbXB0VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKHByb21wdHMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGludm9rZSB0aGUgbW9kZWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGludm9jYXRpb25QYXJhbXMoX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfZmxhdHRlbkxMTVJlc3VsdChsbG1SZXN1bHQpIHtcbiAgICAgICAgY29uc3QgbGxtUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxsbVJlc3VsdC5nZW5lcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZ2VuTGlzdCA9IGxsbVJlc3VsdC5nZW5lcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGxtUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtnZW5MaXN0XSxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0OiBsbG1SZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGxtT3V0cHV0ID0gbGxtUmVzdWx0LmxsbU91dHB1dFxuICAgICAgICAgICAgICAgICAgICA/IHsgLi4ubGxtUmVzdWx0LmxsbU91dHB1dCwgdG9rZW5Vc2FnZToge30gfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsbG1SZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW2dlbkxpc3RdLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxsbVJlc3VsdHM7XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2dlbmVyYXRlVW5jYWNoZWQocHJvbXB0cywgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IHByb21wdHMubGVuZ3RoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIHByb21wdHMsIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICAvLyBFdmVuIGlmIHN0cmVhbSBpcyBub3QgZXhwbGljaXRseSBjYWxsZWQsIGNoZWNrIGlmIG1vZGVsIGlzIGltcGxpY2l0bHlcbiAgICAgICAgLy8gY2FsbGVkIGZyb20gc3RyZWFtRXZlbnRzKCkgb3Igc3RyZWFtTG9nKCkgdG8gZ2V0IGFsbCBzdHJlYW1lZCBldmVudHMuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIF9zdHJlYW1SZXNwb25zZUNodW5rcyBub3Qgb3ZlcnJpZGRlblxuICAgICAgICBjb25zdCBoYXNTdHJlYW1pbmdIYW5kbGVyID0gISFydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZXJzLmZpbmQoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXZlbnRfc3RyZWFtX2pzXzEuaXNTdHJlYW1FdmVudHNIYW5kbGVyKShoYW5kbGVyKSB8fCAoMCwgbG9nX3N0cmVhbV9qc18xLmlzTG9nU3RyZWFtSGFuZGxlcikoaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAoaGFzU3RyZWFtaW5nSGFuZGxlciAmJlxuICAgICAgICAgICAgcHJvbXB0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzICE9PSBCYXNlTExNLnByb3RvdHlwZS5fc3RyZWFtUmVzcG9uc2VDaHVua3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MocHJvbXB0c1swXSwgcGFyc2VkT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSk7XG4gICAgICAgICAgICAgICAgbGV0IGFnZ3JlZ2F0ZWQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGFnZ3JlZ2F0ZWQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGVtcHR5IHJlc3BvbnNlIGZyb20gY2hhdCBtb2RlbCBjYWxsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyBnZW5lcmF0aW9uczogW1thZ2dyZWdhdGVkXV0sIGxsbU91dHB1dDoge30gfTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVuZChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlKHByb21wdHMsIHBhcnNlZE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihlcnIpKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkT3V0cHV0cyA9IHRoaXMuX2ZsYXR0ZW5MTE1SZXN1bHQob3V0cHV0KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoZmxhdHRlbmVkT3V0cHV0c1tpXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZHMgPSBydW5NYW5hZ2Vycz8ubWFwKChtYW5hZ2VyKSA9PiBtYW5hZ2VyLnJ1bklkKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBvdXRwdXRzX2pzXzEuUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bklkcyA/IHsgcnVuSWRzIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGVDYWNoZWQoeyBwcm9tcHRzLCBjYWNoZSwgbGxtU3RyaW5nS2V5LCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgcnVuSWQsIH0pIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IHByb21wdHMubGVuZ3RoLFxuICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIHByb21wdHMsIHJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSByZXN1bHRzXG4gICAgICAgIGNvbnN0IG1pc3NpbmdQcm9tcHRJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmxvb2t1cChwcm9tcHQsIGxsbVN0cmluZ0tleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gTWFwIHJ1biBtYW5hZ2VycyB0byB0aGUgcmVzdWx0cyBiZWZvcmUgZmlsdGVyaW5nIG91dCBudWxsIHJlc3VsdHNcbiAgICAgICAgLy8gTnVsbCByZXN1bHRzIGFyZSBqdXN0IGFic2VudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0cyA9IHJlc3VsdHNcbiAgICAgICAgICAgIC5tYXAoKHJlc3VsdCwgaW5kZXgpID0+ICh7IHJlc3VsdCwgcnVuTWFuYWdlcjogcnVuTWFuYWdlcnM/LltpbmRleF0gfSkpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHJlc3VsdCB9KSA9PiAocmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJiByZXN1bHQudmFsdWUgIT0gbnVsbCkgfHxcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIik7XG4gICAgICAgIC8vIEhhbmRsZSByZXN1bHRzIGFuZCBjYWxsIHJ1biBtYW5hZ2Vyc1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWNoZWRSZXN1bHRzLm1hcChhc3luYyAoeyByZXN1bHQ6IHByb21pc2VSZXN1bHQsIHJ1bk1hbmFnZXIgfSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2VSZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvbWlzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXN1bHRbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW3Jlc3VsdF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKHByb21pc2VSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocHJvbWlzZVJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBvdXRwdXRzX2pzXzEuUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bk1hbmFnZXJzXG4gICAgICAgICAgICAgICAgPyB7IHJ1bklkczogcnVuTWFuYWdlcnM/Lm1hcCgobWFuYWdlcikgPT4gbWFuYWdlci5ydW5JZCkgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIHRoZSBMTE0gb24gdGhlIGdpdmVuIHByb21wdHMgYW5kIGlucHV0LCBoYW5kbGluZyBjYWNoaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKHByb21wdHMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvbXB0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdwcm9tcHRzJyBpcyBleHBlY3RlZCB0byBiZSBhIHN0cmluZ1tdXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWRPcHRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucyA9IHsgc3RvcDogb3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KHBhcnNlZE9wdGlvbnMpO1xuICAgICAgICBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPSBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPz8gY2FsbGJhY2tzO1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuY2FjaGVkKHByb21wdHMsIGNhbGxPcHRpb25zLCBydW5uYWJsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGxtU3RyaW5nS2V5ID0gdGhpcy5fZ2V0U2VyaWFsaXplZENhY2hlS2V5UGFyYW1ldGVyc0ZvckNhbGwoY2FsbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRpb25zLCBtaXNzaW5nUHJvbXB0SW5kaWNlcyB9ID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVDYWNoZWQoe1xuICAgICAgICAgICAgcHJvbXB0cyxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgbGxtU3RyaW5nS2V5LFxuICAgICAgICAgICAgcGFyc2VkT3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBoYW5kbGVkT3B0aW9uczogcnVubmFibGVDb25maWcsXG4gICAgICAgICAgICBydW5JZDogcnVubmFibGVDb25maWcucnVuSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGxtT3V0cHV0ID0ge307XG4gICAgICAgIGlmIChtaXNzaW5nUHJvbXB0SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IHByb21wdHNbaV0pLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5nZW5lcmF0aW9ucy5tYXAoYXN5bmMgKGdlbmVyYXRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0SW5kZXggPSBtaXNzaW5nUHJvbXB0SW5kaWNlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbcHJvbXB0SW5kZXhdID0gZ2VuZXJhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUudXBkYXRlKHByb21wdHNbcHJvbXB0SW5kZXhdLCBsbG1TdHJpbmdLZXksIGdlbmVyYXRpb24pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGxtT3V0cHV0ID0gcmVzdWx0cy5sbG1PdXRwdXQgPz8ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGlvbnMsIGxsbU91dHB1dCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKiBDb252ZW5pZW5jZSB3cmFwcGVyIGZvciB7QGxpbmsgZ2VuZXJhdGV9IHRoYXQgdGFrZXMgaW4gYSBzaW5nbGUgc3RyaW5nIHByb21wdCBhbmQgcmV0dXJucyBhIHNpbmdsZSBzdHJpbmcgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwocHJvbXB0LCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgeyBnZW5lcmF0aW9ucyB9ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZShbcHJvbXB0XSwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25zWzBdWzBdLnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgc2ltaWxhciB0byBgY2FsbGAsIGJ1dCBpdCdzIHVzZWQgZm9yIG1ha2luZyBwcmVkaWN0aW9uc1xuICAgICAqIGJhc2VkIG9uIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB0ZXh0IElucHV0IHRleHQgZm9yIHRoZSBwcmVkaWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEByZXR1cm5zIEEgcHJlZGljdGlvbiBiYXNlZCBvbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0KHRleHQsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKHRleHQsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgYSBsaXN0IG9mIG1lc3NhZ2VzLCBvcHRpb25zLCBhbmQgY2FsbGJhY2tzLCBhbmRcbiAgICAgKiByZXR1cm5zIGEgcHJlZGljdGVkIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEEgbGlzdCBvZiBtZXNzYWdlcyBmb3IgdGhlIHByZWRpY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQSBwcmVkaWN0ZWQgbWVzc2FnZSBiYXNlZCBvbiB0aGUgbGlzdCBvZiBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0TWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gKDAsIGluZGV4X2pzXzEuZ2V0QnVmZmVyU3RyaW5nKShtZXNzYWdlcyk7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCB0aGlzLmNhbGwodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18xLkFJTWVzc2FnZShwcmVkaWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGlmeWluZyBwYXJhbWV0ZXJzIG9mIHRoZSBMTE0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfaWRlbnRpZnlpbmdQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm4gYSBqc29uLWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIExMTS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pZGVudGlmeWluZ1BhcmFtcygpLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9tb2RlbFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImJhc2VfbGxtXCI7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTExNID0gQmFzZUxMTTtcbi8qKlxuICogTExNIGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBzaW1wbGVyIGludGVyZmFjZSB0byBzdWJjbGFzcyB0aGFuIHtAbGluayBCYXNlTExNfS5cbiAqXG4gKiBSZXF1aXJlcyBvbmx5IGltcGxlbWVudGluZyBhIHNpbXBsZXIge0BsaW5rIF9jYWxsfSBtZXRob2QgaW5zdGVhZCBvZiB7QGxpbmsgX2dlbmVyYXRlfS5cbiAqXG4gKiBAYXVnbWVudHMgQmFzZUxMTVxuICovXG5jbGFzcyBMTE0gZXh0ZW5kcyBCYXNlTExNIHtcbiAgICBhc3luYyBfZ2VuZXJhdGUocHJvbXB0cywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21wdHMubWFwKChwcm9tcHQsIHByb21wdEluZGV4KSA9PiB0aGlzLl9jYWxsKHByb21wdCwgeyAuLi5vcHRpb25zLCBwcm9tcHRJbmRleCB9LCBydW5NYW5hZ2VyKS50aGVuKCh0ZXh0KSA9PiBbeyB0ZXh0IH1dKSkpO1xuICAgICAgICByZXR1cm4geyBnZW5lcmF0aW9ucyB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTExNID0gTExNO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapKeys = exports.keyFromJson = exports.keyToJson = void 0;\nconst decamelize_1 = __importDefault(__webpack_require__(/*! decamelize */ \"(rsc)/./node_modules/decamelize/index.js\"));\nconst camelcase_1 = __importDefault(__webpack_require__(/*! camelcase */ \"(rsc)/./node_modules/camelcase/index.js\"));\nfunction keyToJson(key, map) {\n    return map?.[key] || (0, decamelize_1.default)(key);\n}\nexports.keyToJson = keyToJson;\nfunction keyFromJson(key, map) {\n    return map?.[key] || (0, camelcase_1.default)(key);\n}\nexports.keyFromJson = keyFromJson;\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\nexports.mapKeys = mapKeys;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9tYXBfa2V5cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQ3pELHFDQUFxQyxtQkFBTyxDQUFDLDREQUFZO0FBQ3pELG9DQUFvQyxtQkFBTyxDQUFDLDBEQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sb2FkL21hcF9rZXlzLmNqcz85ZGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBLZXlzID0gZXhwb3J0cy5rZXlGcm9tSnNvbiA9IGV4cG9ydHMua2V5VG9Kc29uID0gdm9pZCAwO1xuY29uc3QgZGVjYW1lbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNhbWVsaXplXCIpKTtcbmNvbnN0IGNhbWVsY2FzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW1lbGNhc2VcIikpO1xuZnVuY3Rpb24ga2V5VG9Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgKDAsIGRlY2FtZWxpemVfMS5kZWZhdWx0KShrZXkpO1xufVxuZXhwb3J0cy5rZXlUb0pzb24gPSBrZXlUb0pzb247XG5mdW5jdGlvbiBrZXlGcm9tSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8ICgwLCBjYW1lbGNhc2VfMS5kZWZhdWx0KShrZXkpO1xufVxuZXhwb3J0cy5rZXlGcm9tSnNvbiA9IGtleUZyb21Kc29uO1xuZnVuY3Rpb24gbWFwS2V5cyhmaWVsZHMsIG1hcHBlciwgbWFwKSB7XG4gICAgY29uc3QgbWFwcGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkcywga2V5KSkge1xuICAgICAgICAgICAgbWFwcGVkW21hcHBlcihrZXksIG1hcCldID0gZmllbGRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZDtcbn1cbmV4cG9ydHMubWFwS2V5cyA9IG1hcEtleXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Serializable = exports.get_lc_unique_name = void 0;\nconst map_keys_js_1 = __webpack_require__(/*! ./map_keys.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\");\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nexports.get_lc_unique_name = get_lc_unique_name;\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lc_kwargs = kwargs || {};\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: (0, map_keys_js_1.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, map_keys_js_1.keyToJson, aliases),\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\nexports.Serializable = Serializable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDBCQUEwQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDOUM7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuY2pzPzhkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZSA9IGV4cG9ydHMuZ2V0X2xjX3VuaXF1ZV9uYW1lID0gdm9pZCAwO1xuY29uc3QgbWFwX2tleXNfanNfMSA9IHJlcXVpcmUoXCIuL21hcF9rZXlzLmNqc1wiKTtcbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgPyBbLi4ub2JqXSA6IHsgLi4ub2JqIH07XG59XG5mdW5jdGlvbiByZXBsYWNlU2VjcmV0cyhyb290LCBzZWNyZXRzTWFwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd0NvcHkocm9vdCk7XG4gICAgZm9yIChjb25zdCBbcGF0aCwgc2VjcmV0SWRdIG9mIE9iamVjdC5lbnRyaWVzKHNlY3JldHNNYXApKSB7XG4gICAgICAgIGNvbnN0IFtsYXN0LCAuLi5wYXJ0c1JldmVyc2VdID0gcGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W3BhcnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRbcGFydF0gPSBzaGFsbG93Q29weShjdXJyZW50W3BhcnRdKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50W2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbbGFzdF0gPSB7XG4gICAgICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZWNyZXRcIixcbiAgICAgICAgICAgICAgICBpZDogW3NlY3JldElkXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogR2V0IGEgdW5pcXVlIG5hbWUgZm9yIHRoZSBtb2R1bGUsIHJhdGhlciB0aGFuIHBhcmVudCBjbGFzcyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBTaG91bGQgbm90IGJlIHN1YmNsYXNzZWQsIHN1YmNsYXNzIGxjX25hbWUgYWJvdmUgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gZ2V0X2xjX3VuaXF1ZV9uYW1lKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuc2VyaWFsaXphYmxlQ2xhc3MpIHtcbiAgICAvLyBcInN1cGVyXCIgaGVyZSB3b3VsZCByZWZlciB0byB0aGUgcGFyZW50IGNsYXNzIG9mIFNlcmlhbGl6YWJsZSxcbiAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIHBhcmVudCBjbGFzcyBvZiB0aGUgbW9kdWxlIGFjdHVhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VyaWFsaXphYmxlQ2xhc3MpO1xuICAgIGNvbnN0IGxjTmFtZUlzU3ViY2xhc3NlZCA9IHR5cGVvZiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgKHR5cGVvZiBwYXJlbnRDbGFzcy5sY19uYW1lICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKSAhPT0gcGFyZW50Q2xhc3MubGNfbmFtZSgpKTtcbiAgICBpZiAobGNOYW1lSXNTdWJjbGFzc2VkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubmFtZTtcbiAgICB9XG59XG5leHBvcnRzLmdldF9sY191bmlxdWVfbmFtZSA9IGdldF9sY191bmlxdWVfbmFtZTtcbmNsYXNzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6YWJsZS4gT3ZlcnJpZGUgdG8gcHJvdmlkZSBhbiBhbGlhcyBvclxuICAgICAqIHRvIHByZXNlcnZlIHRoZSBzZXJpYWxpemVkIG1vZHVsZSBuYW1lIGluIG1pbmlmaWVkIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgc3RhdGljIG1ldGhvZCB0byBzdXBwb3J0IGxvYWRpbmcgbG9naWMuXG4gICAgICovXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaW5hbCBzZXJpYWxpemVkIGlkZW50aWZpZXIgZm9yIHRoZSBtb2R1bGUuXG4gICAgICovXG4gICAgZ2V0IGxjX2lkKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5sY19uYW1lc3BhY2UsXG4gICAgICAgICAgICBnZXRfbGNfdW5pcXVlX25hbWUodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHNlY3JldHMsIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBmcm9tIHNlcmlhbGl6YXRpb24uXG4gICAgICogS2V5cyBhcmUgcGF0aHMgdG8gdGhlIHNlY3JldCBpbiBjb25zdHJ1Y3RvciBhcmdzLCBlLmcuIFwiZm9vLmJhci5iYXpcIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBzZWNyZXQgaWRzLCB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbiBkZXNlcmlhbGl6aW5nLlxuICAgICAqL1xuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgdG8gbWVyZ2Ugd2l0aCBjb25zdHJ1Y3RvciBhcmdzLlxuICAgICAqIEtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGUuZy4gXCJmb29cIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzLCB3aGljaCB3aWxsIGJlIHNlcmlhbGl6ZWQuXG4gICAgICogVGhlc2UgYXR0cmlidXRlcyBuZWVkIHRvIGJlIGFjY2VwdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFsaWFzZXMgZm9yIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGFsaWFzIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBrZXkgaW4gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZWcuIG1ha2UgYXJndW1lbnQgbmFtZXMgbWF0Y2ggUHl0aG9uLlxuICAgICAqL1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3MsIC4uLl9hcmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGt3YXJncyB8fCB7fTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMubGNfc2VyaWFsaXphYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICB0aGlzLmxjX2t3YXJncyBpbnN0YW5jZW9mIFNlcmlhbGl6YWJsZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMubGNfa3dhcmdzICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMubGNfa3dhcmdzKSkge1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHN1cHBvcnQgc2VyaWFsaXphdGlvbiBvZiBjbGFzc2VzIHdpdGggYXJnIG5vdCBhIFBPSk9cbiAgICAgICAgICAgIC8vIEknbSBhd2FyZSB0aGUgY2hlY2sgYWJvdmUgaXNuJ3QgYXMgc3RyaWN0IGFzIGl0IGNvdWxkIGJlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2VjcmV0cyA9IHt9O1xuICAgICAgICBjb25zdCBrd2FyZ3MgPSBPYmplY3Qua2V5cyh0aGlzLmxjX2t3YXJncykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBrZXkgaW4gdGhpcyA/IHRoaXNba2V5XSA6IHRoaXMubGNfa3dhcmdzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIGdldCBzZWNyZXRzLCBhdHRyaWJ1dGVzIGFuZCBhbGlhc2VzIGZyb20gYWxsIHN1cGVyY2xhc3Nlc1xuICAgICAgICBmb3IgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7IGN1cnJlbnQ7IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYWxpYXNlcywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19hbGlhc2VzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VjcmV0cywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19zZWNyZXRzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oa3dhcmdzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2F0dHJpYnV0ZXNcIiwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY2x1ZGUgYWxsIHNlY3JldHMgdXNlZCwgZXZlbiBpZiBub3QgaW4ga3dhcmdzLFxuICAgICAgICAvLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc2VudGluZWwgdmFsdWUgaW4gcmVwbGFjZVNlY3JldHNcbiAgICAgICAgT2JqZWN0LmtleXMoc2VjcmV0cykuZm9yRWFjaCgoa2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgcmVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHdyaXRlID0ga3dhcmdzO1xuICAgICAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBrZXlQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJ0c1JldmVyc2UucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHJlYWQpIHx8IHJlYWRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHdyaXRlKSB8fCB3cml0ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgcmVhZFtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlYWRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkID0gcmVhZFtrZXldO1xuICAgICAgICAgICAgICAgIHdyaXRlID0gd3JpdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0IGluIHJlYWQgJiYgcmVhZFtsYXN0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVbbGFzdF0gPSB3cml0ZVtsYXN0XSB8fCByZWFkW2xhc3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubGNfaWQsXG4gICAgICAgICAgICBrd2FyZ3M6ICgwLCBtYXBfa2V5c19qc18xLm1hcEtleXMpKE9iamVjdC5rZXlzKHNlY3JldHMpLmxlbmd0aCA/IHJlcGxhY2VTZWNyZXRzKGt3YXJncywgc2VjcmV0cykgOiBrd2FyZ3MsIG1hcF9rZXlzX2pzXzEua2V5VG9Kc29uLCBhbGlhc2VzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6YWJsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AIMessageChunk = exports.isAIMessageChunk = exports.isAIMessage = exports.AIMessage = void 0;\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends base_js_1.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0, tool_js_1.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nexports.AIMessage = AIMessage;\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nexports.isAIMessage = isAIMessage;\nfunction isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\nexports.isAIMessageChunk = isAIMessageChunk;\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        else {\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const toolCallChunk of fields.tool_call_chunks) {\n                let parsedArgs = {};\n                try {\n                    parsedArgs = (0, json_js_1.parsePartialJson)(toolCallChunk.args || \"{}\");\n                    if (parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name: toolCallChunk.name ?? \"\",\n                        args: parsedArgs,\n                        id: toolCallChunk.id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name: toolCallChunk.name,\n                        args: toolCallChunk.args,\n                        id: toolCallChunk.id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0, base_js_1._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const inputTokenDetails = {\n                ...((this.usage_metadata?.input_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.input_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_read !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_read !==\n                        undefined) && {\n                    cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_read ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_creation !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_creation !==\n                        undefined) && {\n                    cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0),\n                }),\n            };\n            const outputTokenDetails = {\n                ...((this.usage_metadata?.output_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.output_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.output_token_details?.reasoning !==\n                    undefined ||\n                    chunk.usage_metadata?.output_token_details?.reasoning !==\n                        undefined) && {\n                    reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.reasoning ?? 0),\n                }),\n            };\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n                // Do not include `input_token_details` / `output_token_details` keys in combined fields\n                // unless their values are defined.\n                ...(Object.keys(inputTokenDetails).length > 0 && {\n                    input_token_details: inputTokenDetails,\n                }),\n                ...(Object.keys(outputTokenDetails).length > 0 && {\n                    output_token_details: outputTokenDetails,\n                }),\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\nexports.AIMessageChunk = AIMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQjtBQUMzRixrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9haS5janM/YTAxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUlNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLmlzQUlNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLmlzQUlNZXNzYWdlID0gZXhwb3J0cy5BSU1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBqc29uX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbi5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuL3Rvb2wuY2pzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEFJIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIEFJTWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5sY19hbGlhc2VzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFwiaW52YWxpZF90b29sX2NhbGxzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIGxldCBpbml0UGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczoga3dhcmdzID8/IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSBmaWVsZHM7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSBpbml0UGFyYW1zLmFkZGl0aW9uYWxfa3dhcmdzPy50b29sX2NhbGxzO1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzO1xuICAgICAgICAgICAgaWYgKCEocmF3VG9vbENhbGxzID09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgcmF3VG9vbENhbGxzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAodG9vbENhbGxzID09PSB1bmRlZmluZWQgfHwgdG9vbENhbGxzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oW1xuICAgICAgICAgICAgICAgICAgICBcIk5ldyBMYW5nQ2hhaW4gcGFja2FnZXMgYXJlIGF2YWlsYWJsZSB0aGF0IG1vcmUgZWZmaWNpZW50bHkgaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidG9vbCBjYWxsaW5nLlxcblxcblBsZWFzZSB1cGdyYWRlIHlvdXIgcGFja2FnZXMgdG8gdmVyc2lvbnMgdGhhdCBzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZXNzYWdlIHRvb2wgY2FsbHMuIGUuZy4sIGB5YXJuIGFkZCBAbGFuZ2NoYWluL2FudGhyb3BpY2AsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieWFybiBhZGQgQGxhbmdjaGFpbi9vcGVuYWlgLCBldGMuXCIsXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghKHJhd1Rvb2xDYWxscyA9PSBudWxsKSAmJiB0b29sQ2FsbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbdG9vbENhbGxzLCBpbnZhbGlkVG9vbENhbGxzXSA9ICgwLCB0b29sX2pzXzEuZGVmYXVsdFRvb2xDYWxsUGFyc2VyKShyYXdUb29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSB0b29sQ2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID0gaW52YWxpZFRvb2xDYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcGFyc2luZyBmYWlsc1xuICAgICAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FkbHksIFR5cGVTY3JpcHQgb25seSBhbGxvd3Mgc3VwZXIoKSBjYWxscyBhdCByb290IGlmIHRoZSBjbGFzcyBoYXNcbiAgICAgICAgLy8gcHJvcGVydGllcyB3aXRoIGluaXRpYWxpemVycywgc28gd2UgaGF2ZSB0byBjaGVjayB0eXBlcyB0d2ljZS5cbiAgICAgICAgc3VwZXIoaW5pdFBhcmFtcyk7XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0eXBlZCBhcyBvcHRpb25hbCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzIGFuZCBhbGxvdyBmb3IgY2FzdGluZ1xuICAgICAgICAvLyBmcm9tIEJhc2VNZXNzYWdlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW52YWxpZF90b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0b2tlbiB1c2FnZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2FnZV9tZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGluaXRQYXJhbXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyB0aGlzLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRfdG9vbF9jYWxscyA9XG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2FnZV9tZXRhZGF0YSA9IGluaXRQYXJhbXMudXNhZ2VfbWV0YWRhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJBSU1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRoaXMudG9vbF9jYWxscyxcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMsXG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdGhpcy51c2FnZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkFJTWVzc2FnZSA9IEFJTWVzc2FnZTtcbmZ1bmN0aW9uIGlzQUlNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImFpXCI7XG59XG5leHBvcnRzLmlzQUlNZXNzYWdlID0gaXNBSU1lc3NhZ2U7XG5mdW5jdGlvbiBpc0FJTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImFpXCI7XG59XG5leHBvcnRzLmlzQUlNZXNzYWdlQ2h1bmsgPSBpc0FJTWVzc2FnZUNodW5rO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYW4gQUkgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBBSSBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgQUlNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGxldCBpbml0UGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogZmllbGRzLnRvb2xfY2FsbHMgPz8gW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogZmllbGRzLnVzYWdlX21ldGFkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZHMudXNhZ2VfbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsQ2h1bmsgb2YgZmllbGRzLnRvb2xfY2FsbF9jaHVua3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFyZ3MgPSAoMCwganNvbl9qc18xLnBhcnNlUGFydGlhbEpzb24pKHRvb2xDYWxsQ2h1bmsuYXJncyB8fCBcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkQXJncyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhcnNlZEFyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0b29sIGNhbGwgY2h1bmsgYXJncy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGxDaHVuay5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWRBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsQ2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsQ2h1bmsubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsQ2h1bmsuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbENodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRfdG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IGludmFsaWRUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGZpZWxkcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGRzLnVzYWdlX21ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gTXVzdCByZWRlY2xhcmUgdG9vbCBjYWxsIGZpZWxkcyBzaW5jZSB0aGVyZSBpcyBubyBtdWx0aXBsZSBpbmhlcml0YW5jZSBpbiBKUy5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfY2h1bmtzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0b2tlbiB1c2FnZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2FnZV9tZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvb2xfY2FsbF9jaHVua3MgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxfY2h1bmtzID8/IHRoaXMudG9vbF9jYWxsX2NodW5rcztcbiAgICAgICAgdGhpcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFwidG9vbF9jYWxsX2NodW5rc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRoaXMudG9vbF9jYWxscyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IHRoaXMudG9vbF9jYWxsX2NodW5rcyxcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMsXG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdGhpcy51c2FnZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkRmllbGRzID0ge1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtdLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudG9vbF9jYWxsX2NodW5rcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSAoMCwgYmFzZV9qc18xLl9tZXJnZUxpc3RzKSh0aGlzLnRvb2xfY2FsbF9jaHVua3MsIGNodW5rLnRvb2xfY2FsbF9jaHVua3MpO1xuICAgICAgICAgICAgaWYgKHJhd1Rvb2xDYWxscyAhPT0gdW5kZWZpbmVkICYmIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudG9vbF9jYWxsX2NodW5rcyA9IHJhd1Rvb2xDYWxscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFRva2VuRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX3JlYWQ6ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX2NyZWF0aW9uOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfY3JlYXRpb24gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRUb2tlbkRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uaW5nOiAodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LnJlYXNvbmluZyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMudXNhZ2VfbWV0YWRhdGEgPz8ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGNodW5rLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiBsZWZ0LmlucHV0X3Rva2VucyArIHJpZ2h0LmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiBsZWZ0Lm91dHB1dF90b2tlbnMgKyByaWdodC5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogbGVmdC50b3RhbF90b2tlbnMgKyByaWdodC50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgYGlucHV0X3Rva2VuX2RldGFpbHNgIC8gYG91dHB1dF90b2tlbl9kZXRhaWxzYCBrZXlzIGluIGNvbWJpbmVkIGZpZWxkc1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGVpciB2YWx1ZXMgYXJlIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKGlucHV0VG9rZW5EZXRhaWxzKS5sZW5ndGggPiAwICYmIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5fZGV0YWlsczogaW5wdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKG91dHB1dFRva2VuRGV0YWlscykubGVuZ3RoID4gMCAmJiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbl9kZXRhaWxzOiBvdXRwdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudXNhZ2VfbWV0YWRhdGEgPSB1c2FnZV9tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZUNodW5rKGNvbWJpbmVkRmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkFJTWVzc2FnZUNodW5rID0gQUlNZXNzYWdlQ2h1bms7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBaseMessageChunk = exports.isBaseMessage = exports._isMessageFieldWithRole = exports.BaseMessageChunk = exports._mergeObj = exports._mergeLists = exports._mergeDicts = exports.isOpenAIToolCallArray = exports.BaseMessage = exports._mergeStatus = exports.mergeContent = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return (_mergeLists(firstContent, secondContent) ?? [\n            ...firstContent,\n            ...secondContent,\n        ]);\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\nexports.mergeContent = mergeContent;\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nfunction _mergeStatus(left, right) {\n    if (left === \"error\" || right === \"error\") {\n        return \"error\";\n    }\n    return \"success\";\n}\nexports._mergeStatus = _mergeStatus;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj, depthLimit) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function helper(obj, currentDepth) {\n        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n            return obj;\n        }\n        if (currentDepth >= depthLimit) {\n            if (Array.isArray(obj)) {\n                return \"[Array]\";\n            }\n            return \"[Object]\";\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item) => helper(item, currentDepth + 1));\n        }\n        const result = {};\n        for (const key of Object.keys(obj)) {\n            result[key] = helper(obj[key], currentDepth + 1);\n        }\n        return result;\n    }\n    return JSON.stringify(helper(obj, 0), null, 2);\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends serializable_js_1.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    /** The type of the message. */\n    getType() {\n        return this._getType();\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * An optional unique identifier for the message. This should ideally be\n         * provided by the provider/model which created the message.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n        this.id = fields.id;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    static lc_name() {\n        return \"BaseMessage\";\n    }\n    // Can't be protected for silly reasons\n    get _printableFields() {\n        return {\n            id: this.id,\n            content: this.content,\n            name: this.name,\n            additional_kwargs: this.additional_kwargs,\n            response_metadata: this.response_metadata,\n        };\n    }\n    // this private method is used to update the ID for the runtime\n    // value as well as in lc_kwargs for serialisation\n    _updateId(value) {\n        this.id = value;\n        // lc_attributes wouldn't work here, because jest compares the\n        // whole object\n        this.lc_kwargs.id = value;\n    }\n    get [Symbol.toStringTag]() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.constructor.lc_name();\n    }\n    // Override the default behavior of console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n        if (depth === null) {\n            return this;\n        }\n        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return `${this.constructor.lc_name()} ${printable}`;\n    }\n}\nexports.BaseMessage = BaseMessage;\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nexports.isOpenAIToolCallArray = isOpenAIToolCallArray;\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            if (key === \"type\") {\n                // Do not merge 'type' fields\n                continue;\n            }\n            merged[key] += value;\n        }\n        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\nexports._mergeDicts = _mergeDicts;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);\n                if (toMerge !== -1) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else if (typeof item === \"object\" &&\n                \"text\" in item &&\n                item.text === \"\") {\n                // No-op - skip empty text blocks\n                continue;\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\nexports._mergeLists = _mergeLists;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeObj(left, right) {\n    if (!left && !right) {\n        throw new Error(\"Cannot merge two undefined objects.\");\n    }\n    if (!left || !right) {\n        return left || right;\n    }\n    else if (typeof left !== typeof right) {\n        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n    }\n    else if (typeof left === \"string\" && typeof right === \"string\") {\n        return (left + right);\n    }\n    else if (Array.isArray(left) && Array.isArray(right)) {\n        return _mergeLists(left, right);\n    }\n    else if (typeof left === \"object\" && typeof right === \"object\") {\n        return _mergeDicts(left, right);\n    }\n    else if (left === right) {\n        return left;\n    }\n    else {\n        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n    }\n}\nexports._mergeObj = _mergeObj;\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nexports.BaseMessageChunk = BaseMessageChunk;\nfunction _isMessageFieldWithRole(x) {\n    return typeof x.role === \"string\";\n}\nexports._isMessageFieldWithRole = _isMessageFieldWithRole;\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nexports.isBaseMessage = isBaseMessage;\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\nexports.isBaseMessageChunk = isBaseMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsNkJBQTZCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQ25SLDBCQUEwQixtQkFBTyxDQUFDLGlHQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEIsRUFBRSxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWSxVQUFVLGFBQWE7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxLQUFLLFVBQVUsTUFBTTtBQUNoRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2Jhc2UuY2pzPzQ4M2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQmFzZU1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuaXNCYXNlTWVzc2FnZSA9IGV4cG9ydHMuX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUgPSBleHBvcnRzLkJhc2VNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLl9tZXJnZU9iaiA9IGV4cG9ydHMuX21lcmdlTGlzdHMgPSBleHBvcnRzLl9tZXJnZURpY3RzID0gZXhwb3J0cy5pc09wZW5BSVRvb2xDYWxsQXJyYXkgPSBleHBvcnRzLkJhc2VNZXNzYWdlID0gZXhwb3J0cy5fbWVyZ2VTdGF0dXMgPSBleHBvcnRzLm1lcmdlQ29udGVudCA9IHZvaWQgMDtcbmNvbnN0IHNlcmlhbGl6YWJsZV9qc18xID0gcmVxdWlyZShcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmNqc1wiKTtcbmZ1bmN0aW9uIG1lcmdlQ29udGVudChmaXJzdENvbnRlbnQsIHNlY29uZENvbnRlbnQpIHtcbiAgICAvLyBJZiBmaXJzdCBjb250ZW50IGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBmaXJzdENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDb250ZW50ICsgc2Vjb25kQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogZmlyc3RDb250ZW50IH0sIC4uLnNlY29uZENvbnRlbnRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGJvdGggYXJlIGFycmF5c1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlY29uZENvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiAoX21lcmdlTGlzdHMoZmlyc3RDb250ZW50LCBzZWNvbmRDb250ZW50KSA/PyBbXG4gICAgICAgICAgICAuLi5maXJzdENvbnRlbnQsXG4gICAgICAgICAgICAuLi5zZWNvbmRDb250ZW50LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWRkIHRoZSBzZWNvbmQgY29udGVudCBhcyBhIG5ldyBlbGVtZW50IG9mIHRoZSBsaXN0XG4gICAgICAgIHJldHVybiBbLi4uZmlyc3RDb250ZW50LCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBzZWNvbmRDb250ZW50IH1dO1xuICAgIH1cbn1cbmV4cG9ydHMubWVyZ2VDb250ZW50ID0gbWVyZ2VDb250ZW50O1xuLyoqXG4gKiAnTWVyZ2UnIHR3byBzdGF0dXNlcy4gSWYgZWl0aGVyIHZhbHVlIHBhc3NlZCBpcyAnZXJyb3InLCBpdCB3aWxsIHJldHVybiAnZXJyb3InLiBFbHNlXG4gKiBpdCB3aWxsIHJldHVybiAnc3VjY2VzcycuXG4gKlxuICogQHBhcmFtIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIiB8IHVuZGVmaW5lZH0gbGVmdCBUaGUgZXhpc3RpbmcgdmFsdWUgdG8gJ21lcmdlJyB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gKiBAcGFyYW0ge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwiIHwgdW5kZWZpbmVkfSByaWdodCBUaGUgbmV3IHZhbHVlIHRvICdtZXJnZScgd2l0aCB0aGUgZXhpc3RpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIn0gVGhlICdtZXJnZWQnIHZhbHVlLlxuICovXG5mdW5jdGlvbiBfbWVyZ2VTdGF0dXMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gXCJlcnJvclwiIHx8IHJpZ2h0ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xufVxuZXhwb3J0cy5fbWVyZ2VTdGF0dXMgPSBfbWVyZ2VTdGF0dXM7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc3RyaW5naWZ5V2l0aERlcHRoTGltaXQob2JqLCBkZXB0aExpbWl0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmdW5jdGlvbiBoZWxwZXIob2JqLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50RGVwdGggPj0gZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltBcnJheV1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIltPYmplY3RdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5tYXAoKGl0ZW0pID0+IGhlbHBlcihpdGVtLCBjdXJyZW50RGVwdGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGVscGVyKG9ialtrZXldLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaGVscGVyKG9iaiwgMCksIG51bGwsIDIpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMgb2YgbWVzc2FnZXMgaW4gYSBjb252ZXJzYXRpb24uIEl0IGluY2x1ZGVzXG4gKiBwcm9wZXJ0aWVzIGxpa2UgYGNvbnRlbnRgLCBgbmFtZWAsIGFuZCBgYWRkaXRpb25hbF9rd2FyZ3NgLiBJdCBhbHNvXG4gKiBpbmNsdWRlcyBtZXRob2RzIGxpa2UgYHRvRGljdCgpYCBhbmQgYF9nZXRUeXBlKClgLlxuICovXG5jbGFzcyBCYXNlTWVzc2FnZSBleHRlbmRzIHNlcmlhbGl6YWJsZV9qc18xLlNlcmlhbGl6YWJsZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogXCJhZGRpdGlvbmFsX2t3YXJnc1wiLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IFwicmVzcG9uc2VfbWV0YWRhdGFcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBVc2Uge0BsaW5rIEJhc2VNZXNzYWdlLmNvbnRlbnR9IGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb250ZW50ID09PSBcInN0cmluZ1wiID8gdGhpcy5jb250ZW50IDogXCJcIjtcbiAgICB9XG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyxcbiAgICAgICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYWRkaXRpb25hbF9rd2FyZ3MgaXMgcGFzc2VkIGludG8gc3VwZXIoKSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoIWZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwibWVzc2FnZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBzZW5kZXIgaW4gYSBtdWx0aS11c2VyIGNoYXQuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbF9rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFJlc3BvbnNlIG1ldGFkYXRhLiBGb3IgZXhhbXBsZTogcmVzcG9uc2UgaGVhZGVycywgbG9ncHJvYnMsIHRva2VuIGNvdW50cy4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbWVzc2FnZS4gVGhpcyBzaG91bGQgaWRlYWxseSBiZVxuICAgICAgICAgKiBwcm92aWRlZCBieSB0aGUgcHJvdmlkZXIvbW9kZWwgd2hpY2ggY3JlYXRlZCB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsX2t3YXJncyA9IGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncztcbiAgICAgICAgdGhpcy5yZXNwb25zZV9tZXRhZGF0YSA9IGZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG4gICAgdG9EaWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZSgpLFxuICAgICAgICAgICAgZGF0YTogdGhpcy50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5rd2FyZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCYXNlTWVzc2FnZVwiO1xuICAgIH1cbiAgICAvLyBDYW4ndCBiZSBwcm90ZWN0ZWQgZm9yIHNpbGx5IHJlYXNvbnNcbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogdGhpcy5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gdGhpcyBwcml2YXRlIG1ldGhvZCBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgSUQgZm9yIHRoZSBydW50aW1lXG4gICAgLy8gdmFsdWUgYXMgd2VsbCBhcyBpbiBsY19rd2FyZ3MgZm9yIHNlcmlhbGlzYXRpb25cbiAgICBfdXBkYXRlSWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pZCA9IHZhbHVlO1xuICAgICAgICAvLyBsY19hdHRyaWJ1dGVzIHdvdWxkbid0IHdvcmsgaGVyZSwgYmVjYXVzZSBqZXN0IGNvbXBhcmVzIHRoZVxuICAgICAgICAvLyB3aG9sZSBvYmplY3RcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MuaWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCk7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvbnNvbGUubG9nXG4gICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmludGFibGUgPSBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdCh0aGlzLl9wcmludGFibGVGaWVsZHMsIE1hdGgubWF4KDQsIGRlcHRoKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLmxjX25hbWUoKX0gJHtwcmludGFibGV9YDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VNZXNzYWdlID0gQmFzZU1lc3NhZ2U7XG5mdW5jdGlvbiBpc09wZW5BSVRvb2xDYWxsQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLmV2ZXJ5KCh2KSA9PiB0eXBlb2Ygdi5pbmRleCA9PT0gXCJudW1iZXJcIikpO1xufVxuZXhwb3J0cy5pc09wZW5BSVRvb2xDYWxsQXJyYXkgPSBpc09wZW5BSVRvb2xDYWxsQXJyYXk7XG5mdW5jdGlvbiBfbWVyZ2VEaWN0cyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5sZWZ0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yaWdodFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ubGVmdCB9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJpZ2h0KSkge1xuICAgICAgICBpZiAobWVyZ2VkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkgIT09IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpZWxkWyR7a2V5fV0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1lc3NhZ2UgY2h1bmssIGJ1dCB3aXRoIGEgZGlmZmVyZW50IHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBtZXJnZSAndHlwZScgZmllbGRzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWRba2V5XSArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZURpY3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gX21lcmdlTGlzdHMobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZWRba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoaXMgbWVzc2FnZSBjaHVuayBhbmQgdmFsdWUgaGFzIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuX21lcmdlRGljdHMgPSBfbWVyZ2VEaWN0cztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSB1bmRlZmluZWQgfHwgcmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IFsuLi5sZWZ0XTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcImluZGV4XCIgaW4gaXRlbSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9NZXJnZSA9IG1lcmdlZC5maW5kSW5kZXgoKGxlZnRJdGVtKSA9PiBsZWZ0SXRlbS5pbmRleCA9PT0gaXRlbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvTWVyZ2UgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFt0b01lcmdlXSA9IF9tZXJnZURpY3RzKG1lcmdlZFt0b01lcmdlXSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIFwidGV4dFwiIGluIGl0ZW0gJiZcbiAgICAgICAgICAgICAgICBpdGVtLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBOby1vcCAtIHNraXAgZW1wdHkgdGV4dCBibG9ja3NcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5fbWVyZ2VMaXN0cyA9IF9tZXJnZUxpc3RzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9tZXJnZU9iaihsZWZ0LCByaWdodCkge1xuICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHR3byB1bmRlZmluZWQgb2JqZWN0cy5cIik7XG4gICAgfVxuICAgIGlmICghbGVmdCB8fCAhcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ICE9PSB0eXBlb2YgcmlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWVyZ2Ugb2JqZWN0cyBvZiBkaWZmZXJlbnQgdHlwZXMuXFxuTGVmdCAke3R5cGVvZiBsZWZ0fVxcblJpZ2h0ICR7dHlwZW9mIHJpZ2h0fWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmlnaHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0ICsgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VMaXN0cyhsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiByaWdodCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gX21lcmdlRGljdHMobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBtZXJnZSBvYmplY3RzIG9mIGRpZmZlcmVudCB0eXBlcy5cXG5MZWZ0ICR7bGVmdH1cXG5SaWdodCAke3JpZ2h0fWApO1xuICAgIH1cbn1cbmV4cG9ydHMuX21lcmdlT2JqID0gX21lcmdlT2JqO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbiAqIG1lc3NhZ2UgY2h1bmtzLiBJdCBpbmNsdWRlcyBhIG1ldGhvZCBgX21lcmdlX2t3YXJnc19kaWN0KClgIGZvciBtZXJnaW5nXG4gKiBhZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYW5vdGhlciBgQmFzZU1lc3NhZ2VDaHVua2AgaW50byB0aGlzXG4gKiBvbmUuIEl0IGFsc28gb3ZlcnJpZGVzIHRoZSBgX19hZGRfXygpYCBtZXRob2QgdG8gc3VwcG9ydCBjb25jYXRlbmF0aW9uXG4gKiBvZiBgQmFzZU1lc3NhZ2VDaHVua2AgaW5zdGFuY2VzLlxuICovXG5jbGFzcyBCYXNlTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xufVxuZXhwb3J0cy5CYXNlTWVzc2FnZUNodW5rID0gQmFzZU1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIF9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHgucm9sZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUgPSBfaXNNZXNzYWdlRmllbGRXaXRoUm9sZTtcbmZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2VMaWtlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0Jhc2VNZXNzYWdlID0gaXNCYXNlTWVzc2FnZTtcbmZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2VDaHVuayhtZXNzYWdlTGlrZSkge1xuICAgIHJldHVybiAoaXNCYXNlTWVzc2FnZShtZXNzYWdlTGlrZSkgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2VMaWtlLmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydHMuaXNCYXNlTWVzc2FnZUNodW5rID0gaXNCYXNlTWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isChatMessageChunk = exports.isChatMessage = exports.ChatMessageChunk = exports.ChatMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessage = ChatMessage;\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n            id: this.id ?? chunk.id,\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessageChunk = ChatMessageChunk;\nfunction isChatMessage(x) {\n    return x._getType() === \"generic\";\n}\nexports.isChatMessage = isChatMessage;\nfunction isChatMessageChunk(x) {\n    return x._getType() === \"generic\";\n}\nexports.isChatMessageChunk = isChatMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQ25HLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5janM/ZTg1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNDaGF0TWVzc2FnZUNodW5rID0gZXhwb3J0cy5pc0NoYXRNZXNzYWdlID0gZXhwb3J0cy5DaGF0TWVzc2FnZUNodW5rID0gZXhwb3J0cy5DaGF0TWVzc2FnZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5jbGFzcyBDaGF0TWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBfY2hhdE1lc3NhZ2VDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0TWVzc2FnZSA9IENoYXRNZXNzYWdlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBjaGF0IG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgQ2hhdE1lc3NhZ2VDaHVuayBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRNZXNzYWdlQ2h1bmsgPSBDaGF0TWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gaXNDaGF0TWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG59XG5leHBvcnRzLmlzQ2hhdE1lc3NhZ2UgPSBpc0NoYXRNZXNzYWdlO1xuZnVuY3Rpb24gaXNDaGF0TWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbn1cbmV4cG9ydHMuaXNDaGF0TWVzc2FnZUNodW5rID0gaXNDaGF0TWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isFunctionMessageChunk = exports.isFunctionMessage = exports.FunctionMessageChunk = exports.FunctionMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\nexports.FunctionMessage = FunctionMessage;\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.FunctionMessageChunk = FunctionMessageChunk;\nfunction isFunctionMessage(x) {\n    return x._getType() === \"function\";\n}\nexports.isFunctionMessage = isFunctionMessage;\nfunction isFunctionMessageChunk(x) {\n    return x._getType() === \"function\";\n}\nexports.isFunctionMessageChunk = isFunctionMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvZnVuY3Rpb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QjtBQUNuSCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9mdW5jdGlvbi5janM/MTY1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2UgPSBleHBvcnRzLkZ1bmN0aW9uTWVzc2FnZUNodW5rID0gZXhwb3J0cy5GdW5jdGlvbk1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGZ1bmN0aW9uIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIEZ1bmN0aW9uTWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWU6IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uTWVzc2FnZSA9IEZ1bmN0aW9uTWVzc2FnZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgZnVuY3Rpb24gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciBmdW5jdGlvbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgRnVuY3Rpb25NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiAoMCwgYmFzZV9qc18xLm1lcmdlQ29udGVudCkodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5jdGlvbk1lc3NhZ2VDaHVuayA9IEZ1bmN0aW9uTWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gaXNGdW5jdGlvbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2UgPSBpc0Z1bmN0aW9uTWVzc2FnZTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2VDaHVuayA9IGlzRnVuY3Rpb25NZXNzYWdlQ2h1bms7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isHumanMessageChunk = exports.isHumanMessage = exports.HumanMessageChunk = exports.HumanMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\nexports.HumanMessage = HumanMessage;\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.HumanMessageChunk = HumanMessageChunk;\nfunction isHumanMessage(x) {\n    return x.getType() === \"human\";\n}\nexports.isHumanMessage = isHumanMessage;\nfunction isHumanMessageChunk(x) {\n    return x.getType() === \"human\";\n}\nexports.isHumanMessageChunk = isHumanMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaHVtYW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQjtBQUN2RyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2h1bWFuLmNqcz83OGE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0h1bWFuTWVzc2FnZUNodW5rID0gZXhwb3J0cy5pc0h1bWFuTWVzc2FnZSA9IGV4cG9ydHMuSHVtYW5NZXNzYWdlQ2h1bmsgPSBleHBvcnRzLkh1bWFuTWVzc2FnZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgaHVtYW4gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgSHVtYW5NZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbn1cbmV4cG9ydHMuSHVtYW5NZXNzYWdlID0gSHVtYW5NZXNzYWdlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBodW1hbiBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGh1bWFuIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5jbGFzcyBIdW1hbk1lc3NhZ2VDaHVuayBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdW1hbk1lc3NhZ2VDaHVuayA9IEh1bWFuTWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gaXNIdW1hbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4LmdldFR5cGUoKSA9PT0gXCJodW1hblwiO1xufVxuZXhwb3J0cy5pc0h1bWFuTWVzc2FnZSA9IGlzSHVtYW5NZXNzYWdlO1xuZnVuY3Rpb24gaXNIdW1hbk1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguZ2V0VHlwZSgpID09PSBcImh1bWFuXCI7XG59XG5leHBvcnRzLmlzSHVtYW5NZXNzYWdlQ2h1bmsgPSBpc0h1bWFuTWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isToolMessageChunk = exports.isToolMessage = exports.ToolMessageChunk = exports.ToolMessage = void 0;\n__exportStar(__webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\"), exports);\n// TODO: Use a star export when we deprecate the\n// existing \"ToolCall\" type in \"base.js\".\nvar tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nObject.defineProperty(exports, \"ToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessage; } }));\nObject.defineProperty(exports, \"ToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessageChunk; } }));\nObject.defineProperty(exports, \"isToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessage; } }));\nObject.defineProperty(exports, \"isToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessageChunk; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQjtBQUNuRyxhQUFhLG1CQUFPLENBQUMsMkVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywrRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsbUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLGlGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywrRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHVGQUFnQjtBQUNyQztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVk7QUFDcEMsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxpREFBZ0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDM0gsc0RBQXFELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2luZGV4LmNqcz81OGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVG9vbE1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuaXNUb29sTWVzc2FnZSA9IGV4cG9ydHMuVG9vbE1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuVG9vbE1lc3NhZ2UgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWkuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hhdC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Z1bmN0aW9uLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaHVtYW4uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zeXN0ZW0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlscy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybWVycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vZGlmaWVyLmNqc1wiKSwgZXhwb3J0cyk7XG4vLyBUT0RPOiBVc2UgYSBzdGFyIGV4cG9ydCB3aGVuIHdlIGRlcHJlY2F0ZSB0aGVcbi8vIGV4aXN0aW5nIFwiVG9vbENhbGxcIiB0eXBlIGluIFwiYmFzZS5qc1wiLlxudmFyIHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuL3Rvb2wuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9vbE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5Ub29sTWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvb2xNZXNzYWdlQ2h1bmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5Ub29sTWVzc2FnZUNodW5rOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUb29sTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9vbF9qc18xLmlzVG9vbE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Rvb2xNZXNzYWdlQ2h1bmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5pc1Rvb2xNZXNzYWdlQ2h1bms7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/modifier.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoveMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Message responsible for deleting other messages.\n */\nclass RemoveMessage extends base_js_1.BaseMessage {\n    constructor(fields) {\n        super({\n            ...fields,\n            content: \"\",\n        });\n        /**\n         * The ID of the message to remove.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = fields.id;\n    }\n    _getType() {\n        return \"remove\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            id: this.id,\n        };\n    }\n}\nexports.RemoveMessage = RemoveMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvbW9kaWZpZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL21vZGlmaWVyLmNqcz8zYjJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdmVNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIE1lc3NhZ2UgcmVzcG9uc2libGUgZm9yIGRlbGV0aW5nIG90aGVyIG1lc3NhZ2VzLlxuICovXG5jbGFzcyBSZW1vdmVNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gcmVtb3ZlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInJlbW92ZVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlbW92ZU1lc3NhZ2UgPSBSZW1vdmVNZXNzYWdlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSystemMessageChunk = exports.isSystemMessage = exports.SystemMessageChunk = exports.SystemMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\nexports.SystemMessage = SystemMessage;\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.SystemMessageChunk = SystemMessageChunk;\nfunction isSystemMessage(x) {\n    return x._getType() === \"system\";\n}\nexports.isSystemMessage = isSystemMessage;\nfunction isSystemMessageChunk(x) {\n    return x._getType() === \"system\";\n}\nexports.isSystemMessageChunk = isSystemMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvc3lzdGVtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUI7QUFDM0csa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9zeXN0ZW0uY2pzPzUwYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzU3lzdGVtTWVzc2FnZUNodW5rID0gZXhwb3J0cy5pc1N5c3RlbU1lc3NhZ2UgPSBleHBvcnRzLlN5c3RlbU1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuU3lzdGVtTWVzc2FnZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3lzdGVtIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIFN5c3RlbU1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTeXN0ZW1NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG59XG5leHBvcnRzLlN5c3RlbU1lc3NhZ2UgPSBTeXN0ZW1NZXNzYWdlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBzeXN0ZW0gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBzeXN0ZW0gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIFN5c3RlbU1lc3NhZ2VDaHVuayBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TeXN0ZW1NZXNzYWdlQ2h1bmsgPSBTeXN0ZW1NZXNzYWdlQ2h1bms7XG5mdW5jdGlvbiBpc1N5c3RlbU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG59XG5leHBvcnRzLmlzU3lzdGVtTWVzc2FnZSA9IGlzU3lzdGVtTWVzc2FnZTtcbmZ1bmN0aW9uIGlzU3lzdGVtTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiO1xufVxuZXhwb3J0cy5pc1N5c3RlbU1lc3NhZ2VDaHVuayA9IGlzU3lzdGVtTWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isToolMessageChunk = exports.isToolMessage = exports.defaultToolCallParser = exports.ToolMessageChunk = exports.ToolMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessage = ToolMessage;\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            artifact: (0, base_js_1._mergeObj)(this.artifact, chunk.artifact),\n            tool_call_id: this.tool_call_id,\n            id: this.id ?? chunk.id,\n            status: (0, base_js_1._mergeStatus)(this.status, chunk.status),\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessageChunk = ToolMessageChunk;\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\nexports.defaultToolCallParser = defaultToolCallParser;\nfunction isToolMessage(x) {\n    return x._getType() === \"tool\";\n}\nexports.isToolMessage = isToolMessage;\nfunction isToolMessageChunk(x) {\n    return x._getType() === \"tool\";\n}\nexports.isToolMessageChunk = isToolMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQ25JLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5janM/ZjJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUb29sTWVzc2FnZUNodW5rID0gZXhwb3J0cy5pc1Rvb2xNZXNzYWdlID0gZXhwb3J0cy5kZWZhdWx0VG9vbENhbGxQYXJzZXIgPSBleHBvcnRzLlRvb2xNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLlRvb2xNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0b29sIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIFRvb2xNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VcIjtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7IHRvb2xfY2FsbF9pZDogXCJ0b29sX2NhbGxfaWRcIiB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHRvb2xfY2FsbF9pZCwgbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgbmFtZSwgdG9vbF9jYWxsX2lkOiB0b29sX2NhbGxfaWQgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdHVzIG9mIHRoZSB0b29sIGludm9jYXRpb24uXG4gICAgICAgICAqIEB2ZXJzaW9uIDAuMi4xOVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbF9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBhcnRpZmFjdDogdGhpcy5hcnRpZmFjdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xNZXNzYWdlID0gVG9vbE1lc3NhZ2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5jbGFzcyBUb29sTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGFydGlmYWN0OiAoMCwgYmFzZV9qc18xLl9tZXJnZU9iaikodGhpcy5hcnRpZmFjdCwgY2h1bmsuYXJ0aWZhY3QpLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICAgICAgc3RhdHVzOiAoMCwgYmFzZV9qc18xLl9tZXJnZVN0YXR1cykodGhpcy5zdGF0dXMsIGNodW5rLnN0YXR1cyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sTWVzc2FnZUNodW5rID0gVG9vbE1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGRlZmF1bHRUb29sQ2FsbFBhcnNlcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbHMpIHtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiByYXdUb29sQ2FsbHMpIHtcbiAgICAgICAgaWYgKCF0b29sQ2FsbC5mdW5jdGlvbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb25BcmdzIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdO1xufVxuZXhwb3J0cy5kZWZhdWx0VG9vbENhbGxQYXJzZXIgPSBkZWZhdWx0VG9vbENhbGxQYXJzZXI7XG5mdW5jdGlvbiBpc1Rvb2xNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcInRvb2xcIjtcbn1cbmV4cG9ydHMuaXNUb29sTWVzc2FnZSA9IGlzVG9vbE1lc3NhZ2U7XG5mdW5jdGlvbiBpc1Rvb2xNZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xufVxuZXhwb3J0cy5pc1Rvb2xNZXNzYWdlQ2h1bmsgPSBpc1Rvb2xNZXNzYWdlQ2h1bms7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/transformers.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultTextSplitter = exports.trimMessages = exports.mergeMessageRuns = exports.filterMessages = void 0;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst modifier_js_1 = __webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"_getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass._getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass._getType();\n        })),\n    ];\n    const msgType = msg._getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nfunction filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return base_js_1.RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nexports.filterMessages = filterMessages;\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nfunction mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return base_js_1.RunnableLambda.from(_mergeMessageRuns);\n}\nexports.mergeMessageRuns = mergeMessageRuns;\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg; // Create a shallow copy of the message\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr._getType() === \"tool\" ||\n            !(curr._getType() === last._getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = (0, utils_js_1.convertToChunk)(last);\n            const currChunk = (0, utils_js_1.convertToChunk)(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nfunction trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return base_js_1.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions));\n    }\n}\nexports.trimMessages = trimMessages;\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length - 1 && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded._getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messages &&\n            !_isMessageType(messages[messages.length - 1], endOnArr)) {\n            messages.pop();\n        }\n    }\n    const swappedSystem = includeSystem && messages[0]._getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messages.slice(0, 1).concat(messages.slice(1).reverse())\n        : messages.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: human_js_1.HumanMessage,\n        messageChunk: human_js_1.HumanMessageChunk,\n    },\n    ai: {\n        message: ai_js_1.AIMessage,\n        messageChunk: ai_js_1.AIMessageChunk,\n    },\n    system: {\n        message: system_js_1.SystemMessage,\n        messageChunk: system_js_1.SystemMessageChunk,\n    },\n    tool: {\n        message: tool_js_1.ToolMessage,\n        messageChunk: tool_js_1.ToolMessageChunk,\n    },\n    function: {\n        message: function_js_1.FunctionMessage,\n        messageChunk: function_js_1.FunctionMessageChunk,\n    },\n    generic: {\n        message: chat_js_1.ChatMessage,\n        messageChunk: chat_js_1.ChatMessageChunk,\n    },\n    remove: {\n        message: modifier_js_1.RemoveMessage,\n        messageChunk: modifier_js_1.RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new human_js_1.HumanMessageChunk(fields);\n            }\n            else {\n                msg = new human_js_1.HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new ai_js_1.AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new ai_js_1.AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new system_js_1.SystemMessageChunk(fields);\n            }\n            else {\n                msg = new system_js_1.SystemMessage(fields);\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new tool_js_1.ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new tool_js_1.ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new function_js_1.FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new function_js_1.FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new chat_js_1.ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new chat_js_1.ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk._getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nfunction defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\nexports.defaultTextSplitter = defaultTextSplitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdHJhbnNmb3JtZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0I7QUFDdEcsa0JBQWtCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFVO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsbUZBQWM7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QiwrQ0FBK0M7QUFDL0MsWUFBWSxrRkFBa0Y7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0IsSUFBSSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxZQUFZLHlIQUF5SDtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFnRTtBQUM1RTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSwwQkFBMEIsNEJBQTRCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3RyYW5zZm9ybWVycy5janM/NDNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdFRleHRTcGxpdHRlciA9IGV4cG9ydHMudHJpbU1lc3NhZ2VzID0gZXhwb3J0cy5tZXJnZU1lc3NhZ2VSdW5zID0gZXhwb3J0cy5maWx0ZXJNZXNzYWdlcyA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4vYWkuY2pzXCIpO1xuY29uc3QgY2hhdF9qc18xID0gcmVxdWlyZShcIi4vY2hhdC5janNcIik7XG5jb25zdCBmdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vZnVuY3Rpb24uY2pzXCIpO1xuY29uc3QgaHVtYW5fanNfMSA9IHJlcXVpcmUoXCIuL2h1bWFuLmNqc1wiKTtcbmNvbnN0IG1vZGlmaWVyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RpZmllci5janNcIik7XG5jb25zdCBzeXN0ZW1fanNfMSA9IHJlcXVpcmUoXCIuL3N5c3RlbS5janNcIik7XG5jb25zdCB0b29sX2pzXzEgPSByZXF1aXJlKFwiLi90b29sLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5jb25zdCBfaXNNZXNzYWdlVHlwZSA9IChtc2csIHR5cGVzKSA9PiB7XG4gICAgY29uc3QgdHlwZXNBc1N0cmluZ3MgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQodHlwZXM/Lm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgaW5zdGFudGlhdGVkTXNnQ2xhc3MgPSBuZXcgdCh7fSk7XG4gICAgICAgICAgICBpZiAoIShcIl9nZXRUeXBlXCIgaW4gaW5zdGFudGlhdGVkTXNnQ2xhc3MpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbnRpYXRlZE1zZ0NsYXNzLl9nZXRUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGUgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlZE1zZ0NsYXNzLl9nZXRUeXBlKCk7XG4gICAgICAgIH0pKSxcbiAgICBdO1xuICAgIGNvbnN0IG1zZ1R5cGUgPSBtc2cuX2dldFR5cGUoKTtcbiAgICByZXR1cm4gdHlwZXNBc1N0cmluZ3Muc29tZSgodCkgPT4gdCA9PT0gbXNnVHlwZSk7XG59O1xuZnVuY3Rpb24gZmlsdGVyTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlc09yT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJNZXNzYWdlcyhtZXNzYWdlc09yT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJNZXNzYWdlcyhpbnB1dCwgbWVzc2FnZXNPck9wdGlvbnMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5maWx0ZXJNZXNzYWdlcyA9IGZpbHRlck1lc3NhZ2VzO1xuZnVuY3Rpb24gX2ZpbHRlck1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGluY2x1ZGVOYW1lcywgZXhjbHVkZU5hbWVzLCBpbmNsdWRlVHlwZXMsIGV4Y2x1ZGVUeXBlcywgaW5jbHVkZUlkcywgZXhjbHVkZUlkcywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1zZyBvZiBtZXNzYWdlcykge1xuICAgICAgICBpZiAoZXhjbHVkZU5hbWVzICYmIG1zZy5uYW1lICYmIGV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVUeXBlcyAmJiBfaXNNZXNzYWdlVHlwZShtc2csIGV4Y2x1ZGVUeXBlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVJZHMgJiYgbXNnLmlkICYmIGV4Y2x1ZGVJZHMuaW5jbHVkZXMobXNnLmlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB0byBpbmNsdXNpb24gd2hlbiBubyBpbmNsdXNpb24gY3JpdGVyaWEgZ2l2ZW4uXG4gICAgICAgIGlmICghKGluY2x1ZGVUeXBlcyB8fCBpbmNsdWRlSWRzIHx8IGluY2x1ZGVOYW1lcykpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlTmFtZXMgJiZcbiAgICAgICAgICAgIG1zZy5uYW1lICYmXG4gICAgICAgICAgICBpbmNsdWRlTmFtZXMuc29tZSgoaU5hbWUpID0+IGlOYW1lID09PSBtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlVHlwZXMgJiYgX2lzTWVzc2FnZVR5cGUobXNnLCBpbmNsdWRlVHlwZXMpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZUlkcyAmJiBtc2cuaWQgJiYgaW5jbHVkZUlkcy5zb21lKChpZCkgPT4gaWQgPT09IG1zZy5pZCkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU1lc3NhZ2VSdW5zKG1lc3NhZ2VzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbShfbWVyZ2VNZXNzYWdlUnVucyk7XG59XG5leHBvcnRzLm1lcmdlTWVzc2FnZVJ1bnMgPSBtZXJnZU1lc3NhZ2VSdW5zO1xuZnVuY3Rpb24gX21lcmdlTWVzc2FnZVJ1bnMobWVzc2FnZXMpIHtcbiAgICBpZiAoIW1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgbXNnIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBtc2c7IC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiB0aGUgbWVzc2FnZVxuICAgICAgICBjb25zdCBsYXN0ID0gbWVyZ2VkLnBvcCgpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKGN1cnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnIuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCIgfHxcbiAgICAgICAgICAgICEoY3Vyci5fZ2V0VHlwZSgpID09PSBsYXN0Ll9nZXRUeXBlKCkpKSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChsYXN0LCBjdXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaHVuayA9ICgwLCB1dGlsc19qc18xLmNvbnZlcnRUb0NodW5rKShsYXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJDaHVuayA9ICgwLCB1dGlsc19qc18xLmNvbnZlcnRUb0NodW5rKShjdXJyKTtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZENodW5rcyA9IGxhc3RDaHVuay5jb25jYXQoY3VyckNodW5rKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdENodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY3VyckNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MuY29udGVudCA9IGAke2xhc3RDaHVuay5jb250ZW50fVxcbiR7Y3VyckNodW5rLmNvbnRlbnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZC5wdXNoKF9jaHVua1RvTXNnKG1lcmdlZENodW5rcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5mdW5jdGlvbiB0cmltTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlc09yT3B0aW9ucykpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yT3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHByb3ZpZGluZyBtZXNzYWdlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90cmltTWVzc2FnZXNIZWxwZXIobWVzc2FnZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHJpbW1lck9wdGlvbnMgPSBtZXNzYWdlc09yT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUxhbWJkYS5mcm9tKChpbnB1dCkgPT4gX3RyaW1NZXNzYWdlc0hlbHBlcihpbnB1dCwgdHJpbW1lck9wdGlvbnMpKTtcbiAgICB9XG59XG5leHBvcnRzLnRyaW1NZXNzYWdlcyA9IHRyaW1NZXNzYWdlcztcbmFzeW5jIGZ1bmN0aW9uIF90cmltTWVzc2FnZXNIZWxwZXIobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCBzdHJhdGVneSA9IFwibGFzdFwiLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSwgZW5kT24sIHN0YXJ0T24sIGluY2x1ZGVTeXN0ZW0gPSBmYWxzZSwgdGV4dFNwbGl0dGVyLCB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RhcnRPbiAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzdGFydE9uYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZVN5c3RlbSAmJiBzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBpbmNsdWRlU3lzdGVtYCBzaG91bGQgb25seSBiZSBzcGVjaWZpZWQgaWYgYHN0cmF0ZWd5YCBpcyAnbGFzdCcuXCIpO1xuICAgIH1cbiAgICBsZXQgbGlzdFRva2VuQ291bnRlcjtcbiAgICBpZiAoXCJnZXROdW1Ub2tlbnNcIiBpbiB0b2tlbkNvdW50ZXIpIHtcbiAgICAgICAgbGlzdFRva2VuQ291bnRlciA9IGFzeW5jIChtc2dzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50cyA9IGF3YWl0IFByb21pc2UuYWxsKG1zZ3MubWFwKChtc2cpID0+IHRva2VuQ291bnRlci5nZXROdW1Ub2tlbnMobXNnLmNvbnRlbnQpKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5Db3VudHMucmVkdWNlKChzdW0sIGNvdW50KSA9PiBzdW0gKyBjb3VudCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaXN0VG9rZW5Db3VudGVyID0gYXN5bmMgKG1zZ3MpID0+IHRva2VuQ291bnRlcihtc2dzKTtcbiAgICB9XG4gICAgbGV0IHRleHRTcGxpdHRlckZ1bmMgPSBkZWZhdWx0VGV4dFNwbGl0dGVyO1xuICAgIGlmICh0ZXh0U3BsaXR0ZXIpIHtcbiAgICAgICAgaWYgKFwic3BsaXRUZXh0XCIgaW4gdGV4dFNwbGl0dGVyKSB7XG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXJGdW5jID0gdGV4dFNwbGl0dGVyLnNwbGl0VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRTcGxpdHRlckZ1bmMgPSBhc3luYyAodGV4dCkgPT4gdGV4dFNwbGl0dGVyKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJhdGVneSA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgIHJldHVybiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIHtcbiAgICAgICAgICAgIG1heFRva2VucyxcbiAgICAgICAgICAgIHRva2VuQ291bnRlcjogbGlzdFRva2VuQ291bnRlcixcbiAgICAgICAgICAgIHRleHRTcGxpdHRlcjogdGV4dFNwbGl0dGVyRnVuYyxcbiAgICAgICAgICAgIHBhcnRpYWxTdHJhdGVneTogYWxsb3dQYXJ0aWFsID8gXCJmaXJzdFwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kT24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9sYXN0TWF4VG9rZW5zKG1lc3NhZ2VzLCB7XG4gICAgICAgICAgICBtYXhUb2tlbnMsXG4gICAgICAgICAgICB0b2tlbkNvdW50ZXI6IGxpc3RUb2tlbkNvdW50ZXIsXG4gICAgICAgICAgICB0ZXh0U3BsaXR0ZXI6IHRleHRTcGxpdHRlckZ1bmMsXG4gICAgICAgICAgICBhbGxvd1BhcnRpYWwsXG4gICAgICAgICAgICBpbmNsdWRlU3lzdGVtLFxuICAgICAgICAgICAgc3RhcnRPbixcbiAgICAgICAgICAgIGVuZE9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHN0cmF0ZWd5OiAnJHtzdHJhdGVneX0nLiBNdXN0IGJlIG9uZSBvZiAnZmlyc3QnIG9yICdsYXN0Jy5gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBfZmlyc3RNYXhUb2tlbnMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1heFRva2VucywgdG9rZW5Db3VudGVyLCB0ZXh0U3BsaXR0ZXIsIHBhcnRpYWxTdHJhdGVneSwgZW5kT24gfSA9IG9wdGlvbnM7XG4gICAgbGV0IG1lc3NhZ2VzQ29weSA9IFsuLi5tZXNzYWdlc107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlc0NvcHkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nTWVzc2FnZXMgPSBpID4gMCA/IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAtaSkgOiBtZXNzYWdlc0NvcHk7XG4gICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKHJlbWFpbmluZ01lc3NhZ2VzKSkgPD0gbWF4VG9rZW5zKSB7XG4gICAgICAgICAgICBpZHggPSBtZXNzYWdlc0NvcHkubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpZHggPCBtZXNzYWdlc0NvcHkubGVuZ3RoIC0gMSAmJiBwYXJ0aWFsU3RyYXRlZ3kpIHtcbiAgICAgICAgbGV0IGluY2x1ZGVkUGFydGlhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlc0NvcHlbaWR4XS5jb250ZW50KSkge1xuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBtZXNzYWdlc0NvcHlbaWR4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhjbHVkZWQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvbnRlbnQgdG8gYmUgYW4gYXJyYXkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtQmxvY2sgPSBleGNsdWRlZC5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkQ29udGVudCA9IHBhcnRpYWxTdHJhdGVneSA9PT0gXCJsYXN0XCJcbiAgICAgICAgICAgICAgICA/IFsuLi5leGNsdWRlZC5jb250ZW50XS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICA6IGV4Y2x1ZGVkLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1CbG9jazsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbENvbnRlbnQgPSBwYXJ0aWFsU3RyYXRlZ3kgPT09IFwiZmlyc3RcIlxuICAgICAgICAgICAgICAgICAgICA/IHJldmVyc2VkQ29udGVudC5zbGljZSgwLCBpKVxuICAgICAgICAgICAgICAgICAgICA6IHJldmVyc2VkQ29udGVudC5zbGljZSgtaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGV4Y2x1ZGVkKS5maWx0ZXIoKFtrXSkgPT4gayAhPT0gXCJ0eXBlXCIgJiYgIWsuc3RhcnRzV2l0aChcImxjX1wiKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlID0gX3N3aXRjaFR5cGVUb01lc3NhZ2UoZXhjbHVkZWQuX2dldFR5cGUoKSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnRpYWxDb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlZE1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzQ29weS5zbGljZSgwLCBpZHgpLCB1cGRhdGVkTWVzc2FnZV07XG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCB0b2tlbkNvdW50ZXIoc2xpY2VkTWVzc2FnZXMpKSA8PSBtYXhUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNDb3B5ID0gc2xpY2VkTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGVkUGFydGlhbCAmJiBwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudCA9IFsuLi5yZXZlcnNlZENvbnRlbnRdLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVkUGFydGlhbCkge1xuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBtZXNzYWdlc0NvcHlbaWR4XTtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhjbHVkZWQuY29udGVudCkgJiZcbiAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50LnNvbWUoKGJsb2NrKSA9PiB0eXBlb2YgYmxvY2sgPT09IFwic3RyaW5nXCIgfHwgYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEJsb2NrID0gZXhjbHVkZWQuY29udGVudC5maW5kKChibG9jaykgPT4gYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgYmxvY2sudGV4dCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHRCbG9jaz8udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBleGNsdWRlZC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGV4Y2x1ZGVkLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0VGV4dHMgPSBhd2FpdCB0ZXh0U3BsaXR0ZXIodGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtU3BsaXRzID0gc3BsaXRUZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxTdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRUZXh0cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgbnVtU3BsaXRzIC0gMTsgXyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0VGV4dHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVkLmNvbnRlbnQgPSBzcGxpdFRleHRzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgZXhjbHVkZWRdKSkgPD1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxTdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50ID0gWy4uLnNwbGl0VGV4dHNdLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNDb3B5ID0gWy4uLm1lc3NhZ2VzQ29weS5zbGljZSgwLCBpZHgpLCBleGNsdWRlZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRPbikge1xuICAgICAgICBjb25zdCBlbmRPbkFyciA9IEFycmF5LmlzQXJyYXkoZW5kT24pID8gZW5kT24gOiBbZW5kT25dO1xuICAgICAgICB3aGlsZSAoaWR4ID4gMCAmJiAhX2lzTWVzc2FnZVR5cGUobWVzc2FnZXNDb3B5W2lkeCAtIDFdLCBlbmRPbkFycikpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9sYXN0TWF4VG9rZW5zKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbGxvd1BhcnRpYWwgPSBmYWxzZSwgaW5jbHVkZVN5c3RlbSA9IGZhbHNlLCBlbmRPbiwgc3RhcnRPbiwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICBpZiAoZW5kT24pIHtcbiAgICAgICAgY29uc3QgZW5kT25BcnIgPSBBcnJheS5pc0FycmF5KGVuZE9uKSA/IGVuZE9uIDogW2VuZE9uXTtcbiAgICAgICAgd2hpbGUgKG1lc3NhZ2VzICYmXG4gICAgICAgICAgICAhX2lzTWVzc2FnZVR5cGUobWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sIGVuZE9uQXJyKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3dhcHBlZFN5c3RlbSA9IGluY2x1ZGVTeXN0ZW0gJiYgbWVzc2FnZXNbMF0uX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbiAgICBsZXQgcmV2ZXJzZWRfID0gc3dhcHBlZFN5c3RlbVxuICAgICAgICA/IG1lc3NhZ2VzLnNsaWNlKDAsIDEpLmNvbmNhdChtZXNzYWdlcy5zbGljZSgxKS5yZXZlcnNlKCkpXG4gICAgICAgIDogbWVzc2FnZXMucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkXyA9IGF3YWl0IF9maXJzdE1heFRva2VucyhyZXZlcnNlZF8sIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgcGFydGlhbFN0cmF0ZWd5OiBhbGxvd1BhcnRpYWwgPyBcImxhc3RcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5kT246IHN0YXJ0T24sXG4gICAgfSk7XG4gICAgaWYgKHN3YXBwZWRTeXN0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFtyZXZlcnNlZF9bMF0sIC4uLnJldmVyc2VkXy5zbGljZSgxKS5yZXZlcnNlKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2VkXy5yZXZlcnNlKCk7XG4gICAgfVxufVxuY29uc3QgX01TR19DSFVOS19NQVAgPSB7XG4gICAgaHVtYW46IHtcbiAgICAgICAgbWVzc2FnZTogaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGFpOiB7XG4gICAgICAgIG1lc3NhZ2U6IGFpX2pzXzEuQUlNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBzeXN0ZW06IHtcbiAgICAgICAgbWVzc2FnZTogc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICB0b29sOiB7XG4gICAgICAgIG1lc3NhZ2U6IHRvb2xfanNfMS5Ub29sTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiB0b29sX2pzXzEuVG9vbE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBnZW5lcmljOiB7XG4gICAgICAgIG1lc3NhZ2U6IGNoYXRfanNfMS5DaGF0TWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIHJlbW92ZToge1xuICAgICAgICBtZXNzYWdlOiBtb2RpZmllcl9qc18xLlJlbW92ZU1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogbW9kaWZpZXJfanNfMS5SZW1vdmVNZXNzYWdlLCAvLyBSZW1vdmVNZXNzYWdlIGRvZXMgbm90IGhhdmUgYSBjaHVuayBjbGFzcy5cbiAgICB9LFxufTtcbmZ1bmN0aW9uIF9zd2l0Y2hUeXBlVG9NZXNzYWdlKG1lc3NhZ2VUeXBlLCBmaWVsZHMsIHJldHVybkNodW5rKSB7XG4gICAgbGV0IGNodW5rO1xuICAgIGxldCBtc2c7XG4gICAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChcInRvb2xfY2FsbHNcIiBpbiBhaUNodW5rRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5haUNodW5rRmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogYWlDaHVua0ZpZWxkcy50b29sX2NhbGxzPy5tYXAoKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnN0cmluZ2lmeSh0Yy5hcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgYWlfanNfMS5BSU1lc3NhZ2VDaHVuayhhaUNodW5rRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBhaV9qc18xLkFJTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgaWYgKFwidG9vbF9jYWxsX2lkXCIgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IHRvb2xfanNfMS5Ub29sTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFRvb2xNZXNzYWdlIHRvIFRvb2xNZXNzYWdlQ2h1bmsgaWYgJ3Rvb2xfY2FsbF9pZCcgZmllbGQgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgZnVuY3Rpb25fanNfMS5GdW5jdGlvbk1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZHMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbk1lc3NhZ2UgbXVzdCBoYXZlIGEgJ25hbWUnIGZpZWxkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgZnVuY3Rpb25fanNfMS5GdW5jdGlvbk1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOlxuICAgICAgICAgICAgaWYgKFwicm9sZVwiIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IGNoYXRfanNfMS5DaGF0TWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBDaGF0TWVzc2FnZSB0byBDaGF0TWVzc2FnZUNodW5rIGlmICdyb2xlJyBmaWVsZCBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZSAke21lc3NhZ2VUeXBlfWApO1xuICAgIH1cbiAgICBpZiAocmV0dXJuQ2h1bmsgJiYgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZSAke21lc3NhZ2VUeXBlfWApO1xufVxuZnVuY3Rpb24gX2NodW5rVG9Nc2coY2h1bmspIHtcbiAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay5fZ2V0VHlwZSgpO1xuICAgIGxldCBtc2c7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNodW5rKS5maWx0ZXIoKFtrXSkgPT4gIVtcInR5cGVcIiwgXCJ0b29sX2NhbGxfY2h1bmtzXCJdLmluY2x1ZGVzKGspICYmICFrLnN0YXJ0c1dpdGgoXCJsY19cIikpKTtcbiAgICBpZiAoY2h1bmtUeXBlIGluIF9NU0dfQ0hVTktfTUFQKSB7XG4gICAgICAgIG1zZyA9IF9zd2l0Y2hUeXBlVG9NZXNzYWdlKGNodW5rVHlwZSwgZmllbGRzKTtcbiAgICB9XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbWVzc2FnZSBjaHVuayBjbGFzcyAke2NodW5rVHlwZX0uIFN1cHBvcnRlZCBjbGFzc2VzIGFyZSAke09iamVjdC5rZXlzKF9NU0dfQ0hVTktfTUFQKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgdGV4dCBzcGxpdHRlciBmdW5jdGlvbiB0aGF0IHNwbGl0cyB0ZXh0IGJ5IG5ld2xpbmVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0VGV4dFNwbGl0dGVyKHRleHQpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1xuICAgICAgICAuLi5zcGxpdHMuc2xpY2UoMCwgLTEpLm1hcCgocykgPT4gYCR7c31cXG5gKSxcbiAgICAgICAgc3BsaXRzW3NwbGl0cy5sZW5ndGggLSAxXSxcbiAgICBdKTtcbn1cbmV4cG9ydHMuZGVmYXVsdFRleHRTcGxpdHRlciA9IGRlZmF1bHRUZXh0U3BsaXR0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertToChunk = exports.mapChatMessagesToStoredMessages = exports.mapStoredMessagesToChatMessages = exports.mapStoredMessageToChatMessage = exports.getBufferString = exports.coerceMessageLikeToMessage = void 0;\nconst index_js_1 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nfunction _coerceToolCall(toolCall) {\n    if ((0, utils_js_1._isToolCall)(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction isSerializedConstructor(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        x.lc === 1 &&\n        Array.isArray(x.id) &&\n        x.kwargs != null &&\n        typeof x.kwargs === \"object\");\n}\nfunction _constructMessageFromParams(params) {\n    let type;\n    let rest;\n    // Support serialized messages\n    if (isSerializedConstructor(params)) {\n        const className = params.id.at(-1);\n        if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n            type = \"user\";\n        }\n        else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n            type = \"assistant\";\n        }\n        else if (className === \"SystemMessage\" ||\n            className === \"SystemMessageChunk\") {\n            type = \"system\";\n        }\n        else {\n            type = \"unknown\";\n        }\n        rest = params.kwargs;\n    }\n    else {\n        const { type: extractedType, ...otherParams } = params;\n        type = extractedType;\n        rest = otherParams;\n    }\n    if (type === \"human\" || type === \"user\") {\n        return new human_js_1.HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new ai_js_1.AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new ai_js_1.AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new system_js_1.SystemMessage(rest);\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new tool_js_1.ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else {\n        const error = (0, index_js_1.addLangChainErrorFields)(new Error(`Unable to coerce message from array: only human, AI, system, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n        throw error;\n    }\n}\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new human_js_1.HumanMessage(messageLike);\n    }\n    else if ((0, base_js_1.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if ((0, base_js_1._isMessageFieldWithRole)(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\nexports.coerceMessageLikeToMessage = coerceMessageLikeToMessage;\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\nexports.getBufferString = getBufferString;\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new human_js_1.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new ai_js_1.AIMessage(storedMessage.data);\n        case \"system\":\n            return new system_js_1.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new function_js_1.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new tool_js_1.ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new chat_js_1.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\nexports.mapStoredMessageToChatMessage = mapStoredMessageToChatMessage;\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\nexports.mapStoredMessagesToChatMessages = mapStoredMessagesToChatMessages;\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nexports.mapChatMessagesToStoredMessages = mapChatMessagesToStoredMessages;\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new human_js_1.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new ai_js_1.AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new system_js_1.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new function_js_1.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (chat_js_1.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new chat_js_1.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\nexports.convertToChunk = convertToChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHVDQUF1QyxHQUFHLHVDQUF1QyxHQUFHLHFDQUFxQyxHQUFHLHVCQUF1QixHQUFHLGtDQUFrQztBQUNqTixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMscUZBQW9CO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFVO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYztBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc01BQXNNLGdDQUFnQztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0Qyw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssSUFBSSxRQUFRLEVBQUUsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3V0aWxzLmNqcz81N2ExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb252ZXJ0VG9DaHVuayA9IGV4cG9ydHMubWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcyA9IGV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZXNUb0NoYXRNZXNzYWdlcyA9IGV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UgPSBleHBvcnRzLmdldEJ1ZmZlclN0cmluZyA9IGV4cG9ydHMuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2Vycm9ycy9pbmRleC5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3Rvb2xzL3V0aWxzLmNqc1wiKTtcbmNvbnN0IGFpX2pzXzEgPSByZXF1aXJlKFwiLi9haS5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGNoYXRfanNfMSA9IHJlcXVpcmUoXCIuL2NoYXQuY2pzXCIpO1xuY29uc3QgZnVuY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLmNqc1wiKTtcbmNvbnN0IGh1bWFuX2pzXzEgPSByZXF1aXJlKFwiLi9odW1hbi5janNcIik7XG5jb25zdCBzeXN0ZW1fanNfMSA9IHJlcXVpcmUoXCIuL3N5c3RlbS5janNcIik7XG5jb25zdCB0b29sX2pzXzEgPSByZXF1aXJlKFwiLi90b29sLmNqc1wiKTtcbmZ1bmN0aW9uIF9jb2VyY2VUb29sQ2FsbCh0b29sQ2FsbCkge1xuICAgIGlmICgoMCwgdXRpbHNfanNfMS5faXNUb29sQ2FsbCkodG9vbENhbGwpKSB7XG4gICAgICAgIHJldHVybiB0b29sQ2FsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRvb2xDYWxsLmlkID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHRvb2xDYWxsLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24gIT09IG51bGwgJiZcbiAgICAgICAgXCJhcmd1bWVudHNcIiBpbiB0b29sQ2FsbC5mdW5jdGlvbiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIFwibmFtZVwiIGluIHRvb2xDYWxsLmZ1bmN0aW9uICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEhhbmRsZSBPcGVuQUkgdG9vbCBjYWxsIGZvcm1hdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgYXJnczogSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpLFxuICAgICAgICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBUaHJvdyBhbiBlcnJvcj9cbiAgICAgICAgcmV0dXJuIHRvb2xDYWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZENvbnN0cnVjdG9yKHgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHggIT0gbnVsbCAmJlxuICAgICAgICB4LmxjID09PSAxICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5pZCkgJiZcbiAgICAgICAgeC5rd2FyZ3MgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5rd2FyZ3MgPT09IFwib2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHBhcmFtcykge1xuICAgIGxldCB0eXBlO1xuICAgIGxldCByZXN0O1xuICAgIC8vIFN1cHBvcnQgc2VyaWFsaXplZCBtZXNzYWdlc1xuICAgIGlmIChpc1NlcmlhbGl6ZWRDb25zdHJ1Y3RvcihwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHBhcmFtcy5pZC5hdCgtMSk7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwiSHVtYW5NZXNzYWdlXCIgfHwgY2xhc3NOYW1lID09PSBcIkh1bWFuTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInVzZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiQUlNZXNzYWdlXCIgfHwgY2xhc3NOYW1lID09PSBcIkFJTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImFzc2lzdGFudFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJTeXN0ZW1NZXNzYWdlXCIgfHxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9PT0gXCJTeXN0ZW1NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwic3lzdGVtXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ1bmtub3duXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHBhcmFtcy5rd2FyZ3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGU6IGV4dHJhY3RlZFR5cGUsIC4uLm90aGVyUGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIHR5cGUgPSBleHRyYWN0ZWRUeXBlO1xuICAgICAgICByZXN0ID0gb3RoZXJQYXJhbXM7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIgfHwgdHlwZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShyZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiIHx8IHR5cGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgeyB0b29sX2NhbGxzOiByYXdUb29sQ2FsbHMsIC4uLm90aGVyIH0gPSByZXN0O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3VG9vbENhbGxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhaV9qc18xLkFJTWVzc2FnZShyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sX2NhbGxzID0gcmF3VG9vbENhbGxzLm1hcChfY29lcmNlVG9vbENhbGwpO1xuICAgICAgICByZXR1cm4gbmV3IGFpX2pzXzEuQUlNZXNzYWdlKHsgLi4ub3RoZXIsIHRvb2xfY2FsbHMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlKHJlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInRvb2xcIiAmJiBcInRvb2xfY2FsbF9pZFwiIGluIHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3QuY29udGVudCxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogcmVzdC50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBuYW1lOiByZXN0Lm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoMCwgaW5kZXhfanNfMS5hZGRMYW5nQ2hhaW5FcnJvckZpZWxkcykobmV3IEVycm9yKGBVbmFibGUgdG8gY29lcmNlIG1lc3NhZ2UgZnJvbSBhcnJheTogb25seSBodW1hbiwgQUksIHN5c3RlbSwgb3IgdG9vbCBtZXNzYWdlIGNvZXJjaW9uIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXFxuXFxuUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAyKX1gKSwgXCJNRVNTQUdFX0NPRVJDSU9OX0ZBSUxVUkVcIik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKG1lc3NhZ2VMaWtlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlTGlrZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlKG1lc3NhZ2VMaWtlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGJhc2VfanNfMS5pc0Jhc2VNZXNzYWdlKShtZXNzYWdlTGlrZSkpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VMaWtlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlTGlrZSkpIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGNvbnRlbnRdID0gbWVzc2FnZUxpa2U7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMoeyB0eXBlLCBjb250ZW50IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgYmFzZV9qc18xLl9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlKShtZXNzYWdlTGlrZSkpIHtcbiAgICAgICAgY29uc3QgeyByb2xlOiB0eXBlLCAuLi5yZXN0IH0gPSBtZXNzYWdlTGlrZTtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyh7IC4uLnJlc3QsIHR5cGUgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKG1lc3NhZ2VMaWtlKTtcbiAgICB9XG59XG5leHBvcnRzLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlID0gY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2U7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBtZW1vcnkgY2xhc3NlcyB0byBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBjaGF0IG1lc3NhZ2UgaGlzdG9yeSwgYmFzZWQgb24gdGhlIG1lc3NhZ2UgY29udGVudCBhbmQgcm9sZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VzLCBodW1hblByZWZpeCA9IFwiSHVtYW5cIiwgYWlQcmVmaXggPSBcIkFJXCIpIHtcbiAgICBjb25zdCBzdHJpbmdfbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgbGV0IHJvbGU7XG4gICAgICAgIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiaHVtYW5cIikge1xuICAgICAgICAgICAgcm9sZSA9IGh1bWFuUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJhaVwiKSB7XG4gICAgICAgICAgICByb2xlID0gYWlQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJTeXN0ZW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiRnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJUb29sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcm9sZSA9IG0ucm9sZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZTogJHttLl9nZXRUeXBlKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZVN0ciA9IG0ubmFtZSA/IGAke20ubmFtZX0sIGAgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRlbnQgPSB0eXBlb2YgbS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG0uY29udGVudFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShtLmNvbnRlbnQsIG51bGwsIDIpO1xuICAgICAgICBzdHJpbmdfbWVzc2FnZXMucHVzaChgJHtyb2xlfTogJHtuYW1lU3RyfSR7cmVhZGFibGVDb250ZW50fWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nX21lc3NhZ2VzLmpvaW4oXCJcXG5cIik7XG59XG5leHBvcnRzLmdldEJ1ZmZlclN0cmluZyA9IGdldEJ1ZmZlclN0cmluZztcbi8qKlxuICogTWFwcyBtZXNzYWdlcyBmcm9tIGFuIG9sZGVyIGZvcm1hdCAoVjEpIHRvIHRoZSBjdXJyZW50IGBTdG9yZWRNZXNzYWdlYFxuICogZm9ybWF0LiBJZiB0aGUgbWVzc2FnZSBpcyBhbHJlYWR5IGluIHRoZSBgU3RvcmVkTWVzc2FnZWAgZm9ybWF0LCBpdCBpc1xuICogcmV0dXJuZWQgYXMgaXMuIE90aGVyd2lzZSwgaXQgdHJhbnNmb3JtcyB0aGUgVjEgbWVzc2FnZSBpbnRvIGFcbiAqIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIG1haW50YWluaW5nXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgbWVzc2FnZSBmb3JtYXRzLlxuICovXG5mdW5jdGlvbiBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIG1hcHBlciB3aGVuIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIG1lc3NhZ2UgZm9ybWF0LlxuICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYxTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2MU1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2MU1lc3NhZ2UudGV4dCxcbiAgICAgICAgICAgICAgICByb2xlOiB2MU1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBzdG9yZWRNZXNzYWdlID0gbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHN3aXRjaCAoc3RvcmVkTWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgYWlfanNfMS5BSU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInN5c3RlbVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIG11c3QgYmUgZGVmaW5lZCBmb3IgZnVuY3Rpb24gbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLnRvb2xfY2FsbF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIElEIG11c3QgYmUgZGVmaW5lZCBmb3IgdG9vbCBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6IHtcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEucm9sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBtdXN0IGJlIGRlZmluZWQgZm9yIGNoYXQgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNoYXRfanNfMS5DaGF0TWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmV4cGVjdGVkIHR5cGU6ICR7c3RvcmVkTWVzc2FnZS50eXBlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UgPSBtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZTtcbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCB1c2VzIHRoZSBgbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlYFxuICogZnVuY3Rpb24gdG8gZW5zdXJlIGFsbCBtZXNzYWdlcyBhcmUgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIHRoZW5cbiAqIGNyZWF0ZXMgbmV3IGluc3RhbmNlcyBvZiB0aGUgYXBwcm9wcmlhdGUgYEJhc2VNZXNzYWdlYCBzdWJjbGFzcyBiYXNlZFxuICogb24gdGhlIHR5cGUgb2YgZWFjaCBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlcGFyZSBzdG9yZWRcbiAqIG1lc3NhZ2VzIGZvciB1c2UgaW4gYSBjaGF0IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKTtcbn1cbmV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZXNUb0NoYXRNZXNzYWdlcyA9IG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXM7XG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYFN0b3JlZE1lc3NhZ2VgIGluc3RhbmNlcy4gSXQgZG9lcyB0aGlzIGJ5IGNhbGxpbmcgdGhlIGB0b0RpY3RgIG1ldGhvZFxuICogb24gZWFjaCBgQmFzZU1lc3NhZ2VgLCB3aGljaCByZXR1cm5zIGEgYFN0b3JlZE1lc3NhZ2VgLiBUaGlzIGZ1bmN0aW9uXG4gKiBpcyB1c2VkIHRvIHByZXBhcmUgY2hhdCBtZXNzYWdlcyBmb3Igc3RvcmFnZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UudG9EaWN0KCkpO1xufVxuZXhwb3J0cy5tYXBDaGF0TWVzc2FnZXNUb1N0b3JlZE1lc3NhZ2VzID0gbWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcztcbmZ1bmN0aW9uIGNvbnZlcnRUb0NodW5rKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImFpXCIpIHtcbiAgICAgICAgbGV0IGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJ0b29sX2NhbGxzXCIgaW4gYWlDaHVua0ZpZWxkcykge1xuICAgICAgICAgICAgYWlDaHVua0ZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5haUNodW5rRmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IGFpQ2h1bmtGaWVsZHMudG9vbF9jYWxscz8ubWFwKCh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KHRjLmFyZ3MpLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmsoeyAuLi5haUNodW5rRmllbGRzIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXRfanNfMS5DaGF0TWVzc2FnZS5pc0luc3RhbmNlKG1lc3NhZ2UpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1lc3NhZ2UgdHlwZS5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5jb252ZXJ0VG9DaHVuayA9IGNvbnZlcnRUb0NodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/base.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutputParserException = exports.BaseOutputParser = exports.BaseLLMOutputParser = void 0;\nconst index_js_1 = __webpack_require__(/*! ../runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nclass BaseLLMOutputParser extends index_js_1.Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    _baseMessageToString(message) {\n        return typeof message.content === \"string\"\n            ? message.content\n            : this._baseMessageContentToString(message.content);\n    }\n    _baseMessageContentToString(content) {\n        return JSON.stringify(content);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input, options) => this.parseResult([{ text: input }], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input, options) => this.parseResult([\n                {\n                    message: input,\n                    text: this._baseMessageToString(input),\n                },\n            ], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\nexports.BaseLLMOutputParser = BaseLLMOutputParser;\n/**\n * Class to parse the output of an LLM call.\n */\nclass BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\nexports.BaseOutputParser = BaseOutputParser;\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nclass OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n        (0, index_js_2.addLangChainErrorFields)(this, \"OUTPUT_PARSING_FAILURE\");\n    }\n}\nexports.OutputParserException = OutputParserException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCO0FBQ3RGLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYSxpQ0FBaUMsK0JBQStCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5janM/N2M2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0cHV0UGFyc2VyRXhjZXB0aW9uID0gZXhwb3J0cy5CYXNlT3V0cHV0UGFyc2VyID0gZXhwb3J0cy5CYXNlTExNT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvaW5kZXguY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvaW5kZXguY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwYXJzaW5nIHRoZSBvdXRwdXQgb2YgYSBMYXJnZSBMYW5ndWFnZSBNb2RlbFxuICogKExMTSkgY2FsbC4gSXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgcGFyc2luZyB0aGUgcmVzdWx0IG9mIGFuIExMTSBjYWxsXG4gKiBhbmQgaW52b2tpbmcgdGhlIHBhcnNlciB3aXRoIGEgZ2l2ZW4gaW5wdXQuXG4gKi9cbmNsYXNzIEJhc2VMTE1PdXRwdXRQYXJzZXIgZXh0ZW5kcyBpbmRleF9qc18xLlJ1bm5hYmxlIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHJlc3VsdCBvZiBhbiBMTE0gY2FsbCB3aXRoIGEgZ2l2ZW4gcHJvbXB0LiBCeSBkZWZhdWx0LCBpdFxuICAgICAqIHNpbXBseSBjYWxscyBgcGFyc2VSZXN1bHRgLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0aW9ucyBUaGUgZ2VuZXJhdGlvbnMgZnJvbSBhbiBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gX3Byb21wdCBUaGUgcHJvbXB0IHVzZWQgaW4gdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgT3B0aW9uYWwgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBwYXJzZVJlc3VsdFdpdGhQcm9tcHQoZ2VuZXJhdGlvbnMsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3VsdChnZW5lcmF0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlVG9TdHJpbmcobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgIDogdGhpcy5fYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcobWVzc2FnZS5jb250ZW50KTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlQ29udGVudFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgcGFyc2VyIHdpdGggYSBnaXZlbiBpbnB1dCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgY3JlYXRlcyBhIGdlbmVyYXRpb24gd2l0aCB0aGUgaW5wdXQgYXNcbiAgICAgKiB0ZXh0IGFuZCBjYWxscyBgcGFyc2VSZXN1bHRgLiBJZiB0aGUgaW5wdXQgaXMgYSBgQmFzZU1lc3NhZ2VgLCBpdFxuICAgICAqIGNyZWF0ZXMgYSBnZW5lcmF0aW9uIHdpdGggdGhlIGlucHV0IGFzIGEgbWVzc2FnZSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICogaW5wdXQgYXMgdGV4dCwgYW5kIHRoZW4gY2FsbHMgYHBhcnNlUmVzdWx0YC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIHRoZSBwYXJzZXIsIHdoaWNoIGNhbiBiZSBhIHN0cmluZyBvciBhIGBCYXNlTWVzc2FnZWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4gdGhpcy5wYXJzZVJlc3VsdChbeyB0ZXh0OiBpbnB1dCB9XSwgb3B0aW9ucz8uY2FsbGJhY2tzKSwgaW5wdXQsIHsgLi4ub3B0aW9ucywgcnVuVHlwZTogXCJwYXJzZXJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyhhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHRoaXMucGFyc2VSZXN1bHQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Jhc2VNZXNzYWdlVG9TdHJpbmcoaW5wdXQpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLCBvcHRpb25zPy5jYWxsYmFja3MpLCBpbnB1dCwgeyAuLi5vcHRpb25zLCBydW5UeXBlOiBcInBhcnNlclwiIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlTExNT3V0cHV0UGFyc2VyID0gQmFzZUxMTU91dHB1dFBhcnNlcjtcbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIG91dHB1dCBvZiBhbiBMTE0gY2FsbC5cbiAqL1xuY2xhc3MgQmFzZU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VMTE1PdXRwdXRQYXJzZXIge1xuICAgIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZ2VuZXJhdGlvbnNbMF0udGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VXaXRoUHJvbXB0KHRleHQsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSh0ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0eXBlIGtleSB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIGNsYXNzIG9mIHBhcnNlclxuICAgICAqL1xuICAgIF90eXBlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdHlwZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlT3V0cHV0UGFyc2VyID0gQmFzZU91dHB1dFBhcnNlcjtcbi8qKlxuICogRXhjZXB0aW9uIHRoYXQgb3V0cHV0IHBhcnNlcnMgc2hvdWxkIHJhaXNlIHRvIHNpZ25pZnkgYSBwYXJzaW5nIGVycm9yLlxuICpcbiAqIFRoaXMgZXhpc3RzIHRvIGRpZmZlcmVudGlhdGUgcGFyc2luZyBlcnJvcnMgZnJvbSBvdGhlciBjb2RlIG9yIGV4ZWN1dGlvbiBlcnJvcnNcbiAqIHRoYXQgYWxzbyBtYXkgYXJpc2UgaW5zaWRlIHRoZSBvdXRwdXQgcGFyc2VyLiBPdXRwdXRQYXJzZXJFeGNlcHRpb25zIHdpbGwgYmVcbiAqIGF2YWlsYWJsZSB0byBjYXRjaCBhbmQgaGFuZGxlIGluIHdheXMgdG8gZml4IHRoZSBwYXJzaW5nIGVycm9yLCB3aGlsZSBvdGhlclxuICogZXJyb3JzIHdpbGwgYmUgcmFpc2VkLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIHRoYXQncyBiZWluZyByZS1yYWlzZWQgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBsbG1PdXRwdXQgLSBTdHJpbmcgbW9kZWwgb3V0cHV0IHdoaWNoIGlzIGVycm9yLWluZy5cbiAqIEBwYXJhbSBvYnNlcnZhdGlvbiAtIFN0cmluZyBleHBsYW5hdGlvbiBvZiBlcnJvciB3aGljaCBjYW4gYmUgcGFzc2VkIHRvIGFcbiAqICAgICBtb2RlbCB0byB0cnkgYW5kIHJlbWVkaWF0ZSB0aGUgaXNzdWUuXG4gKiBAcGFyYW0gc2VuZFRvTExNIC0gV2hldGhlciB0byBzZW5kIHRoZSBvYnNlcnZhdGlvbiBhbmQgbGxtX291dHB1dCBiYWNrIHRvIGFuIEFnZW50XG4gKiAgICAgYWZ0ZXIgYW4gT3V0cHV0UGFyc2VyRXhjZXB0aW9uIGhhcyBiZWVuIHJhaXNlZC4gVGhpcyBnaXZlcyB0aGUgdW5kZXJseWluZ1xuICogICAgIG1vZGVsIGRyaXZpbmcgdGhlIGFnZW50IHRoZSBjb250ZXh0IHRoYXQgdGhlIHByZXZpb3VzIG91dHB1dCB3YXMgaW1wcm9wZXJseVxuICogICAgIHN0cnVjdHVyZWQsIGluIHRoZSBob3BlcyB0aGF0IGl0IHdpbGwgdXBkYXRlIHRoZSBvdXRwdXQgdG8gdGhlIGNvcnJlY3RcbiAqICAgICBmb3JtYXQuXG4gKi9cbmNsYXNzIE91dHB1dFBhcnNlckV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsbG1PdXRwdXQsIG9ic2VydmF0aW9uLCBzZW5kVG9MTE0gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGxtT3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbmRUb0xMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxsbU91dHB1dCA9IGxsbU91dHB1dDtcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbiA9IG9ic2VydmF0aW9uO1xuICAgICAgICB0aGlzLnNlbmRUb0xMTSA9IHNlbmRUb0xMTTtcbiAgICAgICAgaWYgKHNlbmRUb0xMTSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uID09PSB1bmRlZmluZWQgfHwgbGxtT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgJ29ic2VydmF0aW9uJyAmICdsbG1PdXRwdXQnIGFyZSByZXF1aXJlZCBpZiAnc2VuZFRvTGxtJyBpcyB0cnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFkZExhbmdDaGFpbkVycm9yRmllbGRzKSh0aGlzLCBcIk9VVFBVVF9QQVJTSU5HX0ZBSUxVUkVcIik7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRwdXRQYXJzZXJFeGNlcHRpb24gPSBPdXRwdXRQYXJzZXJFeGNlcHRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/json.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseJsonMarkdown = exports.parsePartialJson = exports.JsonOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst json_patch_js_1 = __webpack_require__(/*! ../utils/json_patch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nObject.defineProperty(exports, \"parseJsonMarkdown\", ({ enumerable: true, get: function () { return json_js_1.parseJsonMarkdown; } }));\nObject.defineProperty(exports, \"parsePartialJson\", ({ enumerable: true, get: function () { return json_js_1.parsePartialJson; } }));\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nclass JsonOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0, json_patch_js_1.compare)(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return (0, json_js_1.parseJsonMarkdown)(generations[0].text);\n    }\n    async parse(text) {\n        return (0, json_js_1.parseJsonMarkdown)(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.JsonOutputParser = JsonOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQy9FLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsbUZBQW1CO0FBQzdDLHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL2pzb24uY2pzPzU2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlSnNvbk1hcmtkb3duID0gZXhwb3J0cy5wYXJzZVBhcnRpYWxKc29uID0gZXhwb3J0cy5Kc29uT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgdHJhbnNmb3JtX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0uY2pzXCIpO1xuY29uc3QganNvbl9wYXRjaF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2pzb25fcGF0Y2guY2pzXCIpO1xuY29uc3QganNvbl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2pzb24uY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VKc29uTWFya2Rvd25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fanNfMS5wYXJzZUpzb25NYXJrZG93bjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlUGFydGlhbEpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fanNfMS5wYXJzZVBhcnRpYWxKc29uOyB9IH0pO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGFuIExMTSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKi9cbmNsYXNzIEpzb25PdXRwdXRQYXJzZXIgZXh0ZW5kcyB0cmFuc2Zvcm1fanNfMS5CYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSnNvbk91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBfZGlmZihwcmV2LCBuZXh0KSB7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBbeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IFwiXCIsIHZhbHVlOiBuZXh0IH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwganNvbl9wYXRjaF9qc18xLmNvbXBhcmUpKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBhY3R1YWxseSByZXR1cm4gUGFydGlhbDxUPiwgYnV0IHRoZXJlJ3Mgbm8gd2F5XG4gICAgLy8gdG8gc3BlY2lmeSBlbWl0dGVkIGNodW5rcyBhcyBpbnN0YW5jZXMgc2VwYXJhdGUgZnJvbSB0aGUgbWFpbiBvdXRwdXQgdHlwZS5cbiAgICBhc3luYyBwYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBqc29uX2pzXzEucGFyc2VKc29uTWFya2Rvd24pKGdlbmVyYXRpb25zWzBdLnRleHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiAoMCwganNvbl9qc18xLnBhcnNlSnNvbk1hcmtkb3duKSh0ZXh0LCBKU09OLnBhcnNlKTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkpzb25PdXRwdXRQYXJzZXIgPSBKc29uT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./json_output_tools_parsers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNElBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy9pbmRleC5janM/YmFiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonOutputKeyToolsParser = exports.JsonOutputToolsParser = exports.makeInvalidToolCall = exports.convertLangChainToolCallToOpenAI = exports.parseToolCall = void 0;\nconst base_js_1 = __webpack_require__(/*! ../base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\");\nconst transform_js_1 = __webpack_require__(/*! ../transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nfunction parseToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, options) {\n    if (rawToolCall.function === undefined) {\n        return undefined;\n    }\n    let functionArgs;\n    if (options?.partial) {\n        try {\n            functionArgs = (0, json_js_1.parsePartialJson)(rawToolCall.function.arguments ?? \"{}\");\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    else {\n        try {\n            functionArgs = JSON.parse(rawToolCall.function.arguments);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException([\n                `Function \"${rawToolCall.function.name}\" arguments:`,\n                ``,\n                rawToolCall.function.arguments,\n                ``,\n                `are not valid JSON.`,\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n    const parsedToolCall = {\n        name: rawToolCall.function.name,\n        args: functionArgs,\n        type: \"tool_call\",\n    };\n    if (options?.returnId) {\n        parsedToolCall.id = rawToolCall.id;\n    }\n    return parsedToolCall;\n}\nexports.parseToolCall = parseToolCall;\nfunction convertLangChainToolCallToOpenAI(toolCall) {\n    if (toolCall.id === undefined) {\n        throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n    }\n    return {\n        id: toolCall.id,\n        type: \"function\",\n        function: {\n            name: toolCall.name,\n            arguments: JSON.stringify(toolCall.args),\n        },\n    };\n}\nexports.convertLangChainToolCallToOpenAI = convertLangChainToolCallToOpenAI;\nfunction makeInvalidToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, errorMsg) {\n    return {\n        name: rawToolCall.function?.name,\n        args: rawToolCall.function?.arguments,\n        id: rawToolCall.id,\n        error: errorMsg,\n        type: \"invalid_tool_call\",\n    };\n}\nexports.makeInvalidToolCall = makeInvalidToolCall;\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nclass JsonOutputToolsParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    _diff() {\n        throw new Error(\"Not supported.\");\n    }\n    async parse() {\n        throw new Error(\"Not implemented.\");\n    }\n    async parseResult(generations) {\n        const result = await this.parsePartialResult(generations, false);\n        return result;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parsePartialResult(generations, partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const message = generations[0].message;\n        let toolCalls;\n        if ((0, ai_js_1.isAIMessage)(message) && message.tool_calls?.length) {\n            toolCalls = message.tool_calls.map((toolCall) => {\n                const { id, ...rest } = toolCall;\n                if (!this.returnId) {\n                    return rest;\n                }\n                return {\n                    id,\n                    ...rest,\n                };\n            });\n        }\n        else if (message.additional_kwargs.tool_calls !== undefined) {\n            const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n            toolCalls = rawToolCalls.map((rawToolCall) => {\n                return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n            });\n        }\n        if (!toolCalls) {\n            return [];\n        }\n        const parsedToolCalls = [];\n        for (const toolCall of toolCalls) {\n            if (toolCall !== undefined) {\n                const backwardsCompatibleToolCall = {\n                    type: toolCall.name,\n                    args: toolCall.args,\n                    id: toolCall.id,\n                };\n                parsedToolCalls.push(backwardsCompatibleToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\nexports.JsonOutputToolsParser = JsonOutputToolsParser;\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nclass JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"zodSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.zodSchema = params.zodSchema;\n    }\n    async _validateResult(result) {\n        if (this.zodSchema === undefined) {\n            return result;\n        }\n        const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n        if (zodParsedResult.success) {\n            return zodParsedResult.data;\n        }\n        else {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parsePartialResult(generations) {\n        const results = await super.parsePartialResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return returnedValues[0];\n        }\n        return returnedValues;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await super.parsePartialResult(generations, false);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return this._validateResult(returnedValues[0]);\n        }\n        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n        return toolCallResults;\n    }\n}\nexports.JsonOutputKeyToolsParser = JsonOutputKeyToolsParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLDJCQUEyQixHQUFHLHdDQUF3QyxHQUFHLHFCQUFxQjtBQUNqSyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0NBQWtDO0FBQ3RGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsZ0NBQWdDLFlBQVksNkNBQTZDO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzPzIwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25PdXRwdXRLZXlUb29sc1BhcnNlciA9IGV4cG9ydHMuSnNvbk91dHB1dFRvb2xzUGFyc2VyID0gZXhwb3J0cy5tYWtlSW52YWxpZFRvb2xDYWxsID0gZXhwb3J0cy5jb252ZXJ0TGFuZ0NoYWluVG9vbENhbGxUb09wZW5BSSA9IGV4cG9ydHMucGFyc2VUb29sQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGpzb25fanNfMSA9IHJlcXVpcmUoXCIuLi9qc29uLmNqc1wiKTtcbmNvbnN0IHRyYW5zZm9ybV9qc18xID0gcmVxdWlyZShcIi4uL3RyYW5zZm9ybS5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4uLy4uL21lc3NhZ2VzL2FpLmNqc1wiKTtcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmF3VG9vbENhbGwsIG9wdGlvbnMpIHtcbiAgICBpZiAocmF3VG9vbENhbGwuZnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25BcmdzO1xuICAgIGlmIChvcHRpb25zPy5wYXJ0aWFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jdGlvbkFyZ3MgPSAoMCwganNvbl9qc18xLnBhcnNlUGFydGlhbEpzb24pKHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA/PyBcInt9XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuY3Rpb25BcmdzID0gSlNPTi5wYXJzZShyYXdUb29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oW1xuICAgICAgICAgICAgICAgIGBGdW5jdGlvbiBcIiR7cmF3VG9vbENhbGwuZnVuY3Rpb24ubmFtZX1cIiBhcmd1bWVudHM6YCxcbiAgICAgICAgICAgICAgICBgYCxcbiAgICAgICAgICAgICAgICByYXdUb29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgYGAsXG4gICAgICAgICAgICAgICAgYGFyZSBub3QgdmFsaWQgSlNPTi5gLFxuICAgICAgICAgICAgICAgIGBFcnJvcjogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVG9vbENhbGwgPSB7XG4gICAgICAgIG5hbWU6IHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgIGFyZ3M6IGZ1bmN0aW9uQXJncyxcbiAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICB9O1xuICAgIGlmIChvcHRpb25zPy5yZXR1cm5JZCkge1xuICAgICAgICBwYXJzZWRUb29sQ2FsbC5pZCA9IHJhd1Rvb2xDYWxsLmlkO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkVG9vbENhbGw7XG59XG5leHBvcnRzLnBhcnNlVG9vbENhbGwgPSBwYXJzZVRvb2xDYWxsO1xuZnVuY3Rpb24gY29udmVydExhbmdDaGFpblRvb2xDYWxsVG9PcGVuQUkodG9vbENhbGwpIHtcbiAgICBpZiAodG9vbENhbGwuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbCBPcGVuQUkgdG9vbCBjYWxscyBtdXN0IGhhdmUgYW4gXCJpZFwiIGZpZWxkLmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsLm5hbWUsXG4gICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpLFxuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmNvbnZlcnRMYW5nQ2hhaW5Ub29sQ2FsbFRvT3BlbkFJID0gY29udmVydExhbmdDaGFpblRvb2xDYWxsVG9PcGVuQUk7XG5mdW5jdGlvbiBtYWtlSW52YWxpZFRvb2xDYWxsKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnJhd1Rvb2xDYWxsLCBlcnJvck1zZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHJhd1Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lLFxuICAgICAgICBhcmdzOiByYXdUb29sQ2FsbC5mdW5jdGlvbj8uYXJndW1lbnRzLFxuICAgICAgICBpZDogcmF3VG9vbENhbGwuaWQsXG4gICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgdHlwZTogXCJpbnZhbGlkX3Rvb2xfY2FsbFwiLFxuICAgIH07XG59XG5leHBvcnRzLm1ha2VJbnZhbGlkVG9vbENhbGwgPSBtYWtlSW52YWxpZFRvb2xDYWxsO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGEgdG9vbC1jYWxsaW5nIExMTSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKi9cbmNsYXNzIEpzb25PdXRwdXRUb29sc1BhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSnNvbk91dHB1dFRvb2xzUGFyc2VyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJvcGVuYWlfdG9vbHNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXR1cm5JZCA9IGZpZWxkcz8ucmV0dXJuSWQgPz8gdGhpcy5yZXR1cm5JZDtcbiAgICB9XG4gICAgX2RpZmYoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VSZXN1bHQoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBvdXRwdXQgYW5kIHJldHVybnMgYSBKU09OIG9iamVjdC4gSWYgYGFyZ3NPbmx5YCBpcyB0cnVlLFxuICAgICAqIG9ubHkgdGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gY2FsbCBhcmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGdlbmVyYXRpb25zIFRoZSBvdXRwdXQgb2YgdGhlIExMTSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9yIGl0cyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zLCBwYXJ0aWFsID0gdHJ1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW5lcmF0aW9uc1swXS5tZXNzYWdlO1xuICAgICAgICBsZXQgdG9vbENhbGxzO1xuICAgICAgICBpZiAoKDAsIGFpX2pzXzEuaXNBSU1lc3NhZ2UpKG1lc3NhZ2UpICYmIG1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHMubWFwKCh0b29sQ2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIC4uLnJlc3QgfSA9IHRvb2xDYWxsO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXR1cm5JZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MudG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MudG9vbF9jYWxscykpO1xuICAgICAgICAgICAgdG9vbENhbGxzID0gcmF3VG9vbENhbGxzLm1hcCgocmF3VG9vbENhbGwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb29sQ2FsbChyYXdUb29sQ2FsbCwgeyByZXR1cm5JZDogdGhpcy5yZXR1cm5JZCwgcGFydGlhbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9vbENhbGxzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgICAgICAgICBpZiAodG9vbENhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t3YXJkc0NvbXBhdGlibGVUb29sQ2FsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyc2VkVG9vbENhbGxzLnB1c2goYmFja3dhcmRzQ29tcGF0aWJsZVRvb2xDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVG9vbENhbGxzO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvbk91dHB1dFRvb2xzUGFyc2VyID0gSnNvbk91dHB1dFRvb2xzUGFyc2VyO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGEgdG9vbC1jYWxsaW5nIExMTSBpbnRvIGEgSlNPTiBvYmplY3QgaWYgeW91IGFyZVxuICogZXhwZWN0aW5nIG9ubHkgYSBzaW5nbGUgdG9vbCB0byBiZSBjYWxsZWQuXG4gKi9cbmNsYXNzIEpzb25PdXRwdXRLZXlUb29sc1BhcnNlciBleHRlbmRzIEpzb25PdXRwdXRUb29sc1BhcnNlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25PdXRwdXRLZXlUb29sc1BhcnNlclwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcIm9wZW5haV90b29sc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0b29sIGNhbGxzIHRvIHJldHVybi4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogV2hldGhlciB0byByZXR1cm4gb25seSB0aGUgZmlyc3QgdG9vbCBjYWxsLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5TaW5nbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ6b2RTY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXlOYW1lID0gcGFyYW1zLmtleU5hbWU7XG4gICAgICAgIHRoaXMucmV0dXJuU2luZ2xlID0gcGFyYW1zLnJldHVyblNpbmdsZSA/PyB0aGlzLnJldHVyblNpbmdsZTtcbiAgICAgICAgdGhpcy56b2RTY2hlbWEgPSBwYXJhbXMuem9kU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRhdGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnpvZFNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHpvZFBhcnNlZFJlc3VsdCA9IGF3YWl0IHRoaXMuem9kU2NoZW1hLnNhZmVQYXJzZUFzeW5jKHJlc3VsdCk7XG4gICAgICAgIGlmICh6b2RQYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHpvZFBhcnNlZFJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oYEZhaWxlZCB0byBwYXJzZS4gVGV4dDogXCIke0pTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMil9XCIuIEVycm9yOiAke0pTT04uc3RyaW5naWZ5KHpvZFBhcnNlZFJlc3VsdC5lcnJvci5lcnJvcnMpfWAsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5wYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ1Jlc3VsdHMgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQudHlwZSA9PT0gdGhpcy5rZXlOYW1lKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHJldHVybmVkVmFsdWVzID0gbWF0Y2hpbmdSZXN1bHRzO1xuICAgICAgICBpZiAoIW1hdGNoaW5nUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJldHVybklkKSB7XG4gICAgICAgICAgICByZXR1cm5lZFZhbHVlcyA9IG1hdGNoaW5nUmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHVyblNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkVmFsdWVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5lZFZhbHVlcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBwYXJzZVJlc3VsdChnZW5lcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIucGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKChyZXN1bHQpID0+IHJlc3VsdC50eXBlID09PSB0aGlzLmtleU5hbWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgcmV0dXJuZWRWYWx1ZXMgPSBtYXRjaGluZ1Jlc3VsdHM7XG4gICAgICAgIGlmICghbWF0Y2hpbmdSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmV0dXJuSWQpIHtcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWVzID0gbWF0Y2hpbmdSZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0dXJuU2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVSZXN1bHQocmV0dXJuZWRWYWx1ZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJldHVybmVkVmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMuX3ZhbGlkYXRlUmVzdWx0KHZhbHVlKSkpO1xuICAgICAgICByZXR1cm4gdG9vbENhbGxSZXN1bHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyID0gSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/transform.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseCumulativeTransformOutputParser = exports.BaseTransformOutputParser = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../messages/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../utils/@cfworker/json-schema/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/index.cjs\");\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nclass BaseTransformOutputParser extends base_js_1.BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: this._baseMessageToString(chunk),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\nexports.BaseTransformOutputParser = BaseTransformOutputParser;\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nclass BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if ((0, base_js_2.isBaseMessageChunk)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if ((0, base_js_2.isBaseMessage)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: (0, utils_js_1.convertToChunk)(chunk),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new outputs_js_1.GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !(0, index_js_1.deepCompareStrict)(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.BaseCumulativeTransformOutputParser = BaseCumulativeTransformOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsR0FBRyxpQ0FBaUM7QUFDL0Usa0JBQWtCLG1CQUFPLENBQUMscUZBQVk7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMseUZBQXNCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsaUlBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmNqcz82ZDRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IGV4cG9ydHMuQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18yID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2Jhc2UuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy91dGlscy5janNcIik7XG5jb25zdCBvdXRwdXRzX2pzXzEgPSByZXF1aXJlKFwiLi4vb3V0cHV0cy5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9pbmRleC5janNcIik7XG4vKipcbiAqIENsYXNzIHRvIHBhcnNlIHRoZSBvdXRwdXQgb2YgYW4gTExNIGNhbGwgdGhhdCBhbHNvIGFsbG93cyBzdHJlYW1pbmcgaW5wdXRzLlxuICovXG5jbGFzcyBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VPdXRwdXRQYXJzZXIge1xuICAgIGFzeW5jICpfdHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBhcnNlUmVzdWx0KFt7IHRleHQ6IGNodW5rIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VSZXN1bHQoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Jhc2VNZXNzYWdlVG9TdHJpbmcoY2h1bmspLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvciBvZiBpbnB1dCBpbnRvIGFuIGFzeW5jaHJvbm91c1xuICAgICAqIGdlbmVyYXRvciBvZiBwYXJzZWQgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dEdlbmVyYXRvciBBbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIGlucHV0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgQW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvciBvZiBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jICp0cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoaW5wdXRHZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgcnVuVHlwZTogXCJwYXJzZXJcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyID0gQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlcjtcbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBvdXRwdXQgcGFyc2VycyB0aGF0IGNhbiBoYW5kbGUgc3RyZWFtaW5nIGlucHV0LiBJdFxuICogZXh0ZW5kcyB0aGUgYEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXJgIGNsYXNzIGFuZCBwcm92aWRlcyBhIG1ldGhvZCBmb3JcbiAqIGNvbnZlcnRpbmcgcGFyc2VkIG91dHB1dHMgaW50byBhIGRpZmYgZm9ybWF0LlxuICovXG5jbGFzcyBCYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaWZmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaWZmID0gZmllbGRzPy5kaWZmID8/IHRoaXMuZGlmZjtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IHByZXZQYXJzZWQ7XG4gICAgICAgIGxldCBhY2NHZW47XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGFuZGxlIG5vbi1zdHJpbmcgb3V0cHV0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaHVua0dlbjtcbiAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZU1lc3NhZ2VDaHVuaykoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBtZXNzYWdlIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IG91dHB1dHNfanNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZU1lc3NhZ2UpKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGFuZGxlIG5vbi1zdHJpbmcgbWVzc2FnZSBvdXRwdXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVua0dlbiA9IG5ldyBvdXRwdXRzX2pzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICgwLCB1dGlsc19qc18xLmNvbnZlcnRUb0NodW5rKShjaHVuayksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua0dlbiA9IG5ldyBvdXRwdXRzX2pzXzEuR2VuZXJhdGlvbkNodW5rKHsgdGV4dDogY2h1bmsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWNjR2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2NHZW4gPSBjaHVua0dlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY0dlbiA9IGFjY0dlbi5jb25jYXQoY2h1bmtHZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gYXdhaXQgdGhpcy5wYXJzZVBhcnRpYWxSZXN1bHQoW2FjY0dlbl0pO1xuICAgICAgICAgICAgaWYgKHBhcnNlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcGFyc2VkICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgISgwLCBpbmRleF9qc18xLmRlZXBDb21wYXJlU3RyaWN0KShwYXJzZWQsIHByZXZQYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlmZikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9kaWZmKHByZXZQYXJzZWQsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyID0gQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/outputs.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/outputs.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGenerationChunk = exports.GenerationChunk = exports.RUN_KEY = void 0;\nexports.RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nclass GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nexports.GenerationChunk = GenerationChunk;\nclass ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\nexports.ChatGenerationChunk = ChatGenerationChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZTtBQUN2RSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRzLmNqcz81NjFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0R2VuZXJhdGlvbkNodW5rID0gZXhwb3J0cy5HZW5lcmF0aW9uQ2h1bmsgPSBleHBvcnRzLlJVTl9LRVkgPSB2b2lkIDA7XG5leHBvcnRzLlJVTl9LRVkgPSBcIl9fcnVuXCI7XG4vKipcbiAqIENodW5rIG9mIGEgc2luZ2xlIGdlbmVyYXRpb24uIFVzZWQgZm9yIHN0cmVhbWluZy5cbiAqL1xuY2xhc3MgR2VuZXJhdGlvbkNodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0aW9uSW5mb1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRleHQgPSBmaWVsZHMudGV4dDtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uSW5mbyA9IGZpZWxkcy5nZW5lcmF0aW9uSW5mbztcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyYXRpb25DaHVuayA9IEdlbmVyYXRpb25DaHVuaztcbmNsYXNzIENoYXRHZW5lcmF0aW9uQ2h1bmsgZXh0ZW5kcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGZpZWxkcy5tZXNzYWdlO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLmNvbmNhdChjaHVuay5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0R2VuZXJhdGlvbkNodW5rID0gQ2hhdEdlbmVyYXRpb25DaHVuaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompt_values.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImagePromptValue = exports.ChatPromptValue = exports.StringPromptValue = exports.BasePromptValue = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./messages/human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nclass BasePromptValue extends serializable_js_1.Serializable {\n}\nexports.BasePromptValue = BasePromptValue;\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nclass StringPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"StringPromptValue\";\n    }\n    constructor(value) {\n        super({ value });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    toChatMessages() {\n        return [new human_js_1.HumanMessage(this.value)];\n    }\n}\nexports.StringPromptValue = StringPromptValue;\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nclass ChatPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ChatPromptValue\";\n    }\n    constructor(fields) {\n        if (Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { messages: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.messages = fields.messages;\n    }\n    toString() {\n        return (0, utils_js_1.getBufferString)(this.messages);\n    }\n    toChatMessages() {\n        return this.messages;\n    }\n}\nexports.ChatPromptValue = ChatPromptValue;\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nclass ImagePromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ImagePromptValue\";\n    }\n    constructor(fields) {\n        if (!(\"imageUrl\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { imageUrl: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"imageUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.imageUrl = fields.imageUrl;\n    }\n    toString() {\n        return this.imageUrl.url;\n    }\n    toChatMessages() {\n        return [\n            new human_js_1.HumanMessage({\n                content: [\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            detail: this.imageUrl.detail,\n                            url: this.imageUrl.url,\n                        },\n                    },\n                ],\n            }),\n        ];\n    }\n}\nexports.ImagePromptValue = ImagePromptValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ3hHLDBCQUEwQixtQkFBTyxDQUFDLGdHQUF5QjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Byb21wdF92YWx1ZXMuY2pzPzU2N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkltYWdlUHJvbXB0VmFsdWUgPSBleHBvcnRzLkNoYXRQcm9tcHRWYWx1ZSA9IGV4cG9ydHMuU3RyaW5nUHJvbXB0VmFsdWUgPSBleHBvcnRzLkJhc2VQcm9tcHRWYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IHNlcmlhbGl6YWJsZV9qc18xID0gcmVxdWlyZShcIi4vbG9hZC9zZXJpYWxpemFibGUuY2pzXCIpO1xuY29uc3QgaHVtYW5fanNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL2h1bWFuLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlcy91dGlscy5janNcIik7XG4vKipcbiAqIEJhc2UgUHJvbXB0VmFsdWUgY2xhc3MuIEFsbCBwcm9tcHQgdmFsdWVzIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQmFzZVByb21wdFZhbHVlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbn1cbmV4cG9ydHMuQmFzZVByb21wdFZhbHVlID0gQmFzZVByb21wdFZhbHVlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHJvbXB0IHZhbHVlIGFzIGEgc3RyaW5nLiBJdCBleHRlbmRzIHRoZSBCYXNlUHJvbXB0VmFsdWVcbiAqIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIHRvU3RyaW5nIGFuZCB0b0NoYXRNZXNzYWdlcyBtZXRob2RzLlxuICovXG5jbGFzcyBTdHJpbmdQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN0cmluZ1Byb21wdFZhbHVlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHsgdmFsdWUgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0NoYXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UodGhpcy52YWx1ZSldO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nUHJvbXB0VmFsdWUgPSBTdHJpbmdQcm9tcHRWYWx1ZTtcbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2hhdCBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAqL1xuY2xhc3MgQ2hhdFByb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdFByb21wdFZhbHVlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgbWVzc2FnZXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBmaWVsZHMubWVzc2FnZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuZ2V0QnVmZmVyU3RyaW5nKSh0aGlzLm1lc3NhZ2VzKTtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdFByb21wdFZhbHVlID0gQ2hhdFByb21wdFZhbHVlO1xuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UgcHJvbXB0IHZhbHVlLiBJdCBleHRlbmRzIHRoZVxuICogQmFzZVByb21wdFZhbHVlIGFuZCBpbmNsdWRlcyBhbiBJbWFnZVVSTCBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgSW1hZ2VQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkltYWdlUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICghKFwiaW1hZ2VVcmxcIiBpbiBmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgaW1hZ2VVcmw6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImltYWdlVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSBmaWVsZHMuaW1hZ2VVcmw7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVVybC51cmw7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHRoaXMuaW1hZ2VVcmwuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVVybC51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnRzLkltYWdlUHJvbXB0VmFsdWUgPSBJbWFnZVByb21wdFZhbHVlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertRunnableToTool = exports.RunnableToolLike = exports.RunnablePick = exports.RunnableAssign = exports._coerceToRunnable = exports.RunnableWithFallbacks = exports.RunnableParallel = exports.RunnableLambda = exports.RunnableTraceable = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = exports._coerceToDict = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst event_stream_js_1 = __webpack_require__(/*! ../tracers/event_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\");\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ../utils/signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst root_listener_js_1 = __webpack_require__(/*! ../tracers/root_listener.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst graph_js_1 = __webpack_require__(/*! ./graph.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\");\nconst wrappers_js_1 = __webpack_require__(/*! ./wrappers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\");\nconst iter_js_1 = __webpack_require__(/*! ./iter.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\");\nconst utils_js_2 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nexports._coerceToDict = _coerceToDict;\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends serializable_js_1.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(config_js_1.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0, config_js_1.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new async_caller_js_1.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0, config_js_1.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0, config_js_1.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await (0, signal_js_1.raceWithSignal)(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = (0, stream_js_1.concat)(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0, stream_js_1.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(event_stream_js_1.isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(log_stream_js_1.isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new graph_js_1.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: zod_1.z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: zod_1.z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = (0, stream_js_1.concat)(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0, config_js_1.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new log_stream_js_1.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return (0, wrappers_js_1.convertToHttpEventStream)(stream);\n        }\n        else {\n            return stream_js_1.IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new event_stream_js_1.EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        const runId = config.runId ?? (0, uuid_1.v4)();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await outerThis.stream(input, config);\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new utils_js_1._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = log_stream_js_1.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0, utils_js_1.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\nexports.Runnable = Runnable;\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0, config_js_1.mergeConfigs)(this.config, ...options);\n        return (0, config_js_1.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0, config_js_1.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig((0, config_js_1.ensureConfig)(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\nexports.RunnableBinding = RunnableBinding;\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\nexports.RunnableEach = RunnableEach;\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return (0, p_retry_1.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await (0, p_retry_1.default)(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\nexports.RunnableRetry = RunnableRetry;\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return (0, config_js_1.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await (0, signal_js_1.raceWithSignal)(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0, config_js_1.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0, config_js_1.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new graph_js_1.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\nexports.RunnableSequence = RunnableSequence;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await (0, signal_js_1.raceWithSignal)(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0, stream_js_1.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0, config_js_1.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableMap = RunnableMap;\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nclass RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!(0, traceable_1.isTraceableFunction)(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const promise = this.func((0, config_js_1.patchConfig)(config, { callbacks }), input);\n        return (0, signal_js_1.raceWithSignal)(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if ((0, iter_js_1.isAsyncIterable)(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if ((0, iter_js_1.isIterator)(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nexports.RunnableTraceable = RunnableTraceable;\nfunction assertNonTraceableFunction(func) {\n    if ((0, traceable_1.isTraceableFunction)(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if ((0, traceable_1.isTraceableFunction)(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0, iter_js_1.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0, iter_js_1.isIterableIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = (0, stream_js_1.concat)(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = (0, config_js_1.patchConfig)(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isAsyncIterable)(output)) {\n            for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isIterableIterator)(output)) {\n            for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableLambda = RunnableLambda;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = sequence.invoke(25);\n *\n * // { years_to_fifty: 25, years_to_hundred: 75 }\n * ```\n */\nclass RunnableParallel extends RunnableMap {\n}\nexports.RunnableParallel = RunnableParallel;\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            try {\n                const output = await runnable.invoke(input, (0, config_js_1.patchConfig)(otherConfigFields, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async *_streamIterator(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                stream = await runnable.stream(input, childConfig);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output = output === undefined ? output : (0, stream_js_1.concat)(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => (0, config_js_1.getCallbackManagerForConfig)(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0, config_js_1.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nexports.RunnableWithFallbacks = RunnableWithFallbacks;\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\nexports._coerceToRunnable = _coerceToRunnable;\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0, stream_js_1.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0, config_js_1.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableAssign = RunnableAssign;\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnablePick = RunnablePick;\nclass RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if ((0, utils_js_2._isToolCall)(input)) {\n                    try {\n                        toolInput = await this.schema.parseAsync(input.args);\n                    }\n                    catch (e) {\n                        throw new utils_js_2.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\nexports.RunnableToolLike = RunnableToolLike;\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {z.ZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<z.ZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nfunction convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? fields.schema?.description;\n    if (fields.schema.constructor === zod_1.z.ZodString) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: zod_1.z\n                .object({\n                input: zod_1.z.string(),\n            })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\nexports.convertRunnableToTool = convertRunnableToTool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCO0FBQ3paLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxlQUFlLG1CQUFPLENBQUMsOERBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWdDO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLG1HQUEyQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDL0QsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQWM7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLHlHQUE4QjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsZ0JBQWdCLGNBQWMsUUFBUTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0xBQXNMLFdBQVc7QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDLDRDQUE0QztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsWUFBWSw0QkFBNEIsY0FBYztBQUNwSjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsR0FBRyxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixZQUFZLDRCQUE0QixXQUFXO0FBQzdJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsaUJBQWlCO0FBQzFFLHdDQUF3QyxnQkFBZ0IsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsbUNBQW1DO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkUsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRCxzREFBc0Qsc0NBQXNDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBLHlFQUF5RTtBQUN6RSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBLG9HQUFvRyxNQUFNO0FBQzFHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxrQkFBa0I7QUFDbEgsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBLGlIQUFpSCxNQUFNO0FBQ3ZILHlFQUF5RSw0QkFBNEI7QUFDckcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0Esb0dBQW9HLE1BQU07QUFDMUcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxNQUFNO0FBQ3BFLDJCQUEyQjtBQUMzQjtBQUNBLG1FQUFtRSxNQUFNO0FBQ3pFLDJCQUEyQjtBQUMzQjtBQUNBLElBQUk7QUFDSiwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxJQUFJO0FBQ25FLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELElBQUk7QUFDL0QsYUFBYTtBQUNiLHdEQUF3RCxrQkFBa0I7QUFDMUUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EseUJBQXlCLFdBQVcsV0FBVztBQUMvQztBQUNBLDhCQUE4QixlQUFlLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxtQ0FBbUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsbUJBQW1CLEtBQUssY0FBYztBQUNwRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWMsS0FBSyxtQkFBbUI7QUFDdEUsY0FBYyxvQkFBb0IsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0EsUUFBUSw0Q0FBNEMsU0FBUyxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxtQ0FBbUM7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxZQUFZLFlBQVksZUFBZTtBQUNuRTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsa0RBQWtEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuY2pzPzQzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRSdW5uYWJsZVRvVG9vbCA9IGV4cG9ydHMuUnVubmFibGVUb29sTGlrZSA9IGV4cG9ydHMuUnVubmFibGVQaWNrID0gZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IGV4cG9ydHMuX2NvZXJjZVRvUnVubmFibGUgPSBleHBvcnRzLlJ1bm5hYmxlV2l0aEZhbGxiYWNrcyA9IGV4cG9ydHMuUnVubmFibGVQYXJhbGxlbCA9IGV4cG9ydHMuUnVubmFibGVMYW1iZGEgPSBleHBvcnRzLlJ1bm5hYmxlVHJhY2VhYmxlID0gZXhwb3J0cy5SdW5uYWJsZU1hcCA9IGV4cG9ydHMuUnVubmFibGVTZXF1ZW5jZSA9IGV4cG9ydHMuUnVubmFibGVSZXRyeSA9IGV4cG9ydHMuUnVubmFibGVFYWNoID0gZXhwb3J0cy5SdW5uYWJsZUJpbmRpbmcgPSBleHBvcnRzLlJ1bm5hYmxlID0gZXhwb3J0cy5fY29lcmNlVG9EaWN0ID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgcF9yZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwLXJldHJ5XCIpKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdHJhY2VhYmxlXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCIpO1xuY29uc3QgbG9nX3N0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvbG9nX3N0cmVhbS5janNcIik7XG5jb25zdCBldmVudF9zdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2V2ZW50X3N0cmVhbS5janNcIik7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3Qgc2lnbmFsX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc2lnbmFsLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5janNcIik7XG5jb25zdCByb290X2xpc3RlbmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3QgZ3JhcGhfanNfMSA9IHJlcXVpcmUoXCIuL2dyYXBoLmNqc1wiKTtcbmNvbnN0IHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5janNcIik7XG5jb25zdCBpdGVyX2pzXzEgPSByZXF1aXJlKFwiLi9pdGVyLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzIgPSByZXF1aXJlKFwiLi4vdG9vbHMvdXRpbHMuY2pzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG5leHBvcnRzLl9jb2VyY2VUb0RpY3QgPSBfY29lcmNlVG9EaWN0O1xuLyoqXG4gKiBBIFJ1bm5hYmxlIGlzIGEgZ2VuZXJpYyB1bml0IG9mIHdvcmsgdGhhdCBjYW4gYmUgaW52b2tlZCwgYmF0Y2hlZCwgc3RyZWFtZWQsIGFuZC9vclxuICogdHJhbnNmb3JtZWQuXG4gKi9cbmNsYXNzIFJ1bm5hYmxlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmFtZShzdWZmaXgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLm5hbWUgPz8gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPz8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4gc3VmZml4ID8gYCR7bmFtZX0ke3N1ZmZpeH1gIDogbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBhcmd1bWVudHMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBrd2FyZ3NcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJpbmRpbmcgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIGFwcGx5IHRoZSBib3VuZCBhcmdzLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoeyBib3VuZDogdGhpcywga3dhcmdzLCBjb25maWc6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgUnVubmFibGUgdGhhdCBtYXBzIGEgbGlzdCBvZiBpbnB1dHMgdG8gYSBsaXN0IG9mIG91dHB1dHMsXG4gICAgICogYnkgY2FsbGluZyBpbnZva2UoKSB3aXRoIGVhY2ggaW5wdXQuXG4gICAgICovXG4gICAgbWFwKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHsgYm91bmQ6IHRoaXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCByZXRyeSBsb2dpYyB0byBhbiBleGlzdGluZyBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVSZXRyeSB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgcmV0cnkgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBrd2FyZ3M6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIG1heEF0dGVtcHROdW1iZXI6IGZpZWxkcz8uc3RvcEFmdGVyQXR0ZW1wdCxcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgY29uZmlnIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE5ldyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gYXR0YWNoIHRvIHRoZSBuZXcgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHdpdGggYSBjb25maWcgbWF0Y2hpbmcgd2hhdCdzIHBhc3NlZC5cbiAgICAgKi9cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBmcm9tIHRoZSBjdXJyZW50IG9uZSB0aGF0IHdpbGwgdHJ5IGludm9raW5nXG4gICAgICogb3RoZXIgcGFzc2VkIGZhbGxiYWNrIHJ1bm5hYmxlcyBpZiB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqIEBwYXJhbSBmaWVsZHMuZmFsbGJhY2tzIE90aGVyIHJ1bm5hYmxlcyB0byBjYWxsIGlmIHRoZSBydW5uYWJsZSBlcnJvcnMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzLlxuICAgICAqL1xuICAgIHdpdGhGYWxsYmFja3MoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcyA6IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgcnVubmFibGU6IHRoaXMsXG4gICAgICAgICAgICBmYWxsYmFja3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucywgbGVuZ3RoID0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBpbnB1dHMsIGJ1dCBnb3QgJHtvcHRpb25zLmxlbmd0aH0gb3B0aW9ucyBmb3IgJHtsZW5ndGh9IGlucHV0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXAoY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBydW5JZCB3aWxsIGJlIHVzZWQgb25seSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJhdGNoLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNlcXVlbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmlsdGVyKChba2V5XSkgPT4ga2V5ICE9PSBcInJ1bklkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShpID09PSAwID8gb3B0aW9ucyA6IHN1YnNlcXVlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBjb25maWdMaXN0WzBdPy5tYXhDb25jdXJyZW5jeSA/PyBiYXRjaE9wdGlvbnM/Lm1heENvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBjYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyX2pzXzEuQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXRjaENhbGxzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGkpID0+IGNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQsIGNvbmZpZ0xpc3RbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGJhdGNoQ2FsbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0cmVhbWluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHN1cHBvcnQgc3RyZWFtaW5nIG91dHB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGluIGNodW5rcy5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtIHRoYXQgaXMgYWxzbyBhbiBpdGVyYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnVmZmVyIHRoZSBmaXJzdCBzdHJlYW1lZCBjaHVuayB0byBhbGxvdyBmb3IgaW5pdGlhbCBlcnJvcnNcbiAgICAgICAgLy8gdG8gc3VyZmFjZSBpbW1lZGlhdGVseS5cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgc3RyZWFtX2pzXzEuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgcnVubmFibGVDb25maWc7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydW5uYWJsZUNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG9wdGlvbnMuY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBvcHRpb25zLnJ1bk5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcHRpb25zLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogb3B0aW9ucy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogb3B0aW9ucy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBydW5JZDogb3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50YWdzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5ydW5OYW1lO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY29uZmlndXJhYmxlO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucmVjdXJzaW9uTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bklkO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMudGltZW91dDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyBfY2FsbFdpdGhDb25maWcoZnVuYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIGNvbmZpZz8ucnVuVHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5jYWxsKHRoaXMsIGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpO1xuICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBoYW5kbGVzIGJhdGNoaW5nIGFuZCBjb25maWd1cmF0aW9uIGZvciBhIHJ1bm5hYmxlXG4gICAgICogSXQgdGFrZXMgYSBmdW5jdGlvbiwgaW5wdXQgdmFsdWVzLCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiwgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaW5wdXQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfYmF0Y2hXaXRoQ29uZmlnKGZ1bmMsIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zTGlzdC5tYXAoY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIG9wdGlvbnNMaXN0W2ldLnJ1bklkLCBvcHRpb25zTGlzdFtpXS5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9uc0xpc3RbaV0ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5jYWxsKHRoaXMsIGlucHV0cywgb3B0aW9uc0xpc3QsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkocHJvbWlzZSwgb3B0aW9uc0xpc3Q/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGFuIEl0ZXJhdG9yIG9mIElucHV0IHZhbHVlcyBpbnRvIGFuIEl0ZXJhdG9yIG9mXG4gICAgICogT3V0cHV0IHZhbHVlcywgd2l0aCBjYWxsYmFja3MuXG4gICAgICogVXNlIHRoaXMgdG8gaW1wbGVtZW50IGBzdHJlYW0oKWAgb3IgYHRyYW5zZm9ybSgpYCBpbiBSdW5uYWJsZSBzdWJjbGFzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jICpfdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhpbnB1dEdlbmVyYXRvciwgdHJhbnNmb3JtZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbmFsSW5wdXQ7XG4gICAgICAgIGxldCBmaW5hbElucHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiB3cmFwSW5wdXRGb3JUcmFjaW5nKCkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxJbnB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbnB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBydW5NYW5hZ2VyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGlwZSA9IGF3YWl0ICgwLCBzdHJlYW1fanNfMS5waXBlR2VuZXJhdG9yV2l0aFNldHVwKSh0cmFuc2Zvcm1lci5iaW5kKHRoaXMpLCB3cmFwSW5wdXRGb3JUcmFjaW5nKCksIGFzeW5jICgpID0+IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgeyBpbnB1dDogXCJcIiB9LCBjb25maWcucnVuSWQsIGNvbmZpZy5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpLCBvcHRpb25zPy5zaWduYWwsIGNvbmZpZyk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAgICAgcnVuTWFuYWdlciA9IHBpcGUuc2V0dXA7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1FdmVudHNIYW5kbGVyID0gcnVuTWFuYWdlcj8uaGFuZGxlcnMuZmluZChldmVudF9zdHJlYW1fanNfMS5pc1N0cmVhbUV2ZW50c0hhbmRsZXIpO1xuICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gcGlwZS5vdXRwdXQ7XG4gICAgICAgICAgICBpZiAoc3RyZWFtRXZlbnRzSGFuZGxlciAhPT0gdW5kZWZpbmVkICYmIHJ1bk1hbmFnZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RyZWFtRXZlbnRzSGFuZGxlci50YXBPdXRwdXRJdGVyYWJsZShydW5NYW5hZ2VyLnJ1bklkLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1Mb2dIYW5kbGVyID0gcnVuTWFuYWdlcj8uaGFuZGxlcnMuZmluZChsb2dfc3RyZWFtX2pzXzEuaXNMb2dTdHJlYW1IYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1Mb2dIYW5kbGVyICE9PSB1bmRlZmluZWQgJiYgcnVuTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBzdHJlYW1Mb2dIYW5kbGVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bk1hbmFnZXIucnVuSWQsIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpIH0pO1xuICAgIH1cbiAgICBnZXRHcmFwaChfKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBoX2pzXzEuR3JhcGgoKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIGlucHV0IHNjaGVtYSBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IGlucHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9SW5wdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB6b2RfMS56LmFueSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVubmFibGVOb2RlID0gZ3JhcGguYWRkTm9kZSh0aGlzKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIG91dHB1dCBzY2hlbWFzIGZvciBydW5uYWJsZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9T3V0cHV0YCxcbiAgICAgICAgICAgIHNjaGVtYTogem9kXzEuei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoLmFkZEVkZ2UoaW5wdXROb2RlLCBydW5uYWJsZU5vZGUpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKHJ1bm5hYmxlTm9kZSwgb3V0cHV0Tm9kZSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlIHRoYXQgcnVucyBlYWNoIGluZGl2aWR1YWwgcnVubmFibGUgaW4gc2VyaWVzLFxuICAgICAqIHBpcGluZyB0aGUgb3V0cHV0IG9mIG9uZSBydW5uYWJsZSBpbnRvIGFub3RoZXIgcnVubmFibGUgb3IgcnVubmFibGUtbGlrZS5cbiAgICAgKiBAcGFyYW0gY29lcmNlYWJsZSBBIHJ1bm5hYmxlLCBmdW5jdGlvbiwgb3Igb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZnVuY3Rpb25zIG9yIHJ1bm5hYmxlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBydW5uYWJsZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMsXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpY2sga2V5cyBmcm9tIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIHBpY2soa2V5cykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUobmV3IFJ1bm5hYmxlUGljayhrZXlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGZpZWxkcyB0byB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3NpZ24obWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZUFzc2lnbihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRyYW5zZm9ybSwgd2hpY2ggYnVmZmVycyBpbnB1dCBhbmQgdGhlbiBjYWxscyBzdHJlYW0uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBjYW4gc3RhcnQgcHJvZHVjaW5nIG91dHB1dCB3aGlsZVxuICAgICAqIGlucHV0IGlzIHN0aWxsIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIGdhdGhlcmluZyBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGZpbmFsQ2h1bmssICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIGFsbCBvdXRwdXQgZnJvbSBhIHJ1bm5hYmxlLCBhcyByZXBvcnRlZCB0byB0aGUgY2FsbGJhY2sgc3lzdGVtLlxuICAgICAqIFRoaXMgaW5jbHVkZXMgYWxsIGlubmVyIHJ1bnMgb2YgTExNcywgUmV0cmlldmVycywgVG9vbHMsIGV0Yy5cbiAgICAgKiBPdXRwdXQgaXMgc3RyZWFtZWQgYXMgTG9nIG9iamVjdHMsIHdoaWNoIGluY2x1ZGUgYSBsaXN0IG9mXG4gICAgICoganNvbnBhdGNoIG9wcyB0aGF0IGRlc2NyaWJlIGhvdyB0aGUgc3RhdGUgb2YgdGhlIHJ1biBoYXMgY2hhbmdlZCBpbiBlYWNoXG4gICAgICogc3RlcCwgYW5kIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgcnVuLlxuICAgICAqIFRoZSBqc29ucGF0Y2ggb3BzIGNhbiBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGNvbnN0cnVjdCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdHJlYW1PcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgKnN0cmVhbUxvZyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBuZXcgbG9nX3N0cmVhbV9qc18xLkxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICAgIF9zY2hlbWFGb3JtYXQ6IFwib3JpZ2luYWxcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICB5aWVsZCogdGhpcy5fc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IFtsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChbbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb3BpZWRDYWxsYmFja3MgPSBjYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmFkZEhhbmRsZXIobG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNvcGllZENhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbVByb21pc2UgPSB0aGlzLnN0cmVhbShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9IGF3YWl0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJ1bm5hYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IGxvZ19zdHJlYW1fanNfMS5SdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9zdHJlYW1lZF9vdXRwdXQvLVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZSA9IGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsb2cgb2YgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbG9nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbiA9PT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1FdmVudHNWMShpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy52ZXJzaW9uID09PSBcInYyXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbUV2ZW50c1YyKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSB2ZXJzaW9ucyBcInYxXCIgYW5kIFwidjJcIiBvZiB0aGUgc2NoZW1hIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSBcInRleHQvZXZlbnQtc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgd3JhcHBlcnNfanNfMS5jb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0pKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Ioc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YyKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyZWFtZXIgPSBuZXcgZXZlbnRfc3RyZWFtX2pzXzEuRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcnVuSWQgPSBjb25maWcucnVuSWQgPz8gKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgY29uZmlnLnJ1bklkID0gcnVuSWQ7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbmZpZy5jYWxsYmFja3M7XG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IFtldmVudFN0cmVhbWVyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KGV2ZW50U3RyZWFtZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29waWVkQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvcHkoKTtcbiAgICAgICAgICAgIGNvcGllZENhbGxiYWNrcy5hZGRIYW5kbGVyKGV2ZW50U3RyZWFtZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgdGhlIHJ1bm5hYmxlIGluIHN0cmVhbWluZyBtb2RlLFxuICAgICAgICAvLyBhZGQgZWFjaCBjaHVuayB0byB0aGUgb3V0cHV0IHN0cmVhbVxuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgb3V0ZXJUaGlzLnN0cmVhbShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXBwZWRTdHJlYW0gPSBldmVudFN0cmVhbWVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bklkLCBydW5uYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiB0YXBwZWRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBpdGVyYXRlIHNvIHRoYXQgdGhlIGNhbGxiYWNrIGhhbmRsZXIgcGlja3MgdXAgZXZlbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZXZlbnRTdHJlYW1lci5maW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIGxldCBmaXJzdEV2ZW50U2VudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFJ1bklkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBldmVudFN0cmVhbWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmstYXJvdW5kIGFuIGlzc3VlIHdoZXJlIHRoZSBpbnB1dHMgaW50byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFpbiBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCB0aGUgZW50aXJlIGlucHV0IGlzIGNvbnN1bWVkLlxuICAgICAgICAgICAgICAgIC8vIEFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSdsbCBtb2RpZnkgdGhlIGlucHV0IHRvIGJlIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0RXZlbnRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEV2ZW50UnVuSWQgPSBldmVudC5ydW5faWQ7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJ1bl9pZCA9PT0gZmlyc3RFdmVudFJ1bklkICYmIGV2ZW50LmV2ZW50LmVuZHNXaXRoKFwiX2VuZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBlbmQgZXZlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBydW5uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb250IGluY2x1ZGUgdGhlIGlucHV0IGluIHRoZSBldmVudCBzaW5jZSBpdCdzIGd1YXJhbnRlZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudC5kYXRhLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgcnVubmFibGVTdHJlYW1Db25zdW1lUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YxKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIGxldCBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvb3RUYWdzID0gY29uZmlnLnRhZ3MgPz8gW107XG4gICAgICAgIGNvbnN0IHJvb3RNZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IGxvZ19zdHJlYW1fanNfMS5Mb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcInN0cmVhbWluZ19ldmVudHNcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvb3RFdmVudEZpbHRlciA9IG5ldyB1dGlsc19qc18xLl9Sb290RXZlbnRGaWx0ZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbSA9IHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBsb2dTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmICghcnVuTG9nKSB7XG4gICAgICAgICAgICAgICAgcnVuTG9nID0gbG9nX3N0cmVhbV9qc18xLlJ1bkxvZy5mcm9tUnVuTG9nUGF0Y2gobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5Mb2cuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3I6IFwic3RyZWFtRXZlbnRzXCIgc3RhdGUgaXMgbWlzc2luZy4gUGxlYXNlIG9wZW4gYSBidWcgcmVwb3J0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWWllbGQgdGhlIHN0YXJ0IGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZSBpZiBpdCBoYXNuJ3QgYmVlbiBzZWVuLlxuICAgICAgICAgICAgLy8gVGhlIHJvb3QgcnVuIGlzIG5ldmVyIGZpbHRlcmVkIG91dFxuICAgICAgICAgICAgaWYgKCFoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyAuLi5ydW5Mb2cuc3RhdGUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IGxvZy5vcHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcCkgPT4gb3AucGF0aC5zdGFydHNXaXRoKFwiL2xvZ3MvXCIpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wKSA9PiBvcC5wYXRoLnNwbGl0KFwiL1wiKVsyXSk7XG4gICAgICAgICAgICBjb25zdCBkZWR1cGVkUGF0aHMgPSBbLi4ubmV3IFNldChwYXRocyldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGRlZHVwZWRQYXRocykge1xuICAgICAgICAgICAgICAgIGxldCBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHJ1bkxvZy5zdGF0ZS5sb2dzW3BhdGhdO1xuICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5lbmRfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdHJlYW1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGlucHV0cyB3aXRoIHRoZSBzdGFydCBldmVudCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhleSB3aWxsIE5PVCBiZSBhdmFpbGFibGUgZm9yIGNvbXBvbmVudHMgdGhhdCBvcGVyYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHN0cmVhbXMsIHNpbmNlIHRob3NlIGNvbXBvbmVudHMgc3RyZWFtIHRoZSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpdHMgZmluYWwgdmFsdWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm91dHB1dCA9IGxvZ0VudHJ5LmZpbmFsX291dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7bG9nRW50cnkubmFtZX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IGNodW5rOiBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBhcyB3ZWxsIVxuICAgICAgICAgICAgICAgICAgICBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7bG9nRW50cnkudHlwZX1fJHtldmVudFR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbG9nRW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBsb2dFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbG9nRW50cnkudGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGxvZ0VudHJ5Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB3ZSB0YWtlIGNhcmUgb2YgdGhlIHN0cmVhbWluZyBvdXRwdXQgZnJvbSB0aGUgcm9vdCBjaGFpblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55LlxuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gcnVuTG9nO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7c3RhdGUubmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geyBjaHVuazogc3RhdGUuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHN0YXRlLnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJ1bkxvZz8uc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB5aWVsZCB0aGUgZW5kIGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9lbmRgLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogc3RhdGUuZmluYWxfb3V0cHV0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGUodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmlzUnVubmFibGVJbnRlcmZhY2UpKHRoaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyByb290X2xpc3RlbmVyX2pzXzEuUm9vdExpc3RlbmVyc1RyYWNlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBydW5uYWJsZSB0byBhIHRvb2wuIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWBcbiAgICAgKiB3aGljaCBjb250YWlucyB0aGUgcnVubmFibGUsIG5hbWUsIGRlc2NyaXB0aW9uIGFuZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUge1QgZXh0ZW5kcyBSdW5JbnB1dCA9IFJ1bklucHV0fSBSdW5JbnB1dCAtIFRoZSBpbnB1dCB0eXBlIG9mIHRoZSBydW5uYWJsZS4gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBgUnVuSW5wdXRgIHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC4gRmFsbHMgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gb24gdGhlIFpvZCBzY2hlbWEgaWYgbm90IHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgbmVpdGhlciBhcmUgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHt6LlpvZFR5cGU8VD59IFtmaWVsZHMuc2NoZW1hXSBUaGUgWm9kIHNjaGVtYSBmb3IgdGhlIGlucHV0IG9mIHRoZSB0b29sLiBJbmZlcnMgdGhlIFpvZCB0eXBlIGZyb20gdGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtSdW5uYWJsZVRvb2xMaWtlPHouWm9kVHlwZTxUPiwgUnVuT3V0cHV0Pn0gQW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgIHdoaWNoIGlzIGEgcnVubmFibGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHRvb2wuXG4gICAgICovXG4gICAgYXNUb29sKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gY29udmVydFJ1bm5hYmxlVG9Ub29sKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZSA9IFJ1bm5hYmxlO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgZGVsZWdhdGVzIGNhbGxzIHRvIGFub3RoZXIgcnVubmFibGUgd2l0aCBhIHNldCBvZiBrd2FyZ3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgdHlwZSBSdW5uYWJsZUNvbmZpZyxcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgZW5oYW5jZVByb2ZpbGUgPSAoXG4gKiAgIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gKiAgIGNvbmZpZz86IFJ1bm5hYmxlQ29uZmlnXG4gKiApID0+IHtcbiAqICAgaWYgKGNvbmZpZz8uY29uZmlndXJhYmxlPy5yb2xlKSB7XG4gKiAgICAgcmV0dXJuIHsgLi4ucHJvZmlsZSwgcm9sZTogY29uZmlnLmNvbmZpZ3VyYWJsZS5yb2xlIH07XG4gKiAgIH1cbiAqICAgcmV0dXJuIHByb2ZpbGU7XG4gKiB9O1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShlbmhhbmNlUHJvZmlsZSk7XG4gKlxuICogLy8gQmluZCBjb25maWd1cmF0aW9uIHRvIHRoZSBydW5uYWJsZSB0byBzZXQgdGhlIHVzZXIncyByb2xlIGR5bmFtaWNhbGx5XG4gKiBjb25zdCBhZG1pblJ1bm5hYmxlID0gcnVubmFibGUuYmluZCh7IGNvbmZpZ3VyYWJsZTogeyByb2xlOiBcIkFkbWluXCIgfSB9KTtcbiAqIGNvbnN0IHVzZXJSdW5uYWJsZSA9IHJ1bm5hYmxlLmJpbmQoeyBjb25maWd1cmFibGU6IHsgcm9sZTogXCJVc2VyXCIgfSB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQxID0gYXdhaXQgYWRtaW5SdW5uYWJsZS5pbnZva2Uoe1xuICogICBuYW1lOiBcIkFsaWNlXCIsXG4gKiAgIGVtYWlsOiBcImFsaWNlQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJBbGljZVwiLCBlbWFpbDogXCJhbGljZUBleGFtcGxlLmNvbVwiLCByb2xlOiBcIkFkbWluXCIgfVxuICpcbiAqIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB1c2VyUnVubmFibGUuaW52b2tlKHtcbiAqICAgbmFtZTogXCJCb2JcIixcbiAqICAgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJCb2JcIiwgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCIsIHJvbGU6IFwiVXNlclwiIH1cbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZUJpbmRpbmcgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQmluZGluZ1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ0ZhY3Rvcmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgICAgICB0aGlzLmt3YXJncyA9IGZpZWxkcy5rd2FyZ3M7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZmllbGRzLmNvbmZpZztcbiAgICAgICAgdGhpcy5jb25maWdGYWN0b3JpZXMgPSBmaWVsZHMuY29uZmlnRmFjdG9yaWVzO1xuICAgIH1cbiAgICBnZXROYW1lKHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5nZXROYW1lKHN1ZmZpeCk7XG4gICAgfVxuICAgIGFzeW5jIF9tZXJnZUNvbmZpZyguLi5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5tZXJnZUNvbmZpZ3MpKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgwLCBjb25maWdfanNfMS5tZXJnZUNvbmZpZ3MpKGNvbmZpZywgLi4uKHRoaXMuY29uZmlnRmFjdG9yaWVzXG4gICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY29uZmlnRmFjdG9yaWVzLm1hcChhc3luYyAoY29uZmlnRmFjdG9yeSkgPT4gYXdhaXQgY29uZmlnRmFjdG9yeShjb25maWcpKSlcbiAgICAgICAgICAgIDogW10pKTtcbiAgICB9XG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB7IC4uLnRoaXMua3dhcmdzLCAuLi5rd2FyZ3MgfSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhSZXRyeShmaWVsZHMpLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuaW52b2tlKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICAgICAgICAgID8gYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKGluZGl2aWR1YWxPcHRpb24pID0+IHRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKGluZGl2aWR1YWxPcHRpb24pLCB0aGlzLmt3YXJncykpKVxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsIG1lcmdlZE9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLnN0cmVhbShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnRyYW5zZm9ybShnZW5lcmF0b3IsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IG91dGVyVGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCogb3V0ZXJUaGlzLmJvdW5kLnN0cmVhbUV2ZW50cyhpbnB1dCwge1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBvdXRlclRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpLCBvdXRlclRoaXMua3dhcmdzKSksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgfSwgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlQmluZGluZyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaW5nXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nLmJvdW5kICYmIFJ1bm5hYmxlLmlzUnVubmFibGUodGhpbmcuYm91bmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgY29uZmlnRmFjdG9yaWVzOiBbXG4gICAgICAgICAgICAgICAgKGNvbmZpZykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgcm9vdF9saXN0ZW5lcl9qc18xLlJvb3RMaXN0ZW5lcnNUcmFjZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVCaW5kaW5nID0gUnVubmFibGVCaW5kaW5nO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgZGVsZWdhdGVzIGNhbGxzIHRvIGFub3RoZXIgcnVubmFibGVcbiAqIHdpdGggZWFjaCBlbGVtZW50IG9mIHRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZUVhY2gsIFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCB0b1VwcGVyQ2FzZSA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IGlucHV0LnRvVXBwZXJDYXNlKCk7XG4gKiBjb25zdCBhZGRHcmVldGluZyA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IGBIZWxsbywgJHtpbnB1dH0hYDtcbiAqXG4gKiBjb25zdCB1cHBlckNhc2VMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHRvVXBwZXJDYXNlKTtcbiAqIGNvbnN0IGdyZWV0aW5nTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGRHcmVldGluZyk7XG4gKlxuICogY29uc3QgY2hhaW4gPSBuZXcgUnVubmFibGVFYWNoKHtcbiAqICAgYm91bmQ6IHVwcGVyQ2FzZUxhbWJkYS5waXBlKGdyZWV0aW5nTGFtYmRhKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZShbXCJhbGljZVwiLCBcImJvYlwiLCBcImNhcm9sXCJdKVxuICpcbiAqIC8vIFtcIkhlbGxvLCBBTElDRSFcIiwgXCJIZWxsbywgQk9CIVwiLCBcIkhlbGxvLCBDQVJPTCFcIl1cbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZUVhY2ggZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlRWFjaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ga3dhcmdzIFRoZSBhcmd1bWVudHMgdG8gYmluZCB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bm5hYmxlRWFjaGAgY2xhc3MgdGhhdCBpcyBib3VuZCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLmJpbmQoa3dhcmdzKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXRzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZS5iaW5kKHRoaXMpLCBpbnB1dHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgX2ludm9rZShpbnB1dHMsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUVhY2ggPSBSdW5uYWJsZUVhY2g7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJ1bm5hYmxlcyB0aGF0IGNhbiBiZSByZXRyaWVkIGFcbiAqIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlUmV0cnksXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogLy8gU2ltdWxhdGUgYW4gQVBJIGNhbGwgdGhhdCBmYWlsc1xuICogY29uc3Qgc2ltdWxhdGVBcGlDYWxsID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICogICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyBBUEkgY2FsbCB3aXRoIGlucHV0OiAke2lucHV0fWApO1xuICogICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkgY2FsbCBmYWlsZWQgZHVlIHRvIG5ldHdvcmsgaXNzdWVcIik7XG4gKiB9O1xuICpcbiAqIGNvbnN0IGFwaUNhbGxMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHNpbXVsYXRlQXBpQ2FsbCk7XG4gKlxuICogLy8gQXBwbHkgcmV0cnkgbG9naWMgdXNpbmcgdGhlIC53aXRoUmV0cnkoKSBtZXRob2RcbiAqIGNvbnN0IGFwaUNhbGxXaXRoUmV0cnkgPSBhcGlDYWxsTGFtYmRhLndpdGhSZXRyeSh7IHN0b3BBZnRlckF0dGVtcHQ6IDMgfSk7XG4gKlxuICogLy8gQWx0ZXJuYXRpdmVseSwgY3JlYXRlIGEgUnVubmFibGVSZXRyeSBpbnN0YW5jZSBtYW51YWxseVxuICogY29uc3QgbWFudWFsUmV0cnkgPSBuZXcgUnVubmFibGVSZXRyeSh7XG4gKiAgIGJvdW5kOiBhcGlDYWxsTGFtYmRhLFxuICogICBtYXhBdHRlbXB0TnVtYmVyOiAzLFxuICogICBjb25maWc6IHt9LFxuICogfSk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIHVzaW5nIHRoZSAud2l0aFJldHJ5KCkgbWV0aG9kXG4gKiBjb25zdCByZXMgPSBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5XG4gKiAgIC5pbnZva2UoXCJSZXF1ZXN0IDFcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllczpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyB0aGUgbWFudWFsIHJldHJ5IGluc3RhbmNlXG4gKiBjb25zdCByZXMyID0gYXdhaXQgbWFudWFsUmV0cnlcbiAqICAgLmludm9rZShcIlJlcXVlc3QgMlwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBtdWx0aXBsZSByZXRyaWVzOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVSZXRyeSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUmV0cnlcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heEF0dGVtcHROdW1iZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4geyB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heEF0dGVtcHROdW1iZXIgPSBmaWVsZHMubWF4QXR0ZW1wdE51bWJlciA/PyB0aGlzLm1heEF0dGVtcHROdW1iZXI7XG4gICAgICAgIHRoaXMub25GYWlsZWRBdHRlbXB0ID0gZmllbGRzLm9uRmFpbGVkQXR0ZW1wdCA/PyB0aGlzLm9uRmFpbGVkQXR0ZW1wdDtcbiAgICB9XG4gICAgX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdCwgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGF0dGVtcHQgPiAxID8gYHJldHJ5OmF0dGVtcHQ6JHthdHRlbXB0fWAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRhZykgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gKDAsIHBfcmV0cnlfMS5kZWZhdWx0KSgoYXR0ZW1wdE51bWJlcikgPT4gc3VwZXIuaW52b2tlKGlucHV0LCB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZywgcnVuTWFuYWdlcikpLCB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZXJyb3IpID0+IHRoaXMub25GYWlsZWRBdHRlbXB0KGVycm9yLCBpbnB1dCksXG4gICAgICAgICAgICByZXRyaWVzOiBNYXRoLm1heCh0aGlzLm1heEF0dGVtcHROdW1iZXIgLSAxLCAwKSxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGludm9rZXMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCwgcnVuIG1hbmFnZXIsXG4gICAgICogYW5kIGNvbmZpZy4gSXQgaGFuZGxlcyB0aGUgcmV0cnkgbG9naWMgYnkgY2F0Y2hpbmcgYW55IGVycm9ycyBhbmRcbiAgICAgKiByZWN1cnNpdmVseSBpbnZva2luZyBpdHNlbGYgd2l0aCB0aGUgdXBkYXRlZCBjb25maWcgZm9yIHRoZSBuZXh0IHJldHJ5XG4gICAgICogYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHJ1bk1hbmFnZXIgVGhlIHJ1biBtYW5hZ2VyIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlnIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZS5iaW5kKHRoaXMpLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgX2JhdGNoKGlucHV0cywgY29uZmlncywgcnVuTWFuYWdlcnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHRzTWFwID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCAoMCwgcF9yZXRyeV8xLmRlZmF1bHQpKGFzeW5jIChhdHRlbXB0TnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5kZXhlcyA9IGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpKSA9PiByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNNYXBbaS50b1N0cmluZygpXSBpbnN0YW5jZW9mIEVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dHMgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gaW5wdXRzW2ldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkQ29uZmlncyA9IHJlbWFpbmluZ0luZGV4ZXMubWFwKChpKSA9PiB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZ3M/LltpXSwgcnVuTWFuYWdlcnM/LltpXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5iYXRjaChyZW1haW5pbmdJbnB1dHMsIHBhdGNoZWRDb25maWdzLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJhdGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRXhjZXB0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdE1hcEluZGV4ID0gcmVtYWluaW5nSW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEV4Y2VwdGlvbi5pbnB1dCA9IHJlbWFpbmluZ0lucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW3Jlc3VsdE1hcEluZGV4LnRvU3RyaW5nKCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiAoZXJyb3IpID0+IHRoaXMub25GYWlsZWRBdHRlbXB0KGVycm9yLCBlcnJvci5pbnB1dCksXG4gICAgICAgICAgICAgICAgcmV0cmllczogTWF0aC5tYXgodGhpcy5tYXhBdHRlbXB0TnVtYmVyIC0gMSwgMCksXG4gICAgICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHRzTWFwKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEsIDEwKSAtIHBhcnNlSW50KGIsIDEwKSlcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gcmVzdWx0c01hcFtwYXJzZUludChrZXksIDEwKV0pO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmF0Y2hXaXRoQ29uZmlnKHRoaXMuX2JhdGNoLmJpbmQodGhpcyksIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlUmV0cnkgPSBSdW5uYWJsZVJldHJ5O1xuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIHJ1bm5hYmxlcywgd2hlcmUgdGhlIG91dHB1dCBvZiBlYWNoIGlzIHRoZSBpbnB1dCBvZiB0aGUgbmV4dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW3Byb21wdFRlbXBsYXRlLCBuZXcgQ2hhdE9wZW5BSSh7fSldKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVTZXF1ZW5jZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVTZXF1ZW5jZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlkZGxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbWl0U2VxdWVuY2VUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpcnN0ID0gZmllbGRzLmZpcnN0O1xuICAgICAgICB0aGlzLm1pZGRsZSA9IGZpZWxkcy5taWRkbGUgPz8gdGhpcy5taWRkbGU7XG4gICAgICAgIHRoaXMubGFzdCA9IGZpZWxkcy5sYXN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5vbWl0U2VxdWVuY2VUYWdzID0gZmllbGRzLm9taXRTZXF1ZW5jZVRhZ3MgPz8gdGhpcy5vbWl0U2VxdWVuY2VUYWdzO1xuICAgIH1cbiAgICBnZXQgc3RlcHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF07XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBJbnB1dCA9IGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkocHJvbWlzZSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgY2FuJ3QgZGV0ZWN0IHRoYXQgdGhlIGxhc3Qgb3V0cHV0IG9mIHRoZSBzZXF1ZW5jZSByZXR1cm5zIFJ1bk91dHB1dCwgc28gY2FsbCBpdCBvdXQgb2YgdGhlIGxvb3AgaGVyZVxuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbE91dHB1dCA9IGF3YWl0IHRoaXMubGFzdC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke3RoaXMuc3RlcHMubGVuZ3RofWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBmaW5hbE91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIGNvbmZpZ0xpc3RbaV0ucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5zdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5iYXRjaChuZXh0U3RlcElucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUnVuTWFuYWdlciA9IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke2kgKyAxfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWdMaXN0W2pdLCB7IGNhbGxiYWNrczogY2hpbGRSdW5NYW5hZ2VyIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXRzID0gYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBjb25maWdMaXN0WzBdPy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSkpKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG5leHRTdGVwSW5wdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG5leHRTdGVwSW5wdXRzO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF07XG4gICAgICAgIGxldCBjb25jYXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpbnB1dEdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmluYWxHZW5lcmF0b3IgPSBzdGVwc1swXS50cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IoKSwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShvdGhlck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoxYCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIGZpbmFsR2VuZXJhdG9yID0gYXdhaXQgc3RlcC50cmFuc2Zvcm0oZmluYWxHZW5lcmF0b3IsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3RoZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmaW5hbEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoY29uY2F0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgZ2V0R3JhcGgoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBoX2pzXzEuR3JhcGgoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGN1cnJlbnRMYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBHcmFwaCA9IHN0ZXAuZ2V0R3JhcGgoY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltRmlyc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltTGFzdE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoLmV4dGVuZChzdGVwR3JhcGgpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcEZpcnN0Tm9kZSA9IHN0ZXBHcmFwaC5maXJzdE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghc3RlcEZpcnN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVubmFibGUgJHtzdGVwfSBoYXMgbm8gZmlyc3Qgbm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2UoY3VycmVudExhc3ROb2RlLCBzdGVwRmlyc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYXN0Tm9kZSA9IHN0ZXBHcmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgaWYgKFJ1bm5hYmxlU2VxdWVuY2UuaXNSdW5uYWJsZVNlcXVlbmNlKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIG1pZGRsZTogdGhpcy5taWRkbGUuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0LFxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VhYmxlLmZpcnN0LFxuICAgICAgICAgICAgICAgICAgICAuLi5jb2VyY2VhYmxlLm1pZGRsZSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBsYXN0OiBjb2VyY2VhYmxlLmxhc3QsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IGNvZXJjZWFibGUubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IFsuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XSxcbiAgICAgICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlU2VxdWVuY2UodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcubWlkZGxlKSAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKHRoaW5nKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbShbZmlyc3QsIC4uLnJ1bm5hYmxlc10sIG5hbWVPckZpZWxkcykge1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JGaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV4dHJhLm5hbWUgPSBuYW1lT3JGaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZU9yRmllbGRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4dHJhID0gbmFtZU9yRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgICAgIGZpcnN0OiBfY29lcmNlVG9SdW5uYWJsZShmaXJzdCksXG4gICAgICAgICAgICBtaWRkbGU6IHJ1bm5hYmxlcy5zbGljZSgwLCAtMSkubWFwKF9jb2VyY2VUb1J1bm5hYmxlKSxcbiAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKHJ1bm5hYmxlc1tydW5uYWJsZXMubGVuZ3RoIC0gMV0pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlU2VxdWVuY2UgPSBSdW5uYWJsZVNlcXVlbmNlO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIG1hcHBpbmcgb2YgcnVubmFibGVzIGluIHBhcmFsbGVsLFxuICogYW5kIHJldHVybnMgYSBtYXBwaW5nIG9mIHRoZWlyIG91dHB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbWFwQ2hhaW4gPSBSdW5uYWJsZU1hcC5mcm9tKHtcbiAqICAgam9rZTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqICAgcG9lbTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwid3JpdGUgYSAyLWxpbmUgcG9lbSBhYm91dCB7dG9waWN9XCIpLnBpcGUoXG4gKiAgICAgbmV3IENoYXRBbnRocm9waWMoe30pLFxuICogICApLFxuICogfSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBtYXBDaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyXCIgfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVNYXAgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTWFwXCI7XG4gICAgfVxuICAgIGdldFN0ZXBzS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RlcHMpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0ZXBzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcy5zdGVwcykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHsgc3RlcHMgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICB9LCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0ZXBzKS5tYXAoYXN5bmMgKFtrZXksIHJ1bm5hYmxlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShQcm9taXNlLmFsbChwcm9taXNlcyksIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBzaGFsbG93IGNvcHkgc3RlcHMgdG8gaWdub3JlIGNoYW5nZXMgd2hpbGUgaXRlcmF0aW5nXG4gICAgICAgIGNvbnN0IHN0ZXBzID0geyAuLi50aGlzLnN0ZXBzIH07XG4gICAgICAgIC8vIGVhY2ggc3RlcCBnZXRzIGEgY29weSBvZiB0aGUgaW5wdXQgaXRlcmF0b3JcbiAgICAgICAgY29uc3QgaW5wdXRDb3BpZXMgPSAoMCwgc3RyZWFtX2pzXzEuYXRlZSkoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYG1hcDprZXk6JHtrZXl9YCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgZ2VuLm5leHQoKS50aGVuKChyZXN1bHQpID0+ICh7IGtleSwgZ2VuLCByZXN1bHQgfSkpXTtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB5aWVsZCBjaHVua3MgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLFxuICAgICAgICAvLyBzdGFydGluZyBuZXcgaXRlcmF0aW9ucyBhcyBuZWVkZWQsXG4gICAgICAgIC8vIHVudGlsIGFsbCBpdGVyYXRvcnMgYXJlIGRvbmVcbiAgICAgICAgd2hpbGUgKHRhc2tzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJhY2UodGFza3MudmFsdWVzKCkpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHJlc3VsdCwgZ2VuIH0gPSBhd2FpdCAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IFtrZXldOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0YXNrcy5zZXQoa2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgc3RyZWFtX2pzXzEuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlTWFwID0gUnVubmFibGVNYXA7XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhIHRyYWNlZCBMYW5nU21pdGggZnVuY3Rpb24uXG4gKi9cbmNsYXNzIFJ1bm5hYmxlVHJhY2VhYmxlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghKDAsIHRyYWNlYWJsZV8xLmlzVHJhY2VhYmxlRnVuY3Rpb24pKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVUcmFjZWFibGUgcmVxdWlyZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWddID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgMSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmZ1bmMoKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHsgY2FsbGJhY2tzIH0pLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIGNvbmZpZz8uc2lnbmFsKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnXSA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIDEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICgoMCwgaXRlcl9qc18xLmlzQXN5bmNJdGVyYWJsZSkocmVzdWx0KSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpdGVyX2pzXzEuaXNJdGVyYXRvcikocmVzdWx0KSkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHJlc3VsdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVHJhY2VhYmxlKHsgZnVuYyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlVHJhY2VhYmxlID0gUnVubmFibGVUcmFjZWFibGU7XG5mdW5jdGlvbiBhc3NlcnROb25UcmFjZWFibGVGdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKCgwLCB0cmFjZWFibGVfMS5pc1RyYWNlYWJsZUZ1bmN0aW9uKShmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUxhbWJkYSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvbi4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgYWRkID0gKGlucHV0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pID0+IGlucHV0LnggKyBpbnB1dC55O1xuICpcbiAqIGNvbnN0IG11bHRpcGx5ID0gKGlucHV0OiB7IHZhbHVlOiBudW1iZXI7IG11bHRpcGxpZXI6IG51bWJlciB9KSA9PlxuICogICBpbnB1dC52YWx1ZSAqIGlucHV0Lm11bHRpcGxpZXI7XG4gKlxuICogLy8gQ3JlYXRlIHJ1bm5hYmxlcyBmb3IgdGhlIGZ1bmN0aW9uc1xuICogY29uc3QgYWRkTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGQpO1xuICogY29uc3QgbXVsdGlwbHlMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKG11bHRpcGx5KTtcbiAqXG4gKiAvLyBDaGFpbiB0aGUgbGFtYmRhcyBmb3IgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uXG4gKiBjb25zdCBjaGFpbmVkTGFtYmRhID0gYWRkTGFtYmRhLnBpcGUoKHJlc3VsdCkgPT5cbiAqICAgbXVsdGlwbHlMYW1iZGEuaW52b2tlKHsgdmFsdWU6IHJlc3VsdCwgbXVsdGlwbGllcjogMiB9KVxuICogKTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gb2YgdGhlIGNoYWluZWRMYW1iZGFcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluZWRMYW1iZGEuaW52b2tlKHsgeDogMiwgeTogMyB9KTtcbiAqXG4gKiAvLyBXaWxsIGxvZyBcIjEwXCIgKHNpbmNlICgyICsgMykgKiAyID0gMTApXG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVMYW1iZGEgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTGFtYmRhXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAoKDAsIHRyYWNlYWJsZV8xLmlzVHJhY2VhYmxlRnVuY3Rpb24pKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIFJ1bm5hYmxlVHJhY2VhYmxlLmZyb20oZmllbGRzLmZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0Tm9uVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHtcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoY2hpbGRDb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5mdW5jKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgUnVubmFibGUuaXNSdW5uYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBsaW1pdCByZWFjaGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNoaWxkQ29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgaXRlcl9qc18xLmlzQXN5bmNJdGVyYWJsZSkob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoMCwgaXRlcl9qc18xLmNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KShjaGlsZENvbmZpZywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gZmluYWxPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGl0ZXJfanNfMS5pc0l0ZXJhYmxlSXRlcmF0b3IpKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgKDAsIGl0ZXJfanNfMS5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBjb25maWcpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNoaWxkQ29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpdGVyX2pzXzEuaXNBc3luY0l0ZXJhYmxlKShvdXRwdXQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mICgwLCBpdGVyX2pzXzEuY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGl0ZXJfanNfMS5pc0l0ZXJhYmxlSXRlcmF0b3IpKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgKDAsIGl0ZXJfanNfMS5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBzdHJlYW1fanNfMS5Bc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgICAgICBnZW5lcmF0b3I6IHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBjb25maWcpLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd3JhcHBlZEdlbmVyYXRvci5zZXR1cDtcbiAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHdyYXBwZWRHZW5lcmF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYTtcbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVBhcmFsbGVsLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IGFkZFllYXJzID0gKGFnZTogbnVtYmVyKTogbnVtYmVyID0+IGFnZSArIDU7XG4gKiBjb25zdCB5ZWFyc1RvRmlmdHkgPSAoYWdlOiBudW1iZXIpOiBudW1iZXIgPT4gNTAgLSBhZ2U7XG4gKiBjb25zdCB5ZWFyc1RvSHVuZHJlZCA9IChhZ2U6IG51bWJlcik6IG51bWJlciA9PiAxMDAgLSBhZ2U7XG4gKlxuICogY29uc3QgYWRkWWVhcnNMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFkZFllYXJzKTtcbiAqIGNvbnN0IG1pbGVzdG9uZUZpZnR5TGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbSh5ZWFyc1RvRmlmdHkpO1xuICogY29uc3QgbWlsZXN0b25lSHVuZHJlZExhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oeWVhcnNUb0h1bmRyZWQpO1xuICpcbiAqIC8vIFBpcGUgd2lsbCBjb2VyY2Ugb2JqZWN0cyBpbnRvIFJ1bm5hYmxlUGFyYWxsZWwgYnkgZGVmYXVsdCwgYnV0IHdlXG4gKiAvLyBleHBsaWNpdGx5IGluc3RhbnRpYXRlIG9uZSBoZXJlIHRvIGRlbW9uc3RyYXRlXG4gKiBjb25zdCBzZXF1ZW5jZSA9IGFkZFllYXJzTGFtYmRhLnBpcGUoXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwuZnJvbSh7XG4gKiAgICAgeWVhcnNfdG9fZmlmdHk6IG1pbGVzdG9uZUZpZnR5TGFtYmRhLFxuICogICAgIHllYXJzX3RvX2h1bmRyZWQ6IG1pbGVzdG9uZUh1bmRyZWRMYW1iZGEsXG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIC8vIEludm9rZSB0aGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBhZ2UgaW5wdXRcbiAqIGNvbnN0IHJlcyA9IHNlcXVlbmNlLmludm9rZSgyNSk7XG4gKlxuICogLy8geyB5ZWFyc190b19maWZ0eTogMjUsIHllYXJzX3RvX2h1bmRyZWQ6IDc1IH1cbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVBhcmFsbGVsIGV4dGVuZHMgUnVubmFibGVNYXAge1xufVxuZXhwb3J0cy5SdW5uYWJsZVBhcmFsbGVsID0gUnVubmFibGVQYXJhbGxlbDtcbi8qKlxuICogQSBSdW5uYWJsZSB0aGF0IGNhbiBmYWxsYmFjayB0byBvdGhlciBSdW5uYWJsZXMgaWYgaXQgZmFpbHMuXG4gKiBFeHRlcm5hbCBBUElzIChlLmcuLCBBUElzIGZvciBhIGxhbmd1YWdlIG1vZGVsKSBtYXkgYXQgdGltZXMgZXhwZXJpZW5jZVxuICogZGVncmFkZWQgcGVyZm9ybWFuY2Ugb3IgZXZlbiBkb3dudGltZS5cbiAqXG4gKiBJbiB0aGVzZSBjYXNlcywgaXQgY2FuIGJlIHVzZWZ1bCB0byBoYXZlIGEgZmFsbGJhY2sgUnVubmFibGUgdGhhdCBjYW4gYmVcbiAqIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIFJ1bm5hYmxlIChlLmcuLCBmYWxsYmFjayB0byBhbm90aGVyIExMTSBwcm92aWRlcikuXG4gKlxuICogRmFsbGJhY2tzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBsZXZlbCBvZiBhIHNpbmdsZSBSdW5uYWJsZSwgb3IgYXQgdGhlIGxldmVsXG4gKiBvZiBhIGNoYWluIG9mIFJ1bm5hYmxlcy4gRmFsbGJhY2tzIGFyZSB0cmllZCBpbiBvcmRlciB1bnRpbCBvbmUgc3VjY2VlZHMgb3JcbiAqIGFsbCBmYWlsLlxuICpcbiAqIFdoaWxlIHlvdSBjYW4gaW5zdGFudGlhdGUgYSBgUnVubmFibGVXaXRoRmFsbGJhY2tzYCBkaXJlY3RseSwgaXQgaXMgdXN1YWxseVxuICogbW9yZSBjb252ZW5pZW50IHRvIHVzZSB0aGUgYHdpdGhGYWxsYmFja3NgIG1ldGhvZCBvbiBhbiBleGlzdGluZyBSdW5uYWJsZS5cbiAqXG4gKiBXaGVuIHN0cmVhbWluZywgZmFsbGJhY2tzIHdpbGwgb25seSBiZSBjYWxsZWQgb24gZmFpbHVyZXMgZHVyaW5nIHRoZSBpbml0aWFsXG4gKiBzdHJlYW0gY3JlYXRpb24uIEVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIGEgc3RyZWFtIHN0YXJ0cyB3aWxsIG5vdCBmYWxsYmFja1xuICogdG8gdGhlIG5leHQgUnVubmFibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVdpdGhGYWxsYmFja3MsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgcHJpbWFyeU9wZXJhdGlvbiA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgaWYgKGlucHV0ICE9PSBcInNhZmVcIikge1xuICogICAgIHRocm93IG5ldyBFcnJvcihcIlByaW1hcnkgb3BlcmF0aW9uIGZhaWxlZCBkdWUgdG8gdW5zYWZlIGlucHV0XCIpO1xuICogICB9XG4gKiAgIHJldHVybiBgUHJvY2Vzc2VkOiAke2lucHV0fWA7XG4gKiB9O1xuICpcbiAqIC8vIERlZmluZSBhIGZhbGxiYWNrIG9wZXJhdGlvbiB0aGF0IHByb2Nlc3NlcyB0aGUgaW5wdXQgZGlmZmVyZW50bHlcbiAqIGNvbnN0IGZhbGxiYWNrT3BlcmF0aW9uID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAqICAgYEZhbGxiYWNrIHByb2Nlc3NlZDogJHtpbnB1dH1gO1xuICpcbiAqIGNvbnN0IHByaW1hcnlSdW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20ocHJpbWFyeU9wZXJhdGlvbik7XG4gKiBjb25zdCBmYWxsYmFja1J1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShmYWxsYmFja09wZXJhdGlvbik7XG4gKlxuICogLy8gQXBwbHkgdGhlIGZhbGxiYWNrIGxvZ2ljIHVzaW5nIHRoZSAud2l0aEZhbGxiYWNrcygpIG1ldGhvZFxuICogY29uc3QgcnVubmFibGVXaXRoRmFsbGJhY2sgPSBwcmltYXJ5UnVubmFibGUud2l0aEZhbGxiYWNrcyhbZmFsbGJhY2tSdW5uYWJsZV0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyBpbnN0YW5jZSBtYW51YWxseVxuICogY29uc3QgbWFudWFsRmFsbGJhY2tDaGFpbiA9IG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICogICBydW5uYWJsZTogcHJpbWFyeVJ1bm5hYmxlLFxuICogICBmYWxsYmFja3M6IFtmYWxsYmFja1J1bm5hYmxlXSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyAud2l0aEZhbGxiYWNrcygpXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZVdpdGhGYWxsYmFja1xuICogICAuaW52b2tlKFwidW5zYWZlIGlucHV0XCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIGFsbCBhdHRlbXB0czpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICpcbiAqIC8vIFwiRmFsbGJhY2sgcHJvY2Vzc2VkOiB1bnNhZmUgaW5wdXRcIlxuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyBtYW51YWwgaW5zdGFudGlhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgbWFudWFsRmFsbGJhY2tDaGFpblxuICogICAuaW52b2tlKFwic2FmZVwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBhbGwgYXR0ZW1wdHM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBcIlByb2Nlc3NlZDogc2FmZVwiXG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVXaXRoRmFsbGJhY2tzIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVdpdGhGYWxsYmFja3NcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmFsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVubmFibGUgPSBmaWVsZHMucnVubmFibGU7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tzID0gZmllbGRzLmZhbGxiYWNrcztcbiAgICB9XG4gICAgKnJ1bm5hYmxlcygpIHtcbiAgICAgICAgeWllbGQgdGhpcy5ydW5uYWJsZTtcbiAgICAgICAgZm9yIChjb25zdCBmYWxsYmFjayBvZiB0aGlzLmZhbGxiYWNrcykge1xuICAgICAgICAgICAgeWllbGQgZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyQ29uZmlnRmllbGRzIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlckNvbmZpZ0ZpZWxkcz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3RoZXJDb25maWdGaWVsZHMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2suXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcik7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJDb25maWdGaWVsZHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgcnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG90aGVyQ29uZmlnRmllbGRzPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3RoZXJDb25maWdGaWVsZHMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0gYXdhaXQgcnVubmFibGUuc3RyZWFtKGlucHV0LCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBmaXJzdEVycm9yID8/IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2suXCIpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgPT09IHVuZGVmaW5lZCA/IG91dHB1dCA6ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKG91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKChjb25maWcpID0+ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZykpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcChhc3luYyAoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydFJlcyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgY29uZmlnTGlzdFtpXS5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWdMaXN0W2ldLnJ1bklkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0YXJ0UmVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0xpc3RbMF0uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgcnVubmFibGUuYmF0Y2goaW5wdXRzLCBydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIsIGopID0+ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnTGlzdFtqXSwge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSkpLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaSkgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpKSk7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVdpdGhGYWxsYmFja3MgPSBSdW5uYWJsZVdpdGhGYWxsYmFja3M7XG4vLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgY29tcGlsZXIgbmVlZHMgaGVscCBlbGltaW5hdGluZyBFcnJvciBhcyBhIFJ1bk91dHB1dCB0eXBlXG5mdW5jdGlvbiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBjb2VyY2VhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUxhbWJkYSh7IGZ1bmM6IGNvZXJjZWFibGUgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFJ1bm5hYmxlLmlzUnVubmFibGUoY29lcmNlYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZWFibGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvZXJjZWFibGUpICYmIHR5cGVvZiBjb2VyY2VhYmxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcnVubmFibGVzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7XG4gICAgICAgICAgICBzdGVwczogcnVubmFibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBSdW5uYWJsZSwgZnVuY3Rpb24gb3Igb2JqZWN0Llxcbkluc3RlYWQgZ290IGFuIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5fY29lcmNlVG9SdW5uYWJsZSA9IF9jb2VyY2VUb1J1bm5hYmxlO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUFzc2lnbixcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgY2FsY3VsYXRlQWdlID0gKHg6IHsgYmlydGhZZWFyOiBudW1iZXIgfSk6IHsgYWdlOiBudW1iZXIgfSA9PiB7XG4gKiAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICogICByZXR1cm4geyBhZ2U6IGN1cnJlbnRZZWFyIC0geC5iaXJ0aFllYXIgfTtcbiAqIH07XG4gKlxuICogY29uc3QgY3JlYXRlR3JlZXRpbmcgPSAoeDogeyBuYW1lOiBzdHJpbmcgfSk6IHsgZ3JlZXRpbmc6IHN0cmluZyB9ID0+IHtcbiAqICAgcmV0dXJuIHsgZ3JlZXRpbmc6IGBIZWxsbywgJHt4Lm5hbWV9IWAgfTtcbiAqIH07XG4gKlxuICogY29uc3QgbWFwcGVyID0gUnVubmFibGVQYXJhbGxlbC5mcm9tKHtcbiAqICAgYWdlX3N0ZXA6IFJ1bm5hYmxlTGFtYmRhLmZyb20oY2FsY3VsYXRlQWdlKSxcbiAqICAgZ3JlZXRpbmdfc3RlcDogUnVubmFibGVMYW1iZGEuZnJvbShjcmVhdGVHcmVldGluZyksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZUFzc2lnbiA9IG5ldyBSdW5uYWJsZUFzc2lnbih7IG1hcHBlciB9KTtcbiAqXG4gKiBjb25zdCByZXMgPSBhd2FpdCBydW5uYWJsZUFzc2lnbi5pbnZva2UoeyBuYW1lOiBcIkFsaWNlXCIsIGJpcnRoWWVhcjogMTk5MCB9KTtcbiAqXG4gKiAvLyB7IG5hbWU6IFwiQWxpY2VcIiwgYmlydGhZZWFyOiAxOTkwLCBhZ2Vfc3RlcDogeyBhZ2U6IDM0IH0sIGdyZWV0aW5nX3N0ZXA6IHsgZ3JlZXRpbmc6IFwiSGVsbG8sIEFsaWNlIVwiIH0gfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlQXNzaWduIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUFzc2lnblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgUnVubmFibGVNYXApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBtYXBwZXI6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwcGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwcGVyID0gZmllbGRzLm1hcHBlcjtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlclJlc3VsdCA9IGF3YWl0IHRoaXMubWFwcGVyLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgICAgIC4uLm1hcHBlclJlc3VsdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgbWFwcGVyIGtleXNcbiAgICAgICAgY29uc3QgbWFwcGVyS2V5cyA9IHRoaXMubWFwcGVyLmdldFN0ZXBzS2V5cygpO1xuICAgICAgICAvLyBjcmVhdGUgdHdvIGlucHV0IGdlbnMsIG9uZSBmb3IgdGhlIG1hcHBlciwgb25lIGZvciB0aGUgaW5wdXRcbiAgICAgICAgY29uc3QgW2ZvclBhc3N0aHJvdWdoLCBmb3JNYXBwZXJdID0gKDAsIHN0cmVhbV9qc18xLmF0ZWUpKGdlbmVyYXRvcik7XG4gICAgICAgIC8vIGNyZWF0ZSBtYXBwZXIgb3V0cHV0IGdlblxuICAgICAgICBjb25zdCBtYXBwZXJPdXRwdXQgPSB0aGlzLm1hcHBlci50cmFuc2Zvcm0oZm9yTWFwcGVyLCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG9wdGlvbnMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIG1hcHBlclxuICAgICAgICBjb25zdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSA9IG1hcHBlck91dHB1dC5uZXh0KCk7XG4gICAgICAgIC8vIHlpZWxkIHRoZSBwYXNzdGhyb3VnaFxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZvclBhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW5uYWJsZUFzc2lnbiBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cyBhcyBpbnB1dCwgZ290ICR7dHlwZW9mIGNodW5rfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2h1bmspLmZpbHRlcigoW2tleV0pID0+ICFtYXBwZXJLZXlzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGZpbHRlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlpZWxkIHRoZSBtYXBwZXIgb3V0cHV0XG4gICAgICAgIHlpZWxkIChhd2FpdCBmaXJzdE1hcHBlckNodW5rUHJvbWlzZSkudmFsdWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgbWFwcGVyT3V0cHV0KSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IFJ1bm5hYmxlQXNzaWduO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIFVzZWZ1bCBmb3Igc3RyZWFtaW5nLCBjYW4gYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFuZCBjaGFpbmVkIGJ5IGNhbGxpbmcgYHJ1bm5hYmxlLnBpY2soKTtgLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFJ1bm5hYmxlUGljayB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgaW5wdXREYXRhID0ge1xuICogICBuYW1lOiBcIkpvaG5cIixcbiAqICAgYWdlOiAzMCxcbiAqICAgY2l0eTogXCJOZXcgWW9ya1wiLFxuICogICBjb3VudHJ5OiBcIlVTQVwiLFxuICogICBlbWFpbDogXCJqb2huLmRvZUBleGFtcGxlLmNvbVwiLFxuICogICBwaG9uZTogXCIrMTIzNDU2Nzg5MFwiLFxuICogfTtcbiAqXG4gKiBjb25zdCBiYXNpY0luZm9SdW5uYWJsZSA9IG5ldyBSdW5uYWJsZVBpY2soW1wibmFtZVwiLCBcImNpdHlcIl0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgYmFzaWNJbmZvUnVubmFibGUuaW52b2tlKGlucHV0RGF0YSk7XG4gKlxuICogLy8geyBuYW1lOiAnSm9obicsIGNpdHk6ICdOZXcgWW9yaycgfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlUGljayBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVQaWNrXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBrZXlzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXlzID0gZmllbGRzLmtleXM7XG4gICAgfVxuICAgIGFzeW5jIF9waWNrKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXlzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRbdGhpcy5rZXlzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZCA9IHRoaXMua2V5c1xuICAgICAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gW2tleSwgaW5wdXRba2V5XV0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodikgPT4gdlsxXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiBwaWNrZWQubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogT2JqZWN0LmZyb21FbnRyaWVzKHBpY2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9waWNrLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWQgPSBhd2FpdCB0aGlzLl9waWNrKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChwaWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHBpY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVBpY2sgPSBSdW5uYWJsZVBpY2s7XG5jbGFzcyBSdW5uYWJsZVRvb2xMaWtlIGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAgICAgICAgUnVubmFibGVMYW1iZGEuZnJvbShhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbElucHV0O1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMi5faXNUb29sQ2FsbCkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQgPSBhd2FpdCB0aGlzLnNjaGVtYS5wYXJzZUFzeW5jKGlucHV0LmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdXRpbHNfanNfMi5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uKGBSZWNlaXZlZCB0b29sIGlucHV0IGRpZCBub3QgbWF0Y2ggZXhwZWN0ZWQgc2NoZW1hYCwgSlNPTi5zdHJpbmdpZnkoaW5wdXQuYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xJbnB1dDtcbiAgICAgICAgICAgIH0pLndpdGhDb25maWcoeyBydW5OYW1lOiBgJHtmaWVsZHMubmFtZX06cGFyc2VfaW5wdXRgIH0pLFxuICAgICAgICAgICAgZmllbGRzLmJvdW5kLFxuICAgICAgICBdKS53aXRoQ29uZmlnKHsgcnVuTmFtZTogZmllbGRzLm5hbWUgfSk7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGJvdW5kOiBzZXF1ZW5jZSxcbiAgICAgICAgICAgIGNvbmZpZzogZmllbGRzLmNvbmZpZyA/PyB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGZpZWxkcy5zY2hlbWE7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVRvb2xMaWtlXCI7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVRvb2xMaWtlID0gUnVubmFibGVUb29sTGlrZTtcbi8qKlxuICogR2l2ZW4gYSBydW5uYWJsZSBhbmQgYSBab2Qgc2NoZW1hLCBjb252ZXJ0IHRoZSBydW5uYWJsZSB0byBhIHRvb2wuXG4gKlxuICogQHRlbXBsYXRlIFJ1bklucHV0IFRoZSBpbnB1dCB0eXBlIGZvciB0aGUgcnVubmFibGUuXG4gKiBAdGVtcGxhdGUgUnVuT3V0cHV0IFRoZSBvdXRwdXQgdHlwZSBmb3IgdGhlIHJ1bm5hYmxlLlxuICpcbiAqIEBwYXJhbSB7UnVubmFibGU8UnVuSW5wdXQsIFJ1bk91dHB1dD59IHJ1bm5hYmxlIFRoZSBydW5uYWJsZSB0byBjb252ZXJ0IHRvIGEgdG9vbC5cbiAqIEBwYXJhbSBmaWVsZHNcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5kZXNjcmlwdGlvbl0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLiBGYWxscyBiYWNrIHRvIHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgWm9kIHNjaGVtYSBpZiBub3QgcHJvdmlkZWQsIG9yIHVuZGVmaW5lZCBpZiBuZWl0aGVyIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7ei5ab2RUeXBlPFJ1bklucHV0Pn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTx6LlpvZFR5cGU8UnVuSW5wdXQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFJ1bm5hYmxlVG9Ub29sKHJ1bm5hYmxlLCBmaWVsZHMpIHtcbiAgICBjb25zdCBuYW1lID0gZmllbGRzLm5hbWUgPz8gcnVubmFibGUuZ2V0TmFtZSgpO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uID8/IGZpZWxkcy5zY2hlbWE/LmRlc2NyaXB0aW9uO1xuICAgIGlmIChmaWVsZHMuc2NoZW1hLmNvbnN0cnVjdG9yID09PSB6b2RfMS56LlpvZFN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVG9vbExpa2Uoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2NoZW1hOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKGlucHV0KSA9PiBpbnB1dC5pbnB1dCksXG4gICAgICAgICAgICBib3VuZDogcnVubmFibGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVG9vbExpa2Uoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgc2NoZW1hOiBmaWVsZHMuc2NoZW1hLFxuICAgICAgICBib3VuZDogcnVubmFibGUsXG4gICAgfSk7XG59XG5leHBvcnRzLmNvbnZlcnRSdW5uYWJsZVRvVG9vbCA9IGNvbnZlcnRSdW5uYWJsZVRvVG9vbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/branch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableBranch = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnableBranch extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            (0, base_js_1._coerceToRunnable)(condition),\n            (0, base_js_1._coerceToRunnable)(runnable),\n        ]);\n        const defaultBranch = (0, base_js_1._coerceToRunnable)(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\nexports.RunnableBranch = RunnableBranch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2JyYW5jaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkUsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvYnJhbmNoLmNqcz9lMGNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcnVubmFibGUgYnJhbmNoLiBUaGUgUnVubmFibGVCcmFuY2ggaXNcbiAqIGluaXRpYWxpemVkIHdpdGggYW4gYXJyYXkgb2YgYnJhbmNoZXMgYW5kIGEgZGVmYXVsdCBicmFuY2guIFdoZW4gaW52b2tlZCxcbiAqIGl0IGV2YWx1YXRlcyB0aGUgY29uZGl0aW9uIG9mIGVhY2ggYnJhbmNoIGluIG9yZGVyIGFuZCBleGVjdXRlcyB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgYnJhbmNoIGlmIHRoZSBjb25kaXRpb24gaXMgdHJ1ZS4gSWYgbm9uZSBvZiB0aGUgY29uZGl0aW9uc1xuICogYXJlIHRydWUsIGl0IGV4ZWN1dGVzIHRoZSBkZWZhdWx0IGJyYW5jaC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBicmFuY2ggPSBSdW5uYWJsZUJyYW5jaC5mcm9tKFtcbiAqICAgW1xuICogICAgICh4OiB7IHRvcGljOiBzdHJpbmc7IHF1ZXN0aW9uOiBzdHJpbmcgfSkgPT5cbiAqICAgICAgIHgudG9waWMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImFudGhyb3BpY1wiKSxcbiAqICAgICBhbnRocm9waWNDaGFpbixcbiAqICAgXSxcbiAqICAgW1xuICogICAgICh4OiB7IHRvcGljOiBzdHJpbmc7IHF1ZXN0aW9uOiBzdHJpbmcgfSkgPT5cbiAqICAgICAgIHgudG9waWMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImxhbmdjaGFpblwiKSxcbiAqICAgICBsYW5nQ2hhaW5DaGFpbixcbiAqICAgXSxcbiAqICAgZ2VuZXJhbENoYWluLFxuICogXSk7XG4gKlxuICogY29uc3QgZnVsbENoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAge1xuICogICAgIHRvcGljOiBjbGFzc2lmaWNhdGlvbkNoYWluLFxuICogICAgIHF1ZXN0aW9uOiAoaW5wdXQ6IHsgcXVlc3Rpb246IHN0cmluZyB9KSA9PiBpbnB1dC5xdWVzdGlvbixcbiAqICAgfSxcbiAqICAgYnJhbmNoLFxuICogXSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVsbENoYWluLmludm9rZSh7XG4gKiAgIHF1ZXN0aW9uOiBcImhvdyBkbyBJIHVzZSBMYW5nQ2hhaW4/XCIsXG4gKiB9KTtcbiAqIGBgYFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgUnVubmFibGVCcmFuY2ggZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUJyYW5jaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJyYW5jaGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSBmaWVsZHMuYnJhbmNoZXM7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGZpZWxkcy5kZWZhdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGluc3RhbnRpYXRpbmcgYSBSdW5uYWJsZUJyYW5jaCBmcm9tXG4gICAgICogUnVubmFibGVMaWtlcyAob2JqZWN0cywgZnVuY3Rpb25zLCBvciBSdW5uYWJsZXMpLlxuICAgICAqXG4gICAgICogRWFjaCBpdGVtIGluIHRoZSBpbnB1dCBleGNlcHQgZm9yIHRoZSBsYXN0IG9uZSBzaG91bGQgYmUgYVxuICAgICAqIHR1cGxlIHdpdGggdHdvIGl0ZW1zLiBUaGUgZmlyc3QgaXMgYSBcImNvbmRpdGlvblwiIFJ1bm5hYmxlTGlrZSB0aGF0XG4gICAgICogcmV0dXJucyBcInRydWVcIiBpZiB0aGUgc2Vjb25kIFJ1bm5hYmxlTGlrZSBpbiB0aGUgdHVwbGUgc2hvdWxkIHJ1bi5cbiAgICAgKlxuICAgICAqIFRoZSBmaW5hbCBpdGVtIGluIHRoZSBpbnB1dCBzaG91bGQgYmUgYSBSdW5uYWJsZUxpa2UgdGhhdCBhY3RzIGFzIGFcbiAgICAgKiBkZWZhdWx0IGJyYW5jaCBpZiBubyBvdGhlciBicmFuY2hlcyBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBSdW5uYWJsZUJyYW5jaCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBicmFuY2ggPSBSdW5uYWJsZUJyYW5jaC5mcm9tKFtcbiAgICAgKiAgIFsoeDogbnVtYmVyKSA9PiB4ID4gMCwgKHg6IG51bWJlcikgPT4geCArIDFdLFxuICAgICAqICAgWyh4OiBudW1iZXIpID0+IHggPCAwLCAoeDogbnVtYmVyKSA9PiB4IC0gMV0sXG4gICAgICogICAoeDogbnVtYmVyKSA9PiB4XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGJyYW5jaGVzIEFuIGFycmF5IHdoZXJlIHRoZSBldmVyeSBpdGVtIGV4Y2VwdCB0aGUgbGFzdCBpcyBhIHR1cGxlIG9mIFtjb25kaXRpb24sIHJ1bm5hYmxlXVxuICAgICAqICAgcGFpcnMuIFRoZSBsYXN0IGl0ZW0gaXMgYSBkZWZhdWx0IHJ1bm5hYmxlIHdoaWNoIGlzIGludm9rZWQgaWYgbm8gb3RoZXIgY29uZGl0aW9uIG1hdGNoZXMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCcmFuY2guXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbShicmFuY2hlcykge1xuICAgICAgICBpZiAoYnJhbmNoZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVCcmFuY2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGJyYW5jaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBicmFuY2hMaWtlcyA9IGJyYW5jaGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgY29uc3QgY29lcmNlZEJyYW5jaGVzID0gYnJhbmNoTGlrZXMubWFwKChbY29uZGl0aW9uLCBydW5uYWJsZV0pID0+IFtcbiAgICAgICAgICAgICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvUnVubmFibGUpKGNvbmRpdGlvbiksXG4gICAgICAgICAgICAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb1J1bm5hYmxlKShydW5uYWJsZSksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0QnJhbmNoID0gKDAsIGJhc2VfanNfMS5fY29lcmNlVG9SdW5uYWJsZSkoYnJhbmNoZXNbYnJhbmNoZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgYnJhbmNoZXM6IGNvZXJjZWRCcmFuY2hlcyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRCcmFuY2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBbY29uZGl0aW9uLCBicmFuY2hSdW5uYWJsZV0gPSB0aGlzLmJyYW5jaGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSBhd2FpdCBjb25kaXRpb24uaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGNvbmRpdGlvbjoke2kgKyAxfWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYnJhbmNoUnVubmFibGUuaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBicmFuY2g6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuZGVmYXVsdC5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChcImJyYW5jaDpkZWZhdWx0XCIpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9EaWN0KShpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnPy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2NvbmRpdGlvbiwgYnJhbmNoUnVubmFibGVdID0gdGhpcy5icmFuY2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGF3YWl0IGNvbmRpdGlvbi5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGNvbmRpdGlvbjoke2kgKyAxfWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gYXdhaXQgYnJhbmNoUnVubmFibGUuc3RyZWFtKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgYnJhbmNoOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLmRlZmF1bHQuc3RyZWFtKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKFwiYnJhbmNoOmRlZmF1bHRcIiksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChmaW5hbE91dHB1dCA/PyB7fSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchConfig = exports.ensureConfig = exports.mergeConfigs = exports.getCallbackManagerForConfig = exports.DEFAULT_RECURSION_LIMIT = void 0;\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nexports.DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexports.getCallbackManagerForConfig = getCallbackManagerForConfig;\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new manager_js_1.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nexports.mergeConfigs = mergeConfigs;\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nfunction ensureConfig(config) {\n    const implicitConfig = index_js_1.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\nexports.ensureConfig = ensureConfig;\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\nexports.patchConfig = patchConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsbUNBQW1DLEdBQUcsK0JBQStCO0FBQ3pJLHFCQUFxQixtQkFBTyxDQUFDLGlHQUEwQjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLDJFQUEyRSxJQUFJO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvY29uZmlnLmNqcz8yZjg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRjaENvbmZpZyA9IGV4cG9ydHMuZW5zdXJlQ29uZmlnID0gZXhwb3J0cy5tZXJnZUNvbmZpZ3MgPSBleHBvcnRzLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyA9IGV4cG9ydHMuREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSB2b2lkIDA7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmV4cG9ydHMuREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSAyNTtcbmFzeW5jIGZ1bmN0aW9uIGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5fY29uZmlndXJlU3luYyhjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG59XG5leHBvcnRzLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyA9IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZztcbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyguLi5jb25maWdzKSB7XG4gICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gY2FsbCBlbnN1cmVDb25maWcgb24gdGhlIGVtcHR5IHN0YXRlIGhlcmUgYXMgdGhpcyBtYXkgY2F1c2VcbiAgICAvLyBkb3VibGUgbG9hZGluZyBvZiBjYWxsYmFja3MgaWYgYXN5bmMgbG9jYWwgc3RvcmFnZSBpcyBiZWluZyB1c2VkLlxuICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29uZmlncy5maWx0ZXIoKGMpID0+ICEhYykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IHsgLi4uY29weVtrZXldLCAuLi5vcHRpb25zW2tleV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0YWdzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlS2V5cyA9IGNvcHlba2V5XSA/PyBbXTtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBbLi4ubmV3IFNldChiYXNlS2V5cy5jb25jYXQob3B0aW9uc1trZXldID8/IFtdKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNvbmZpZ3VyYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IE1hdGgubWluKGNvcHkudGltZW91dCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwic2lnbmFsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29weS5zaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNhbGxiYWNrc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUNhbGxiYWNrcyA9IGNvcHkuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVkQ2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIGNhbiBiZSBlaXRoZXIgdW5kZWZpbmVkLCBBcnJheTxoYW5kbGVyPiBvciBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgLy8gc28gbWVyZ2luZyB0d28gY2FsbGJhY2tzIHZhbHVlcyBoYXMgNiBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVkQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gcHJvdmlkZWRDYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiYXNlQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBiYXNlQ2FsbGJhY2tzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlQ2FsbGJhY2tzIGlzIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlciA9IGJhc2VDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcigoMCwgbWFuYWdlcl9qc18xLmVuc3VyZUhhbmRsZXIpKGNhbGxiYWNrKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IG1hbmFnZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZWRDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gcHJvdmlkZWRDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKCgwLCBtYW5hZ2VyX2pzXzEuZW5zdXJlSGFuZGxlcikoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYWxzbyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbmV3IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIocHJvdmlkZWRDYWxsYmFja3MuX3BhcmVudFJ1bklkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnM6IGJhc2VDYWxsYmFja3MuaGFuZGxlcnMuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmhhbmRsZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0YWJsZUhhbmRsZXJzOiBiYXNlQ2FsbGJhY2tzLmluaGVyaXRhYmxlSGFuZGxlcnMuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmluaGVyaXRhYmxlSGFuZGxlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IEFycmF5LmZyb20obmV3IFNldChiYXNlQ2FsbGJhY2tzLnRhZ3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLnRhZ3MpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGFibGVUYWdzOiBBcnJheS5mcm9tKG5ldyBTZXQoYmFzZUNhbGxiYWNrcy5pbmhlcml0YWJsZVRhZ3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzLmluaGVyaXRhYmxlVGFncykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlQ2FsbGJhY2tzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm92aWRlZENhbGxiYWNrcy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBjb3B5W3R5cGVkS2V5XSA9IG9wdGlvbnNbdHlwZWRLZXldID8/IGNvcHlbdHlwZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuZXhwb3J0cy5tZXJnZUNvbmZpZ3MgPSBtZXJnZUNvbmZpZ3M7XG5jb25zdCBQUklNSVRJVkVTID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwYXNzZWQgY29uZmlnIGlzIGFuIG9iamVjdCB3aXRoIGFsbCByZXF1aXJlZCBrZXlzIHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBpbXBsaWNpdENvbmZpZyA9IGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xuICAgIGxldCBlbXB0eSA9IHtcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgcmVjdXJzaW9uTGltaXQ6IDI1LFxuICAgICAgICBydW5JZDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgaWYgKGltcGxpY2l0Q29uZmlnKSB7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJ1bklkIGFuZCBydW5OYW1lIHRvIGJlIGxvYWRlZCBpbXBsaWNpdGx5LCBhcyB0aGlzIGNhbiBjYXVzZVxuICAgICAgICAvLyBjaGlsZCBydW5zIHRvIGltcHJvcGVybHkgaW5oZXJpdCB0aGVpciBwYXJlbnRzJyBydW4gaWRzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIHJ1bk5hbWUsIC4uLnJlc3QgfSA9IGltcGxpY2l0Q29uZmlnO1xuICAgICAgICBlbXB0eSA9IE9iamVjdC5lbnRyaWVzKHJlc3QpLnJlZHVjZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGN1cnJlbnRDb25maWcsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgICAgICB9LCBlbXB0eSk7XG4gICAgfVxuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZW1wdHkgPSBPYmplY3QuZW50cmllcyhjb25maWcpLnJlZHVjZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGN1cnJlbnRDb25maWcsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgICAgICB9LCBlbXB0eSk7XG4gICAgfVxuICAgIGlmIChlbXB0eT8uY29uZmlndXJhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVtcHR5LmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgIGlmIChQUklNSVRJVkVTLmhhcyh0eXBlb2YgZW1wdHkuY29uZmlndXJhYmxlW2tleV0pICYmXG4gICAgICAgICAgICAgICAgIWVtcHR5Lm1ldGFkYXRhPy5ba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1wdHkubWV0YWRhdGFba2V5XSA9IGVtcHR5LmNvbmZpZ3VyYWJsZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbXB0eS50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGVtcHR5LnRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KGVtcHR5LnRpbWVvdXQpO1xuICAgICAgICBpZiAoZW1wdHkuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBlbXB0eS5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW2VtcHR5LnNpZ25hbCwgdGltZW91dFNpZ25hbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW1wdHkuc2lnbmFsID0gdGltZW91dFNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZW1wdHkudGltZW91dDtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xufVxuZXhwb3J0cy5lbnN1cmVDb25maWcgPSBlbnN1cmVDb25maWc7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHBhdGNoZXMgcnVubmFibGUgY29uZmlncyB3aXRoIHVwZGF0ZWQgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gcGF0Y2hDb25maWcoY29uZmlnID0ge30sIHsgY2FsbGJhY2tzLCBtYXhDb25jdXJyZW5jeSwgcmVjdXJzaW9uTGltaXQsIHJ1bk5hbWUsIGNvbmZpZ3VyYWJsZSwgcnVuSWQsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5ld0NvbmZpZyA9IGVuc3VyZUNvbmZpZyhjb25maWcpO1xuICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcmVwbGFjaW5nIGNhbGxiYWNrcyB3ZSBuZWVkIHRvIHVuc2V0IHJ1bk5hbWVcbiAgICAgICAgICogc2luY2UgdGhhdCBzaG91bGQgYXBwbHkgb25seSB0byB0aGUgc2FtZSBydW4gYXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5OYW1lO1xuICAgICAgICBuZXdDb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBpZiAocmVjdXJzaW9uTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucmVjdXJzaW9uTGltaXQgPSByZWN1cnNpb25MaW1pdDtcbiAgICB9XG4gICAgaWYgKG1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gICAgfVxuICAgIGlmIChydW5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLnJ1bk5hbWUgPSBydW5OYW1lO1xuICAgIH1cbiAgICBpZiAoY29uZmlndXJhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSA9IHsgLi4ubmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSwgLi4uY29uZmlndXJhYmxlIH07XG4gICAgfVxuICAgIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdDb25maWcucnVuSWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdDb25maWc7XG59XG5leHBvcnRzLnBhdGNoQ29uZmlnID0gcGF0Y2hDb25maWc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graph = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst graph_mermaid_js_1 = __webpack_require__(/*! ./graph_mermaid.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\");\nfunction nodeDataStr(id, data) {\n    if (id !== undefined && !(0, uuid_1.validate)(id)) {\n        return id;\n    }\n    else if ((0, utils_js_1.isRunnableInterface)(data)) {\n        try {\n            let dataStr = data.getName();\n            dataStr = dataStr.startsWith(\"Runnable\")\n                ? dataStr.slice(\"Runnable\".length)\n                : dataStr;\n            return dataStr;\n        }\n        catch (error) {\n            return data.getName();\n        }\n    }\n    else {\n        return data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data implements Runnable\n    if ((0, utils_js_1.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0, zod_to_json_schema_1.zodToJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor(params) {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.nodes = params?.nodes ?? this.nodes;\n        this.edges = params?.edges ?? this.edges;\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0, uuid_1.validate)(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id ?? (0, uuid_1.v4)();\n        const node = {\n            id: nodeId,\n            data,\n            name: nodeDataStr(id, data),\n            metadata,\n        };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        return _firstNode(this);\n    }\n    lastNode() {\n        return _lastNode(this);\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(uuid_1.validate)) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode && _firstNode(this, [firstNode.id])) {\n            this.removeNode(firstNode);\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode && _lastNode(this, [lastNode.id])) {\n            this.removeNode(lastNode);\n        }\n    }\n    /**\n     * Return a new graph with all nodes re-identified,\n     * using their unique, readable names where possible.\n     */\n    reid() {\n        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));\n        const nodeLabelCounts = new Map();\n        Object.values(nodeLabels).forEach((label) => {\n            nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n        });\n        const getNodeId = (nodeId) => {\n            const label = nodeLabels[nodeId];\n            if ((0, uuid_1.validate)(nodeId) && nodeLabelCounts.get(label) === 1) {\n                return label;\n            }\n            else {\n                return nodeId;\n            }\n        };\n        return new Graph({\n            nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [\n                getNodeId(id),\n                { ...node, id: getNodeId(id) },\n            ])),\n            edges: this.edges.map((edge) => ({\n                ...edge,\n                source: getNodeId(edge.source),\n                target: getNodeId(edge.target),\n            })),\n        });\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = {\n            default: \"fill:#f2f0ff,line-height:1.2\",\n            first: \"fill-opacity:0\",\n            last: \"fill:#bfb6fc\",\n        }, wrapLabelNWords, } = params ?? {};\n        const graph = this.reid();\n        const firstNode = graph.firstNode();\n        const lastNode = graph.lastNode();\n        return (0, graph_mermaid_js_1.drawMermaid)(graph.nodes, graph.edges, {\n            firstNode: firstNode?.id,\n            lastNode: lastNode?.id,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return (0, graph_mermaid_js_1.drawMermaidPng)(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\nexports.Graph = Graph;\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n    const targets = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.source))\n        .map((edge) => edge.target));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !targets.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n    const sources = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.target))\n        .map((edge) => edge.source));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !sources.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsNkJBQTZCLG1CQUFPLENBQUMscUZBQW9CO0FBQ3pELGVBQWUsbUJBQU8sQ0FBQyw4REFBTTtBQUM3QixtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBYTtBQUN4QywyQkFBMkIsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1RkFBdUY7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLEdBQUcsR0FBRztBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakUscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9ncmFwaC5janM/NzMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR3JhcGggPSB2b2lkIDA7XG5jb25zdCB6b2RfdG9fanNvbl9zY2hlbWFfMSA9IHJlcXVpcmUoXCJ6b2QtdG8tanNvbi1zY2hlbWFcIik7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5jb25zdCBncmFwaF9tZXJtYWlkX2pzXzEgPSByZXF1aXJlKFwiLi9ncmFwaF9tZXJtYWlkLmNqc1wiKTtcbmZ1bmN0aW9uIG5vZGVEYXRhU3RyKGlkLCBkYXRhKSB7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dWlkXzEudmFsaWRhdGUpKGlkKSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc19qc18xLmlzUnVubmFibGVJbnRlcmZhY2UpKGRhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGF0YVN0ciA9IGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgZGF0YVN0ciA9IGRhdGFTdHIuc3RhcnRzV2l0aChcIlJ1bm5hYmxlXCIpXG4gICAgICAgICAgICAgICAgPyBkYXRhU3RyLnNsaWNlKFwiUnVubmFibGVcIi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBkYXRhU3RyO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhLm5hbWUgPz8gXCJVbmtub3duU2NoZW1hXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZURhdGFKc29uKG5vZGUpIHtcbiAgICAvLyBpZiBub2RlLmRhdGEgaW1wbGVtZW50cyBSdW5uYWJsZVxuICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc1J1bm5hYmxlSW50ZXJmYWNlKShub2RlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJ1bm5hYmxlXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGUuZGF0YS5sY19pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLmRhdGEuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInNjaGVtYVwiLFxuICAgICAgICAgICAgZGF0YTogeyAuLi4oMCwgem9kX3RvX2pzb25fc2NoZW1hXzEuem9kVG9Kc29uU2NoZW1hKShub2RlLmRhdGEuc2NoZW1hKSwgdGl0bGU6IG5vZGUuZGF0YS5uYW1lIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVkZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHBhcmFtcz8ubm9kZXMgPz8gdGhpcy5ub2RlcztcbiAgICAgICAgdGhpcy5lZGdlcyA9IHBhcmFtcz8uZWRnZXMgPz8gdGhpcy5lZGdlcztcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgZ3JhcGggdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBmb3JtYXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHN0YWJsZU5vZGVJZHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVOb2RlSWRzW25vZGUuaWRdID0gKDAsIHV1aWRfMS52YWxpZGF0ZSkobm9kZS5pZCkgPyBpIDogbm9kZS5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5tYXAoKG5vZGUpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IHN0YWJsZU5vZGVJZHNbbm9kZS5pZF0sXG4gICAgICAgICAgICAgICAgLi4ubm9kZURhdGFKc29uKG5vZGUpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZWRnZXM6IHRoaXMuZWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzdGFibGVOb2RlSWRzW2VkZ2Uuc291cmNlXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzdGFibGVOb2RlSWRzW2VkZ2UudGFyZ2V0XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRnZS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGF0YSA9IGVkZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlZGdlLmNvbmRpdGlvbmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uZGl0aW9uYWwgPSBlZGdlLmNvbmRpdGlvbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGROb2RlKGRhdGEsIGlkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubm9kZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIGlkICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUlkID0gaWQgPz8gKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbmFtZTogbm9kZURhdGFTdHIoaWQsIGRhdGEpLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIG5vZGVzIG1hcFxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5lZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gbm9kZS5pZCAmJiBlZGdlLnRhcmdldCAhPT0gbm9kZS5pZCk7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIGRhdGEsIGNvbmRpdGlvbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3NvdXJjZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugbm9kZSAke3NvdXJjZS5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZXNbdGFyZ2V0LmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBub2RlICR7dGFyZ2V0LmlkfSBub3QgaW4gZ3JhcGhgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UuaWQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZmlyc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gX2ZpcnN0Tm9kZSh0aGlzKTtcbiAgICB9XG4gICAgbGFzdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBfbGFzdE5vZGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbGwgbm9kZXMgYW5kIGVkZ2VzIGZyb20gYW5vdGhlciBncmFwaC5cbiAgICAgKiBOb3RlIHRoaXMgZG9lc24ndCBjaGVjayBmb3IgZHVwbGljYXRlcywgbm9yIGRvZXMgaXQgY29ubmVjdCB0aGUgZ3JhcGhzLlxuICAgICAqL1xuICAgIGV4dGVuZChncmFwaCwgcHJlZml4ID0gXCJcIikge1xuICAgICAgICBsZXQgZmluYWxQcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBpZiAobm9kZUlkcy5ldmVyeSh1dWlkXzEudmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBmaW5hbFByZWZpeCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByZWZpeCA/IGAke2ZpbmFsUHJlZml4fToke2lkfWAgOiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ3JhcGgubm9kZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1twcmVmaXhlZChrZXkpXSA9IHsgLi4udmFsdWUsIGlkOiBwcmVmaXhlZChrZXkpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXdFZGdlcyA9IGdyYXBoLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5lZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogcHJlZml4ZWQoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcHJlZml4ZWQoZWRnZS50YXJnZXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBhbGwgZWRnZXMgZnJvbSB0aGUgb3RoZXIgZ3JhcGhcbiAgICAgICAgdGhpcy5lZGdlcyA9IFsuLi50aGlzLmVkZ2VzLCAuLi5uZXdFZGdlc107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gZ3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBncmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmlyc3QgPyB7IGlkOiBwcmVmaXhlZChmaXJzdC5pZCksIGRhdGE6IGZpcnN0LmRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhc3QgPyB7IGlkOiBwcmVmaXhlZChsYXN0LmlkKSwgZGF0YTogbGFzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRyaW1GaXJzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZmlyc3ROb2RlKCk7XG4gICAgICAgIGlmIChmaXJzdE5vZGUgJiYgX2ZpcnN0Tm9kZSh0aGlzLCBbZmlyc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShmaXJzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaW1MYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlKCk7XG4gICAgICAgIGlmIChsYXN0Tm9kZSAmJiBfbGFzdE5vZGUodGhpcywgW2xhc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGdyYXBoIHdpdGggYWxsIG5vZGVzIHJlLWlkZW50aWZpZWQsXG4gICAgICogdXNpbmcgdGhlaXIgdW5pcXVlLCByZWFkYWJsZSBuYW1lcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICByZWlkKCkge1xuICAgICAgICBjb25zdCBub2RlTGFiZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykubWFwKChub2RlKSA9PiBbbm9kZS5pZCwgbm9kZS5uYW1lXSkpO1xuICAgICAgICBjb25zdCBub2RlTGFiZWxDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobm9kZUxhYmVscykuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAgIG5vZGVMYWJlbENvdW50cy5zZXQobGFiZWwsIChub2RlTGFiZWxDb3VudHMuZ2V0KGxhYmVsKSB8fCAwKSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZUlkID0gKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBub2RlTGFiZWxzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoKDAsIHV1aWRfMS52YWxpZGF0ZSkobm9kZUlkKSAmJiBub2RlTGFiZWxDb3VudHMuZ2V0KGxhYmVsKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGgoe1xuICAgICAgICAgICAgbm9kZXM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLm5vZGVzKS5tYXAoKFtpZCwgbm9kZV0pID0+IFtcbiAgICAgICAgICAgICAgICBnZXROb2RlSWQoaWQpLFxuICAgICAgICAgICAgICAgIHsgLi4ubm9kZSwgaWQ6IGdldE5vZGVJZChpZCkgfSxcbiAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0Tm9kZUlkKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldE5vZGVJZChlZGdlLnRhcmdldCksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3TWVybWFpZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyB3aXRoU3R5bGVzLCBjdXJ2ZVN0eWxlLCBub2RlQ29sb3JzID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogXCJmaWxsOiNmMmYwZmYsbGluZS1oZWlnaHQ6MS4yXCIsXG4gICAgICAgICAgICBmaXJzdDogXCJmaWxsLW9wYWNpdHk6MFwiLFxuICAgICAgICAgICAgbGFzdDogXCJmaWxsOiNiZmI2ZmNcIixcbiAgICAgICAgfSwgd3JhcExhYmVsTldvcmRzLCB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICBjb25zdCBncmFwaCA9IHRoaXMucmVpZCgpO1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBncmFwaC5maXJzdE5vZGUoKTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBncmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gKDAsIGdyYXBoX21lcm1haWRfanNfMS5kcmF3TWVybWFpZCkoZ3JhcGgubm9kZXMsIGdyYXBoLmVkZ2VzLCB7XG4gICAgICAgICAgICBmaXJzdE5vZGU6IGZpcnN0Tm9kZT8uaWQsXG4gICAgICAgICAgICBsYXN0Tm9kZTogbGFzdE5vZGU/LmlkLFxuICAgICAgICAgICAgd2l0aFN0eWxlcyxcbiAgICAgICAgICAgIGN1cnZlU3R5bGUsXG4gICAgICAgICAgICBub2RlQ29sb3JzLFxuICAgICAgICAgICAgd3JhcExhYmVsTldvcmRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZHJhd01lcm1haWRQbmcocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1lcm1haWRTeW50YXggPSB0aGlzLmRyYXdNZXJtYWlkKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoMCwgZ3JhcGhfbWVybWFpZF9qc18xLmRyYXdNZXJtYWlkUG5nKShtZXJtYWlkU3ludGF4LCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHBhcmFtcz8uYmFja2dyb3VuZENvbG9yLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoID0gR3JhcGg7XG4vKipcbiAqIEZpbmQgdGhlIHNpbmdsZSBub2RlIHRoYXQgaXMgbm90IGEgdGFyZ2V0IG9mIGFueSBlZGdlLlxuICogRXhjbHVkZSBub2Rlcy9zb3VyY2VzIHdpdGggaWRzIGluIHRoZSBleGNsdWRlIGxpc3QuXG4gKiBJZiB0aGVyZSBpcyBubyBzdWNoIG5vZGUsIG9yIHRoZXJlIGFyZSBtdWx0aXBsZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIFdoZW4gZHJhd2luZyB0aGUgZ3JhcGgsIHRoaXMgbm9kZSB3b3VsZCBiZSB0aGUgb3JpZ2luLlxuICovXG5mdW5jdGlvbiBfZmlyc3ROb2RlKGdyYXBoLCBleGNsdWRlID0gW10pIHtcbiAgICBjb25zdCB0YXJnZXRzID0gbmV3IFNldChncmFwaC5lZGdlc1xuICAgICAgICAuZmlsdGVyKChlZGdlKSA9PiAhZXhjbHVkZS5pbmNsdWRlcyhlZGdlLnNvdXJjZSkpXG4gICAgICAgIC5tYXAoKGVkZ2UpID0+IGVkZ2UudGFyZ2V0KSk7XG4gICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykpIHtcbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKG5vZGUuaWQpICYmICF0YXJnZXRzLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQubGVuZ3RoID09PSAxID8gZm91bmRbMF0gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEZpbmQgdGhlIHNpbmdsZSBub2RlIHRoYXQgaXMgbm90IGEgc291cmNlIG9mIGFueSBlZGdlLlxuICogRXhjbHVkZSBub2Rlcy90YXJnZXRzIHdpdGggaWRzIGluIHRoZSBleGNsdWRlIGxpc3QuXG4gKiBJZiB0aGVyZSBpcyBubyBzdWNoIG5vZGUsIG9yIHRoZXJlIGFyZSBtdWx0aXBsZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIFdoZW4gZHJhd2luZyB0aGUgZ3JhcGgsIHRoaXMgbm9kZSB3b3VsZCBiZSB0aGUgZGVzdGluYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9sYXN0Tm9kZShncmFwaCwgZXhjbHVkZSA9IFtdKSB7XG4gICAgY29uc3Qgc291cmNlcyA9IG5ldyBTZXQoZ3JhcGguZWRnZXNcbiAgICAgICAgLmZpbHRlcigoZWRnZSkgPT4gIWV4Y2x1ZGUuaW5jbHVkZXMoZWRnZS50YXJnZXQpKVxuICAgICAgICAubWFwKChlZGdlKSA9PiBlZGdlLnNvdXJjZSkpO1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpKSB7XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyhub2RlLmlkKSAmJiAhc291cmNlcy5oYXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA9PT0gMSA/IGZvdW5kWzBdIDogdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawMermaidPng = exports.drawMermaid = void 0;\nfunction _escapeNodeLabel(nodeLabel) {\n    // Escapes the node label for Mermaid syntax.\n    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\nfunction _generateMermaidGraphStyles(nodeColors) {\n    let styles = \"\";\n    for (const [className, color] of Object.entries(nodeColors)) {\n        styles += `\\tclassDef ${className} ${color};\\n`;\n    }\n    return styles;\n}\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nfunction drawMermaid(nodes, edges, config) {\n    const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n    // Initialize Mermaid graph configuration\n    let mermaidGraph = withStyles\n        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n        : \"graph TD;\\n\";\n    if (withStyles) {\n        // Node formatting templates\n        const defaultClassLabel = \"default\";\n        const formatDict = {\n            [defaultClassLabel]: \"{0}({1})\",\n        };\n        if (firstNode !== undefined) {\n            formatDict[firstNode] = \"{0}([{1}]):::first\";\n        }\n        if (lastNode !== undefined) {\n            formatDict[lastNode] = \"{0}([{1}]):::last\";\n        }\n        // Add nodes to the graph\n        for (const [key, node] of Object.entries(nodes)) {\n            const nodeName = node.name.split(\":\").pop() ?? \"\";\n            const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char))\n                ? `<p>${nodeName}</p>`\n                : nodeName;\n            let finalLabel = label;\n            if (Object.keys(node.metadata ?? {}).length) {\n                finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n                    .map(([k, v]) => `${k} = ${v}`)\n                    .join(\"\\n\")}</em></small>`;\n            }\n            const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n                .replace(\"{0}\", _escapeNodeLabel(key))\n                .replace(\"{1}\", finalLabel);\n            mermaidGraph += `\\t${nodeLabel}\\n`;\n        }\n    }\n    // Group edges by their common prefixes\n    const edgeGroups = {};\n    for (const edge of edges) {\n        const srcParts = edge.source.split(\":\");\n        const tgtParts = edge.target.split(\":\");\n        const commonPrefix = srcParts\n            .filter((src, i) => src === tgtParts[i])\n            .join(\":\");\n        if (!edgeGroups[commonPrefix]) {\n            edgeGroups[commonPrefix] = [];\n        }\n        edgeGroups[commonPrefix].push(edge);\n    }\n    const seenSubgraphs = new Set();\n    function addSubgraph(edges, prefix) {\n        const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n        if (prefix && !selfLoop) {\n            const subgraph = prefix.split(\":\").pop();\n            if (seenSubgraphs.has(subgraph)) {\n                throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n                    \"you're reusing a subgraph node with the same name. \" +\n                    \"Please adjust your graph to have subgraph nodes with unique names.\");\n            }\n            seenSubgraphs.add(subgraph);\n            mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n        }\n        for (const edge of edges) {\n            const { source, target, data, conditional } = edge;\n            let edgeLabel = \"\";\n            if (data !== undefined) {\n                let edgeData = data;\n                const words = edgeData.split(\" \");\n                if (words.length > wrapLabelNWords) {\n                    edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words\n                        .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                        .join(\" \")).join(\"&nbsp;<br>&nbsp;\");\n                }\n                edgeLabel = conditional\n                    ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n                    : ` -- &nbsp;${edgeData}&nbsp; --> `;\n            }\n            else {\n                edgeLabel = conditional ? \" -.-> \" : \" --> \";\n            }\n            mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n        }\n        // Recursively add nested subgraphs\n        for (const nestedPrefix in edgeGroups) {\n            if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n                addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n            }\n        }\n        if (prefix && !selfLoop) {\n            mermaidGraph += \"\\tend\\n\";\n        }\n    }\n    // Start with the top-level edges (no common prefix)\n    addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n    // Add remaining subgraphs\n    for (const prefix in edgeGroups) {\n        if (!prefix.includes(\":\") && prefix !== \"\") {\n            addSubgraph(edgeGroups[prefix], prefix);\n        }\n    }\n    // Add custom styles for nodes\n    if (withStyles) {\n        mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n    }\n    return mermaidGraph;\n}\nexports.drawMermaid = drawMermaid;\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n */\nasync function drawMermaidPng(mermaidSyntax, config) {\n    let { backgroundColor = \"white\" } = config ?? {};\n    // Use btoa for compatibility, assume ASCII\n    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n    // Check if the background color is a hexadecimal color code using regex\n    if (backgroundColor !== undefined) {\n        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n        if (!hexColorPattern.test(backgroundColor)) {\n            backgroundColor = `!${backgroundColor}`;\n        }\n    }\n    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;\n    const res = await fetch(imageUrl);\n    if (!res.ok) {\n        throw new Error([\n            `Failed to render the graph using the Mermaid.INK API.`,\n            `Status code: ${res.status}`,\n            `Status text: ${res.statusText}`,\n        ].join(\"\\n\"));\n    }\n    const content = await res.blob();\n    return content;\n}\nexports.drawMermaidPng = drawMermaidPng;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoX21lcm1haWQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsRUFBRSxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrR0FBa0c7QUFDOUc7QUFDQTtBQUNBLGNBQWMsT0FBTyxjQUFjLFlBQVksV0FBVyxJQUFJLGFBQWE7QUFDM0Usb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUUsRUFBRSxFQUFFO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxHQUFHLEVBQUU7QUFDN0M7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLEdBQUcsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxpREFBaUQsa0NBQWtDO0FBQ25GLHdDQUF3QyxHQUFHLElBQUksRUFBRTtBQUNqRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDJCQUEyQixFQUFFO0FBQzdCLDJCQUEyQixFQUFFO0FBQzdCLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtREFBbUQ7QUFDL0Y7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0EsaUNBQWlDLEVBQUUsU0FBUyxPQUFPO0FBQ25ELGlDQUFpQyxFQUFFLFNBQVMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUIsRUFBRSxVQUFVLEVBQUUsMEJBQTBCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxFQUFFLElBQUk7QUFDMUQ7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCLFdBQVcsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvZ3JhcGhfbWVybWFpZC5janM/M2M5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZHJhd01lcm1haWRQbmcgPSBleHBvcnRzLmRyYXdNZXJtYWlkID0gdm9pZCAwO1xuZnVuY3Rpb24gX2VzY2FwZU5vZGVMYWJlbChub2RlTGFiZWwpIHtcbiAgICAvLyBFc2NhcGVzIHRoZSBub2RlIGxhYmVsIGZvciBNZXJtYWlkIHN5bnRheC5cbiAgICByZXR1cm4gbm9kZUxhYmVsLnJlcGxhY2UoL1teYS16QS1aLV8wLTldL2csIFwiX1wiKTtcbn1cbmNvbnN0IE1BUktET1dOX1NQRUNJQUxfQ0hBUlMgPSBbXCIqXCIsIFwiX1wiLCBcImBcIl07XG5mdW5jdGlvbiBfZ2VuZXJhdGVNZXJtYWlkR3JhcGhTdHlsZXMobm9kZUNvbG9ycykge1xuICAgIGxldCBzdHlsZXMgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgW2NsYXNzTmFtZSwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGVDb2xvcnMpKSB7XG4gICAgICAgIHN0eWxlcyArPSBgXFx0Y2xhc3NEZWYgJHtjbGFzc05hbWV9ICR7Y29sb3J9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG59XG4vKipcbiAqIERyYXdzIGEgTWVybWFpZCBncmFwaCB1c2luZyB0aGUgcHJvdmlkZWQgZ3JhcGggZGF0YVxuICovXG5mdW5jdGlvbiBkcmF3TWVybWFpZChub2RlcywgZWRnZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgZmlyc3ROb2RlLCBsYXN0Tm9kZSwgbm9kZUNvbG9ycywgd2l0aFN0eWxlcyA9IHRydWUsIGN1cnZlU3R5bGUgPSBcImxpbmVhclwiLCB3cmFwTGFiZWxOV29yZHMgPSA5LCB9ID0gY29uZmlnID8/IHt9O1xuICAgIC8vIEluaXRpYWxpemUgTWVybWFpZCBncmFwaCBjb25maWd1cmF0aW9uXG4gICAgbGV0IG1lcm1haWRHcmFwaCA9IHdpdGhTdHlsZXNcbiAgICAgICAgPyBgJSV7aW5pdDogeydmbG93Y2hhcnQnOiB7J2N1cnZlJzogJyR7Y3VydmVTdHlsZX0nfX19JSVcXG5ncmFwaCBURDtcXG5gXG4gICAgICAgIDogXCJncmFwaCBURDtcXG5cIjtcbiAgICBpZiAod2l0aFN0eWxlcykge1xuICAgICAgICAvLyBOb2RlIGZvcm1hdHRpbmcgdGVtcGxhdGVzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDbGFzc0xhYmVsID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIGNvbnN0IGZvcm1hdERpY3QgPSB7XG4gICAgICAgICAgICBbZGVmYXVsdENsYXNzTGFiZWxdOiBcInswfSh7MX0pXCIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaXJzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0RGljdFtmaXJzdE5vZGVdID0gXCJ7MH0oW3sxfV0pOjo6Zmlyc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0RGljdFtsYXN0Tm9kZV0gPSBcInswfShbezF9XSk6OjpsYXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG5vZGVzIHRvIHRoZSBncmFwaFxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGVzKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5hbWUuc3BsaXQoXCI6XCIpLnBvcCgpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IE1BUktET1dOX1NQRUNJQUxfQ0hBUlMuc29tZSgoY2hhcikgPT4gbm9kZU5hbWUuc3RhcnRzV2l0aChjaGFyKSAmJiBub2RlTmFtZS5lbmRzV2l0aChjaGFyKSlcbiAgICAgICAgICAgICAgICA/IGA8cD4ke25vZGVOYW1lfTwvcD5gXG4gICAgICAgICAgICAgICAgOiBub2RlTmFtZTtcbiAgICAgICAgICAgIGxldCBmaW5hbExhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5tZXRhZGF0YSA/PyB7fSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmluYWxMYWJlbCArPSBgPGhyLz48c21hbGw+PGVtPiR7T2JqZWN0LmVudHJpZXMobm9kZS5tZXRhZGF0YSA/PyB7fSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfSA9ICR7dn1gKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKX08L2VtPjwvc21hbGw+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGVMYWJlbCA9IChmb3JtYXREaWN0W2tleV0gPz8gZm9ybWF0RGljdFtkZWZhdWx0Q2xhc3NMYWJlbF0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ7MH1cIiwgX2VzY2FwZU5vZGVMYWJlbChrZXkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiezF9XCIsIGZpbmFsTGFiZWwpO1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke25vZGVMYWJlbH1cXG5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdyb3VwIGVkZ2VzIGJ5IHRoZWlyIGNvbW1vbiBwcmVmaXhlc1xuICAgIGNvbnN0IGVkZ2VHcm91cHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3Qgc3JjUGFydHMgPSBlZGdlLnNvdXJjZS5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbnN0IHRndFBhcnRzID0gZWRnZS50YXJnZXQuc3BsaXQoXCI6XCIpO1xuICAgICAgICBjb25zdCBjb21tb25QcmVmaXggPSBzcmNQYXJ0c1xuICAgICAgICAgICAgLmZpbHRlcigoc3JjLCBpKSA9PiBzcmMgPT09IHRndFBhcnRzW2ldKVxuICAgICAgICAgICAgLmpvaW4oXCI6XCIpO1xuICAgICAgICBpZiAoIWVkZ2VHcm91cHNbY29tbW9uUHJlZml4XSkge1xuICAgICAgICAgICAgZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdLnB1c2goZWRnZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlZW5TdWJncmFwaHMgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gYWRkU3ViZ3JhcGgoZWRnZXMsIHByZWZpeCkge1xuICAgICAgICBjb25zdCBzZWxmTG9vcCA9IGVkZ2VzLmxlbmd0aCA9PT0gMSAmJiBlZGdlc1swXS5zb3VyY2UgPT09IGVkZ2VzWzBdLnRhcmdldDtcbiAgICAgICAgaWYgKHByZWZpeCAmJiAhc2VsZkxvb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmdyYXBoID0gcHJlZml4LnNwbGl0KFwiOlwiKS5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzZWVuU3ViZ3JhcGhzLmhhcyhzdWJncmFwaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGR1cGxpY2F0ZSBzdWJncmFwaCAnJHtzdWJncmFwaH0nIC0tIHRoaXMgbGlrZWx5IG1lYW5zIHRoYXQgYCArXG4gICAgICAgICAgICAgICAgICAgIFwieW91J3JlIHJldXNpbmcgYSBzdWJncmFwaCBub2RlIHdpdGggdGhlIHNhbWUgbmFtZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBhZGp1c3QgeW91ciBncmFwaCB0byBoYXZlIHN1YmdyYXBoIG5vZGVzIHdpdGggdW5pcXVlIG5hbWVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5TdWJncmFwaHMuYWRkKHN1YmdyYXBoKTtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBgXFx0c3ViZ3JhcGggJHtzdWJncmFwaH1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCwgZGF0YSwgY29uZGl0aW9uYWwgfSA9IGVkZ2U7XG4gICAgICAgICAgICBsZXQgZWRnZUxhYmVsID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWRnZURhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gZWRnZURhdGEuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGggPiB3cmFwTGFiZWxOV29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZURhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBNYXRoLmNlaWwod29yZHMubGVuZ3RoIC8gd3JhcExhYmVsTldvcmRzKSB9LCAoXywgaSkgPT4gd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpICogd3JhcExhYmVsTldvcmRzLCAoaSArIDEpICogd3JhcExhYmVsTldvcmRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpKS5qb2luKFwiJm5ic3A7PGJyPiZuYnNwO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRnZUxhYmVsID0gY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgPyBgIC0uICZuYnNwOyR7ZWRnZURhdGF9Jm5ic3A7IC4tPiBgXG4gICAgICAgICAgICAgICAgICAgIDogYCAtLSAmbmJzcDske2VkZ2VEYXRhfSZuYnNwOyAtLT4gYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkZ2VMYWJlbCA9IGNvbmRpdGlvbmFsID8gXCIgLS4tPiBcIiA6IFwiIC0tPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBgXFx0JHtfZXNjYXBlTm9kZUxhYmVsKHNvdXJjZSl9JHtlZGdlTGFiZWx9JHtfZXNjYXBlTm9kZUxhYmVsKHRhcmdldCl9O1xcbmA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgYWRkIG5lc3RlZCBzdWJncmFwaHNcbiAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRQcmVmaXggaW4gZWRnZUdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKG5lc3RlZFByZWZpeC5zdGFydHNXaXRoKGAke3ByZWZpeH06YCkgJiYgbmVzdGVkUHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW25lc3RlZFByZWZpeF0sIG5lc3RlZFByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCAmJiAhc2VsZkxvb3ApIHtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBcIlxcdGVuZFxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IHdpdGggdGhlIHRvcC1sZXZlbCBlZGdlcyAobm8gY29tbW9uIHByZWZpeClcbiAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW1wiXCJdID8/IFtdLCBcIlwiKTtcbiAgICAvLyBBZGQgcmVtYWluaW5nIHN1YmdyYXBoc1xuICAgIGZvciAoY29uc3QgcHJlZml4IGluIGVkZ2VHcm91cHMpIHtcbiAgICAgICAgaWYgKCFwcmVmaXguaW5jbHVkZXMoXCI6XCIpICYmIHByZWZpeCAhPT0gXCJcIikge1xuICAgICAgICAgICAgYWRkU3ViZ3JhcGgoZWRnZUdyb3Vwc1twcmVmaXhdLCBwcmVmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBjdXN0b20gc3R5bGVzIGZvciBub2Rlc1xuICAgIGlmICh3aXRoU3R5bGVzKSB7XG4gICAgICAgIG1lcm1haWRHcmFwaCArPSBfZ2VuZXJhdGVNZXJtYWlkR3JhcGhTdHlsZXMobm9kZUNvbG9ycyA/PyB7fSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJtYWlkR3JhcGg7XG59XG5leHBvcnRzLmRyYXdNZXJtYWlkID0gZHJhd01lcm1haWQ7XG4vKipcbiAqIFJlbmRlcnMgTWVybWFpZCBncmFwaCB1c2luZyB0aGUgTWVybWFpZC5JTksgQVBJLlxuICovXG5hc3luYyBmdW5jdGlvbiBkcmF3TWVybWFpZFBuZyhtZXJtYWlkU3ludGF4LCBjb25maWcpIHtcbiAgICBsZXQgeyBiYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCIgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICAvLyBVc2UgYnRvYSBmb3IgY29tcGF0aWJpbGl0eSwgYXNzdW1lIEFTQ0lJXG4gICAgY29uc3QgbWVybWFpZFN5bnRheEVuY29kZWQgPSBidG9hKG1lcm1haWRTeW50YXgpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlzIGEgaGV4YWRlY2ltYWwgY29sb3IgY29kZSB1c2luZyByZWdleFxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBoZXhDb2xvclBhdHRlcm4gPSAvXiMoPzpbMC05YS1mQS1GXXszfSl7MSwyfSQvO1xuICAgICAgICBpZiAoIWhleENvbG9yUGF0dGVybi50ZXN0KGJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGAhJHtiYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWFnZVVybCA9IGBodHRwczovL21lcm1haWQuaW5rL2ltZy8ke21lcm1haWRTeW50YXhFbmNvZGVkfT9iZ0NvbG9yPSR7YmFja2dyb3VuZENvbG9yfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goaW1hZ2VVcmwpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlbmRlciB0aGUgZ3JhcGggdXNpbmcgdGhlIE1lcm1haWQuSU5LIEFQSS5gLFxuICAgICAgICAgICAgYFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICAgIGBTdGF0dXMgdGV4dDogJHtyZXMuc3RhdHVzVGV4dH1gLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmV4cG9ydHMuZHJhd01lcm1haWRQbmcgPSBkcmF3TWVybWFpZFBuZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/history.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nclass RunnableWithMessageHistory extends base_js_1.RunnableBinding {\n    constructor(fields) {\n        let historyChain = base_js_1.RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = passthrough_js_1.RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !(0, index_js_1.isBaseMessage)(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new index_js_1.HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !(0, index_js_1.isBaseMessage)(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new index_js_1.AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\nexports.RunnableWithMessageHistory = RunnableWithMessageHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2hpc3RvcnkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMseUJBQXlCLG1CQUFPLENBQUMsOEZBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILGdCQUFnQix3QkFBd0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxTQUFTO0FBQ1QsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwQ0FBMEM7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRywyQ0FBMkM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLG9DQUFvQyw2QkFBNkIsSUFBSSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9oaXN0b3J5LmNqcz9jZWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvaW5kZXguY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBwYXNzdGhyb3VnaF9qc18xID0gcmVxdWlyZShcIi4vcGFzc3Rocm91Z2guY2pzXCIpO1xuLyoqXG4gKiBXcmFwcyBhIExDRUwgY2hhaW4gYW5kIG1hbmFnZXMgaGlzdG9yeS4gSXQgYXBwZW5kcyBpbnB1dCBtZXNzYWdlc1xuICogYW5kIGNoYWluIG91dHB1dHMgYXMgaGlzdG9yeSwgYW5kIGFkZHMgdGhlIGN1cnJlbnQgaGlzdG9yeSBtZXNzYWdlcyB0b1xuICogdGhlIGNoYWluIGlucHV0LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHlhcm4gYWRkIEBsYW5nY2hhaW4vYW50aHJvcGljIEBsYW5nY2hhaW4vY29tbXVuaXR5IEB1cHN0YXNoL3JlZGlzXG4gKlxuICogaW1wb3J0IHtcbiAqICAgQ2hhdFByb21wdFRlbXBsYXRlLFxuICogICBNZXNzYWdlc1BsYWNlaG9sZGVyLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3Byb21wdHNcIjtcbiAqIGltcG9ydCB7IENoYXRBbnRocm9waWMgfSBmcm9tIFwiQGxhbmdjaGFpbi9hbnRocm9waWNcIjtcbiAqIGltcG9ydCB7IFVwc3Rhc2hSZWRpc0NoYXRNZXNzYWdlSGlzdG9yeSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvbW11bml0eS9zdG9yZXMvbWVzc2FnZS91cHN0YXNoX3JlZGlzXCI7XG4gKiAvLyBGb3IgZGVtb3MsIHlvdSBjYW4gYWxzbyB1c2UgYW4gaW4tbWVtb3J5IHN0b3JlOlxuICogLy8gaW1wb3J0IHsgQ2hhdE1lc3NhZ2VIaXN0b3J5IH0gZnJvbSBcImxhbmdjaGFpbi9zdG9yZXMvbWVzc2FnZS9pbl9tZW1vcnlcIjtcbiAqXG4gKiBjb25zdCBwcm9tcHQgPSBDaGF0UHJvbXB0VGVtcGxhdGUuZnJvbU1lc3NhZ2VzKFtcbiAqICAgW1wic3lzdGVtXCIsIFwiWW91J3JlIGFuIGFzc2lzdGFudCB3aG8ncyBnb29kIGF0IHthYmlsaXR5fVwiXSxcbiAqICAgbmV3IE1lc3NhZ2VzUGxhY2Vob2xkZXIoXCJoaXN0b3J5XCIpLFxuICogICBbXCJodW1hblwiLCBcIntxdWVzdGlvbn1cIl0sXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IHByb21wdC5waXBlKG5ldyBDaGF0QW50aHJvcGljKHt9KSk7XG4gKlxuICogY29uc3QgY2hhaW5XaXRoSGlzdG9yeSA9IG5ldyBSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSh7XG4gKiAgIHJ1bm5hYmxlOiBjaGFpbixcbiAqICAgZ2V0TWVzc2FnZUhpc3Rvcnk6IChzZXNzaW9uSWQpID0+XG4gKiAgICAgbmV3IFVwc3Rhc2hSZWRpc0NoYXRNZXNzYWdlSGlzdG9yeSh7XG4gKiAgICAgICBzZXNzaW9uSWQsXG4gKiAgICAgICBjb25maWc6IHtcbiAqICAgICAgICAgdXJsOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISxcbiAqICAgICAgICAgdG9rZW46IHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiEsXG4gKiAgICAgICB9LFxuICogICAgIH0pLFxuICogICBpbnB1dE1lc3NhZ2VzS2V5OiBcInF1ZXN0aW9uXCIsXG4gKiAgIGhpc3RvcnlNZXNzYWdlc0tleTogXCJoaXN0b3J5XCIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbldpdGhIaXN0b3J5Lmludm9rZShcbiAqICAge1xuICogICAgIGFiaWxpdHk6IFwibWF0aFwiLFxuICogICAgIHF1ZXN0aW9uOiBcIldoYXQgZG9lcyBjb3NpbmUgbWVhbj9cIixcbiAqICAgfSxcbiAqICAge1xuICogICAgIGNvbmZpZ3VyYWJsZToge1xuICogICAgICAgc2Vzc2lvbklkOiBcInNvbWVfc3RyaW5nX2lkZW50aWZ5aW5nX2FfdXNlclwiLFxuICogICAgIH0sXG4gKiAgIH1cbiAqICk7XG4gKlxuICogY29uc3QgcmVzdWx0MiA9IGF3YWl0IGNoYWluV2l0aEhpc3RvcnkuaW52b2tlKFxuICogICB7XG4gKiAgICAgYWJpbGl0eTogXCJtYXRoXCIsXG4gKiAgICAgcXVlc3Rpb246IFwiV2hhdCdzIGl0cyBpbnZlcnNlP1wiLFxuICogICB9LFxuICogICB7XG4gKiAgICAgY29uZmlndXJhYmxlOiB7XG4gKiAgICAgICBzZXNzaW9uSWQ6IFwic29tZV9zdHJpbmdfaWRlbnRpZnlpbmdfYV91c2VyXCIsXG4gKiAgICAgfSxcbiAqICAgfVxuICogKTtcbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZUJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBsZXQgaGlzdG9yeUNoYWluID0gYmFzZV9qc18xLlJ1bm5hYmxlTGFtYmRhLmZyb20oKGlucHV0LCBvcHRpb25zKSA9PiB0aGlzLl9lbnRlckhpc3RvcnkoaW5wdXQsIG9wdGlvbnMgPz8ge30pKS53aXRoQ29uZmlnKHsgcnVuTmFtZTogXCJsb2FkSGlzdG9yeVwiIH0pO1xuICAgICAgICBjb25zdCBtZXNzYWdlc0tleSA9IGZpZWxkcy5oaXN0b3J5TWVzc2FnZXNLZXkgPz8gZmllbGRzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIGlmIChtZXNzYWdlc0tleSkge1xuICAgICAgICAgICAgaGlzdG9yeUNoYWluID0gcGFzc3Rocm91Z2hfanNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAgICAgW21lc3NhZ2VzS2V5XTogaGlzdG9yeUNoYWluLFxuICAgICAgICAgICAgfSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IFwiaW5zZXJ0SGlzdG9yeVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvdW5kID0gaGlzdG9yeUNoYWluXG4gICAgICAgICAgICAucGlwZShmaWVsZHMucnVubmFibGUud2l0aExpc3RlbmVycyh7XG4gICAgICAgICAgICBvbkVuZDogKHJ1biwgY29uZmlnKSA9PiB0aGlzLl9leGl0SGlzdG9yeShydW4sIGNvbmZpZyA/PyB7fSksXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLndpdGhDb25maWcoeyBydW5OYW1lOiBcIlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5XCIgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGZpZWxkcy5jb25maWcgPz8ge307XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGJvdW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRNZXNzYWdlc0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRNZXNzYWdlc0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaXN0b3J5TWVzc2FnZXNLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TWVzc2FnZUhpc3RvcnlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlSGlzdG9yeSA9IGZpZWxkcy5nZXRNZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgdGhpcy5pbnB1dE1lc3NhZ2VzS2V5ID0gZmllbGRzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIHRoaXMub3V0cHV0TWVzc2FnZXNLZXkgPSBmaWVsZHMub3V0cHV0TWVzc2FnZXNLZXk7XG4gICAgICAgIHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID0gZmllbGRzLmhpc3RvcnlNZXNzYWdlc0tleTtcbiAgICB9XG4gICAgX2dldElucHV0TWVzc2FnZXMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpbnB1dFZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJzZWRJbnB1dFZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpICYmXG4gICAgICAgICAgICAhKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dE1lc3NhZ2VzS2V5KSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pbnB1dE1lc3NhZ2VzS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcImlucHV0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlW2tleV0pICYmIEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZVtrZXldWzBdKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZElucHV0VmFsdWUgPSBpbnB1dFZhbHVlW2tleV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFZhbHVlID0gaW5wdXRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXRWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRJbnB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBpbmRleF9qc18xLkh1bWFuTWVzc2FnZShwYXJzZWRJbnB1dFZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRJbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZElucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkocGFyc2VkSW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VkSW5wdXRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBCYXNlTWVzc2FnZSwgb3IgYXJyYXkgb2YgQmFzZU1lc3NhZ2VzLlxcbkdvdCAke0pTT04uc3RyaW5naWZ5KHBhcnNlZElucHV0VmFsdWUsIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRPdXRwdXRNZXNzYWdlcyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG91dHB1dFZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJzZWRPdXRwdXRWYWx1ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgISgwLCBpbmRleF9qc18xLmlzQmFzZU1lc3NhZ2UpKG91dHB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG91dHB1dFZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TWVzc2FnZXNLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMub3V0cHV0TWVzc2FnZXNLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMob3V0cHV0VmFsdWUpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJvdXRwdXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgd3JhcHBpbmcgYSBjaGF0IG1vZGVsIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBUaGUgb3V0cHV0IGlzIGFjdHVhbGx5IHRoaXMgd2VpcmQgZ2VuZXJhdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICBpZiAob3V0cHV0VmFsdWUuZ2VuZXJhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWUuZ2VuZXJhdGlvbnNbMF1bMF0ubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE91dHB1dFZhbHVlID0gb3V0cHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRPdXRwdXRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgaW5kZXhfanNfMS5BSU1lc3NhZ2UocGFyc2VkT3V0cHV0VmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZE91dHB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE91dHB1dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18xLmlzQmFzZU1lc3NhZ2UpKHBhcnNlZE91dHB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZWRPdXRwdXRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBCYXNlTWVzc2FnZSwgb3IgYXJyYXkgb2YgQmFzZU1lc3NhZ2VzLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShwYXJzZWRPdXRwdXRWYWx1ZSwgbnVsbCwgMil9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VudGVySGlzdG9yeShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlucHV0LCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IGt3YXJncz8uY29uZmlndXJhYmxlPy5tZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBoaXN0b3J5LmdldE1lc3NhZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlNZXNzYWdlc0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXMuY29uY2F0KHRoaXMuX2dldElucHV0TWVzc2FnZXMoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuICAgIGFzeW5jIF9leGl0SGlzdG9yeShydW4sIGNvbmZpZykge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY29uZmlnLmNvbmZpZ3VyYWJsZT8ubWVzc2FnZUhpc3Rvcnk7XG4gICAgICAgIC8vIEdldCBpbnB1dCBtZXNzYWdlc1xuICAgICAgICBsZXQgaW5wdXRzO1xuICAgICAgICAvLyBDaGF0IG1vZGVsIGlucHV0cyBhcmUgbmVzdGVkIGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShydW4uaW5wdXRzKSAmJiBBcnJheS5pc0FycmF5KHJ1bi5pbnB1dHNbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBydW4uaW5wdXRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRzID0gcnVuLmlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXRNZXNzYWdlcyA9IHRoaXMuX2dldElucHV0TWVzc2FnZXMoaW5wdXRzKTtcbiAgICAgICAgLy8gSWYgaGlzdG9yaWMgbWVzc2FnZXMgd2VyZSBwcmVwZW5kZWQgdG8gdGhlIGlucHV0IG1lc3NhZ2VzLCByZW1vdmUgdGhlbSB0b1xuICAgICAgICAvLyBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIG1lc3NhZ2VzIHRvIGhpc3RvcnkuXG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlNZXNzYWdlc0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ01lc3NhZ2VzID0gYXdhaXQgaGlzdG9yeS5nZXRNZXNzYWdlcygpO1xuICAgICAgICAgICAgaW5wdXRNZXNzYWdlcyA9IGlucHV0TWVzc2FnZXMuc2xpY2UoZXhpc3RpbmdNZXNzYWdlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXRwdXQgbWVzc2FnZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWUgPSBydW4ub3V0cHV0cztcbiAgICAgICAgaWYgKCFvdXRwdXRWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgdmFsdWVzIGZyb20gJ1J1bicgdW5kZWZpbmVkLiBSdW46ICR7SlNPTi5zdHJpbmdpZnkocnVuLCBudWxsLCAyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXRNZXNzYWdlcyA9IHRoaXMuX2dldE91dHB1dE1lc3NhZ2VzKG91dHB1dFZhbHVlKTtcbiAgICAgICAgYXdhaXQgaGlzdG9yeS5hZGRNZXNzYWdlcyhbLi4uaW5wdXRNZXNzYWdlcywgLi4ub3V0cHV0TWVzc2FnZXNdKTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLmNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgc3VwZXIuX21lcmdlQ29uZmlnKC4uLmNvbmZpZ3MpO1xuICAgICAgICAvLyBFeHRyYWN0IHNlc3Npb25JZFxuICAgICAgICBpZiAoIWNvbmZpZy5jb25maWd1cmFibGUgfHwgIWNvbmZpZy5jb25maWd1cmFibGUuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgW3RoaXMuaW5wdXRNZXNzYWdlc0tleSA/PyBcImlucHV0XCJdOiBcImZvb1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVDb25maWcgPSB7IGNvbmZpZ3VyYWJsZTogeyBzZXNzaW9uSWQ6IFwiMTIzXCIgfSB9O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZXNzaW9uSWQgaXMgcmVxdWlyZWQuIFBhc3MgaXQgaW4gYXMgcGFydCBvZiB0aGUgY29uZmlnIGFyZ3VtZW50IHRvIC5pbnZva2UoKSBvciAuc3RyZWFtKClcXG5gICtcbiAgICAgICAgICAgICAgICBgZWcuIGNoYWluLmludm9rZSgke0pTT04uc3RyaW5naWZ5KGV4YW1wbGVJbnB1dCl9LCAke0pTT04uc3RyaW5naWZ5KGV4YW1wbGVDb25maWcpfSlgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggbWVzc2FnZUhpc3RvcnlcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQgfSA9IGNvbmZpZy5jb25maWd1cmFibGU7XG4gICAgICAgIGNvbmZpZy5jb25maWd1cmFibGUubWVzc2FnZUhpc3RvcnkgPSBhd2FpdCB0aGlzLmdldE1lc3NhZ2VIaXN0b3J5KHNlc3Npb25JZCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeSA9IFJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/index.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = exports.RunnableBranch = exports.RouterRunnable = exports.RunnablePassthrough = exports.mergeConfigs = exports.ensureConfig = exports.patchConfig = exports.getCallbackManagerForConfig = exports.RunnableToolLike = exports._coerceToRunnable = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableLambda = exports.RunnableParallel = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\nvar base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nObject.defineProperty(exports, \"Runnable\", ({ enumerable: true, get: function () { return base_js_1.Runnable; } }));\nObject.defineProperty(exports, \"RunnableBinding\", ({ enumerable: true, get: function () { return base_js_1.RunnableBinding; } }));\nObject.defineProperty(exports, \"RunnableEach\", ({ enumerable: true, get: function () { return base_js_1.RunnableEach; } }));\nObject.defineProperty(exports, \"RunnableRetry\", ({ enumerable: true, get: function () { return base_js_1.RunnableRetry; } }));\nObject.defineProperty(exports, \"RunnableSequence\", ({ enumerable: true, get: function () { return base_js_1.RunnableSequence; } }));\nObject.defineProperty(exports, \"RunnableMap\", ({ enumerable: true, get: function () { return base_js_1.RunnableMap; } }));\nObject.defineProperty(exports, \"RunnableParallel\", ({ enumerable: true, get: function () { return base_js_1.RunnableParallel; } }));\nObject.defineProperty(exports, \"RunnableLambda\", ({ enumerable: true, get: function () { return base_js_1.RunnableLambda; } }));\nObject.defineProperty(exports, \"RunnableWithFallbacks\", ({ enumerable: true, get: function () { return base_js_1.RunnableWithFallbacks; } }));\nObject.defineProperty(exports, \"RunnableAssign\", ({ enumerable: true, get: function () { return base_js_1.RunnableAssign; } }));\nObject.defineProperty(exports, \"RunnablePick\", ({ enumerable: true, get: function () { return base_js_1.RunnablePick; } }));\nObject.defineProperty(exports, \"_coerceToRunnable\", ({ enumerable: true, get: function () { return base_js_1._coerceToRunnable; } }));\nObject.defineProperty(exports, \"RunnableToolLike\", ({ enumerable: true, get: function () { return base_js_1.RunnableToolLike; } }));\nvar config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nObject.defineProperty(exports, \"getCallbackManagerForConfig\", ({ enumerable: true, get: function () { return config_js_1.getCallbackManagerForConfig; } }));\nObject.defineProperty(exports, \"patchConfig\", ({ enumerable: true, get: function () { return config_js_1.patchConfig; } }));\nObject.defineProperty(exports, \"ensureConfig\", ({ enumerable: true, get: function () { return config_js_1.ensureConfig; } }));\nObject.defineProperty(exports, \"mergeConfigs\", ({ enumerable: true, get: function () { return config_js_1.mergeConfigs; } }));\nvar passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nObject.defineProperty(exports, \"RunnablePassthrough\", ({ enumerable: true, get: function () { return passthrough_js_1.RunnablePassthrough; } }));\nvar router_js_1 = __webpack_require__(/*! ./router.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\");\nObject.defineProperty(exports, \"RouterRunnable\", ({ enumerable: true, get: function () { return router_js_1.RouterRunnable; } }));\nvar branch_js_1 = __webpack_require__(/*! ./branch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\");\nObject.defineProperty(exports, \"RunnableBranch\", ({ enumerable: true, get: function () { return branch_js_1.RunnableBranch; } }));\nvar history_js_1 = __webpack_require__(/*! ./history.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\");\nObject.defineProperty(exports, \"RunnableWithMessageHistory\", ({ enumerable: true, get: function () { return history_js_1.RunnableWithMessageHistory; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDcGlCLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3BDLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCxtREFBa0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDL0gsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrREFBaUQsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDN0gseURBQXdELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzNJLGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBYztBQUN4QywrREFBOEQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDekosK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsdUJBQXVCLG1CQUFPLENBQUMsOEZBQW1CO0FBQ2xELHVEQUFzRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUM5SSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBYztBQUN4QyxrREFBaUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDL0gsa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWM7QUFDeEMsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILG1CQUFtQixtQkFBTyxDQUFDLHNGQUFlO0FBQzFDLDhEQUE2RCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvaW5kZXguY2pzP2E2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5ID0gZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IGV4cG9ydHMuUm91dGVyUnVubmFibGUgPSBleHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSBleHBvcnRzLm1lcmdlQ29uZmlncyA9IGV4cG9ydHMuZW5zdXJlQ29uZmlnID0gZXhwb3J0cy5wYXRjaENvbmZpZyA9IGV4cG9ydHMuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnID0gZXhwb3J0cy5SdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5fY29lcmNlVG9SdW5uYWJsZSA9IGV4cG9ydHMuUnVubmFibGVQaWNrID0gZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IGV4cG9ydHMuUnVubmFibGVXaXRoRmFsbGJhY2tzID0gZXhwb3J0cy5SdW5uYWJsZUxhbWJkYSA9IGV4cG9ydHMuUnVubmFibGVQYXJhbGxlbCA9IGV4cG9ydHMuUnVubmFibGVNYXAgPSBleHBvcnRzLlJ1bm5hYmxlU2VxdWVuY2UgPSBleHBvcnRzLlJ1bm5hYmxlUmV0cnkgPSBleHBvcnRzLlJ1bm5hYmxlRWFjaCA9IGV4cG9ydHMuUnVubmFibGVCaW5kaW5nID0gZXhwb3J0cy5SdW5uYWJsZSA9IHZvaWQgMDtcbnZhciBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUJpbmRpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUJpbmRpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUVhY2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUVhY2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVJldHJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVSZXRyeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlU2VxdWVuY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVNlcXVlbmNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZU1hcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlUGFyYWxsZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVBhcmFsbGVsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVMYW1iZGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUxhbWJkYTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlV2l0aEZhbGxiYWNrczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlQXNzaWduXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVBc3NpZ247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVBpY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVBpY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfY29lcmNlVG9SdW5uYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLl9jb2VyY2VUb1J1bm5hYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVUb29sTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlVG9vbExpa2U7IH0gfSk7XG52YXIgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXRjaENvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEucGF0Y2hDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnN1cmVDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lcmdlQ29uZmlnc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEubWVyZ2VDb25maWdzOyB9IH0pO1xudmFyIHBhc3N0aHJvdWdoX2pzXzEgPSByZXF1aXJlKFwiLi9wYXNzdGhyb3VnaC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVBhc3N0aHJvdWdoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXNzdGhyb3VnaF9qc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2g7IH0gfSk7XG52YXIgcm91dGVyX2pzXzEgPSByZXF1aXJlKFwiLi9yb3V0ZXIuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm91dGVyUnVubmFibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlcl9qc18xLlJvdXRlclJ1bm5hYmxlOyB9IH0pO1xudmFyIGJyYW5jaF9qc18xID0gcmVxdWlyZShcIi4vYnJhbmNoLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlQnJhbmNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBicmFuY2hfanNfMS5SdW5uYWJsZUJyYW5jaDsgfSB9KTtcbnZhciBoaXN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi9oaXN0b3J5LmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoaXN0b3J5X2pzXzEuUnVubmFibGVXaXRoTWVzc2FnZUhpc3Rvcnk7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.consumeAsyncIterableInContext = exports.consumeIteratorInContext = exports.isAsyncIterable = exports.isIterator = exports.isIterableIterator = void 0;\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nfunction isIterableIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nexports.isIterableIterator = isIterableIterator;\nconst isIterator = (x) => x != null &&\n    typeof x === \"object\" &&\n    \"next\" in x &&\n    typeof x.next === \"function\";\nexports.isIterator = isIterator;\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nexports.isAsyncIterable = isAsyncIterable;\nfunction* consumeIteratorInContext(context, iter) {\n    while (true) {\n        const { value, done } = index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(context, iter.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nexports.consumeIteratorInContext = consumeIteratorInContext;\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(context, iterator.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nexports.consumeAsyncIterableInContext = consumeAsyncIterableInContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQyxHQUFHLGdDQUFnQyxHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQjtBQUNwSixtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuY2pzP2FmYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0ID0gZXhwb3J0cy5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQgPSBleHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGV4cG9ydHMuaXNJdGVyYXRvciA9IGV4cG9ydHMuaXNJdGVyYWJsZUl0ZXJhdG9yID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmZ1bmN0aW9uIGlzSXRlcmFibGVJdGVyYXRvcih0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgLy8gYXZvaWQgZGV0ZWN0aW5nIGFycmF5L3NldCBhcyBpdGVyYXRvclxuICAgICAgICB0eXBlb2YgdGhpbmcubmV4dCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydHMuaXNJdGVyYWJsZUl0ZXJhdG9yID0gaXNJdGVyYWJsZUl0ZXJhdG9yO1xuY29uc3QgaXNJdGVyYXRvciA9ICh4KSA9PiB4ICE9IG51bGwgJiZcbiAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIFwibmV4dFwiIGluIHggJiZcbiAgICB0eXBlb2YgeC5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnRzLmlzSXRlcmF0b3IgPSBpc0l0ZXJhdG9yO1xuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHRoaW5nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdGhpbmcgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHRoaW5nW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGlzQXN5bmNJdGVyYWJsZTtcbmZ1bmN0aW9uKiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY29udGV4dCwgaXRlcikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNvbnRleHQsIGl0ZXIubmV4dC5iaW5kKGl0ZXIpLCB0cnVlKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNvbnN1bWVJdGVyYXRvckluQ29udGV4dCA9IGNvbnN1bWVJdGVyYXRvckluQ29udGV4dDtcbmFzeW5jIGZ1bmN0aW9uKiBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dChjb250ZXh0LCBpdGVyKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNvbnRleHQsIGl0ZXJhdG9yLm5leHQuYmluZChpdGVyKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCA9IGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/passthrough.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnablePassthrough = void 0;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnablePassthrough extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({}).bind({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new base_js_1.RunnableAssign(new base_js_1.RunnableMap({ steps: mapping }));\n    }\n}\nexports.RunnablePassthrough = RunnablePassthrough;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3Bhc3N0aHJvdWdoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLFNBQVMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxnQkFBZ0I7QUFDeEY7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvcGFzc3Rocm91Z2guY2pzP2RkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG4vKipcbiAqIEEgcnVubmFibGUgdG8gcGFzc3Rocm91Z2ggaW5wdXRzIHVuY2hhbmdlZCBvciB3aXRoIGFkZGl0aW9uYWwga2V5cy5cbiAqXG4gKiBUaGlzIHJ1bm5hYmxlIGJlaGF2ZXMgYWxtb3N0IGxpa2UgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLCBleGNlcHQgdGhhdCBpdFxuICogY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYWRkIGFkZGl0aW9uYWwga2V5cyB0byB0aGUgb3V0cHV0LCBpZiB0aGUgaW5wdXQgaXNcbiAqIGFuIG9iamVjdC5cbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHVzZSBgUnVubmFibGVQYXNzdGhyb3VnaCB0b1xuICogcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAge1xuICogICAgIHF1ZXN0aW9uOiBuZXcgUnVubmFibGVQYXNzdGhyb3VnaCgpLFxuICogICAgIGNvbnRleHQ6IGFzeW5jICgpID0+IGxvYWRDb250ZXh0RnJvbVN0b3JlKCksXG4gKiAgIH0sXG4gKiAgIHByb21wdCxcbiAqICAgbGxtLFxuICogICBvdXRwdXRQYXJzZXIsXG4gKiBdKTtcbiAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhaW4uaW52b2tlKFxuICogICBcIkkgY2FuIHBhc3MgYSBzaW5nbGUgc3RyaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHNpbmNlIEknbSB1c2luZyBgUnVubmFibGVQYXNzdGhyb3VnaGAuXCJcbiAqICk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNsYXNzIFJ1bm5hYmxlUGFzc3Rocm91Z2ggZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBhc3N0aHJvdWdoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5mdW5jKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKChpbnB1dCkgPT4gUHJvbWlzZS5yZXNvbHZlKGlucHV0KSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIChpbnB1dCkgPT4gaW5wdXQsIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mdW5jICYmIGZpbmFsT3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZnVuYyhmaW5hbE91dHB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gdGhlIGlucHV0LlxuICAgICAqXG4gICAgICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd3MgaG93IHlvdSBjb3VsZCB1c2UgaXQgd2l0aCBhbiBpbmxpbmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm9tcHQgPVxuICAgICAqICAgUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGBXcml0ZSBhIFNRTCBxdWVyeSB0byBhbnN3ZXIgdGhlIHF1ZXN0aW9uIHVzaW5nIHRoZSBmb2xsb3dpbmcgc2NoZW1hOiB7c2NoZW1hfVxuICAgICAqIFF1ZXN0aW9uOiB7cXVlc3Rpb259XG4gICAgICogU1FMIFF1ZXJ5OmApO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbigpYCBpcyB1c2VkIGhlcmUgdG8gcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gICAgICogLy8gY2FsbCAoaW4gdGhpcyBleGFtcGxlIGl0J3MgdGhlIHF1ZXN0aW9uKSwgYWxvbmcgd2l0aCBhbnkgaW5wdXRzIHBhc3NlZCB0byB0aGUgYC5hc3NpZ24oKWAgbWV0aG9kLlxuICAgICAqIC8vIEluIHRoaXMgY2FzZSwgd2UncmUgcGFzc2luZyB0aGUgc2NoZW1hLlxuICAgICAqIGNvbnN0IHNxbFF1ZXJ5R2VuZXJhdG9yQ2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAqICAgUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAqICAgICBzY2hlbWE6IGFzeW5jICgpID0+IGRiLmdldFRhYmxlSW5mbygpLFxuICAgICAqICAgfSksXG4gICAgICogICBwcm9tcHQsXG4gICAgICogICBuZXcgQ2hhdE9wZW5BSSh7fSkuYmluZCh7IHN0b3A6IFtcIlxcblNRTFJlc3VsdDpcIl0gfSksXG4gICAgICogICBuZXcgU3RyaW5nT3V0cHV0UGFyc2VyKCksXG4gICAgICogXSk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsUXVlcnlHZW5lcmF0b3JDaGFpbi5pbnZva2Uoe1xuICAgICAqICAgcXVlc3Rpb246IFwiSG93IG1hbnkgZW1wbG95ZWVzIGFyZSB0aGVyZT9cIixcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzaWduKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBiYXNlX2pzXzEuUnVubmFibGVBc3NpZ24obmV3IGJhc2VfanNfMS5SdW5uYWJsZU1hcCh7IHN0ZXBzOiBtYXBwaW5nIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSBSdW5uYWJsZVBhc3N0aHJvdWdoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/remote.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../documents/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst event_source_parse_js_1 = __webpack_require__(/*! ../utils/event_source_parse.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction isSuperset(set, subset) {\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction revive(obj) {\n    if (Array.isArray(obj))\n        return obj.map(revive);\n    if (typeof obj === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!obj || obj instanceof Date) {\n            return obj;\n        }\n        const keysArr = Object.keys(obj);\n        const keys = new Set(keysArr);\n        if (isSuperset(keys, new Set([\"page_content\", \"metadata\"]))) {\n            return new index_js_1.Document({\n                pageContent: obj.page_content,\n                metadata: obj.metadata,\n            });\n        }\n        if (isSuperset(keys, new Set([\"content\", \"type\", \"additional_kwargs\"]))) {\n            if (obj.type === \"HumanMessage\" || obj.type === \"human\") {\n                return new index_js_2.HumanMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessage\" || obj.type === \"system\") {\n                return new index_js_2.SystemMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessage\" || obj.type === \"generic\") {\n                return new index_js_2.ChatMessage({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessage\" || obj.type === \"function\") {\n                return new index_js_2.FunctionMessage({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessage\" || obj.type === \"tool\") {\n                return new index_js_2.ToolMessage({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                });\n            }\n            if (obj.type === \"AIMessage\" || obj.type === \"ai\") {\n                return new index_js_2.AIMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"HumanMessageChunk\") {\n                return new index_js_2.HumanMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessageChunk\") {\n                return new index_js_2.SystemMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessageChunk\") {\n                return new index_js_2.ChatMessageChunk({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessageChunk\") {\n                return new index_js_2.FunctionMessageChunk({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessageChunk\") {\n                return new index_js_2.ToolMessageChunk({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                });\n            }\n            if (obj.type === \"AIMessageChunk\") {\n                return new index_js_2.AIMessageChunk({\n                    content: obj.content,\n                });\n            }\n        }\n        if (isSuperset(keys, new Set([\"text\", \"generation_info\", \"type\"]))) {\n            if (obj.type === \"ChatGenerationChunk\") {\n                return new outputs_js_1.ChatGenerationChunk({\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"ChatGeneration\") {\n                return {\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n            else if (obj.type === \"GenerationChunk\") {\n                return new outputs_js_1.GenerationChunk({\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"Generation\") {\n                return {\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"tool\", \"tool_input\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentAction\") {\n                return {\n                    tool: obj.tool,\n                    toolInput: obj.tool_input,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"return_values\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentFinish\") {\n                return {\n                    returnValues: obj.return_values,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"generations\", \"run\", \"type\"]))) {\n            if (obj.type === \"LLMResult\") {\n                return {\n                    generations: revive(obj.generations),\n                    llmOutput: obj.llm_output,\n                    [outputs_js_1.RUN_KEY]: obj.run,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"messages\"]))) {\n            // TODO: Start checking for type: ChatPromptValue and ChatPromptValueConcrete\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.ChatPromptValue({\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                messages: obj.messages.map((msg) => revive(msg)),\n            });\n        }\n        if (isSuperset(keys, new Set([\"text\"]))) {\n            // TODO: Start checking for type: StringPromptValue\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.StringPromptValue(obj.text);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerRevive = (key) => [\n            key,\n            revive(obj[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerRevive));\n        return rtn;\n    }\n    return obj;\n}\nfunction deserialize(str) {\n    const obj = JSON.parse(str);\n    return revive(obj);\n}\nfunction removeCallbacksAndSignal(options) {\n    const rest = { ...options };\n    delete rest.callbacks;\n    delete rest.signal;\n    return rest;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serialize(input) {\n    if (Array.isArray(input))\n        return input.map(serialize);\n    if ((0, index_js_2.isBaseMessage)(input)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const serializedMessage = {\n            content: input.content,\n            type: input._getType(),\n            additional_kwargs: input.additional_kwargs,\n            name: input.name,\n            example: false,\n        };\n        if (index_js_2.ToolMessage.isInstance(input)) {\n            serializedMessage.tool_call_id = input.tool_call_id;\n        }\n        else if (index_js_2.ChatMessage.isInstance(input)) {\n            serializedMessage.role = input.role;\n        }\n        return serializedMessage;\n    }\n    if (typeof input === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!input || input instanceof Date) {\n            return input;\n        }\n        const keysArr = Object.keys(input);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerSerialize = (key) => [\n            key,\n            serialize(input[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerSerialize));\n        return rtn;\n    }\n    return input;\n}\n/**\n * Client for interacting with LangChain runnables\n * that are hosted as LangServe endpoints.\n *\n * Allows you to interact with hosted runnables using the standard\n * `.invoke()`, `.stream()`, `.streamEvents()`, etc. methods that\n * other runnables support.\n *\n * @param url - The base URL of the LangServe endpoint.\n * @param options - Optional configuration for the remote runnable, including timeout and headers.\n * @param fetch - Optional custom fetch implementation.\n * @param fetchRequestOptions - Optional additional options for fetch requests.\n */\nclass RemoteRunnable extends base_js_1.Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Wrap the default fetch call due to issues with illegal invocations\n        // from the browser:\n        // https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (...args) => \n            // @ts-expect-error Broad typing to support a range of fetch implementations\n            fetch(...args)\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchRequestOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\", \"remote\"]\n        });\n        const { url, options, fetch: fetchImplementation, fetchRequestOptions, } = fields;\n        this.url = url.replace(/\\/$/, \"\"); // remove trailing slash\n        this.options = options;\n        this.fetchImplementation = fetchImplementation ?? this.fetchImplementation;\n        this.fetchRequestOptions = fetchRequestOptions;\n    }\n    async post(path, body, signal) {\n        return this.fetchImplementation(`${this.url}${path}`, {\n            method: \"POST\",\n            body: JSON.stringify(serialize(body)),\n            signal: signal ?? AbortSignal.timeout(this.options?.timeout ?? 60000),\n            ...this.fetchRequestOptions,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this.fetchRequestOptions?.headers,\n                ...this.options?.headers,\n            },\n        });\n    }\n    async _invoke(input, options, _) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const response = await this.post(\"/invoke\", {\n            input,\n            config: removeCallbacksAndSignal(config),\n            kwargs: kwargs ?? {},\n        }, config.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        return revive((await response.json()).output);\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async _batch(inputs, options, _, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"returnExceptions is not supported for remote clients\");\n        }\n        const configsAndKwargsArray = options?.map((opts) => this._separateRunnableConfigFromCallOptions(opts));\n        const [configs, kwargs] = configsAndKwargsArray?.reduce(([pc, pk], [c, k]) => [\n            [...pc, c],\n            [...pk, k],\n        ], [[], []]) ?? [undefined, undefined];\n        const response = await this.post(\"/batch\", {\n            inputs,\n            config: (configs ?? [])\n                .map(removeCallbacksAndSignal)\n                .map((config) => ({ ...config, ...batchOptions })),\n            kwargs,\n        }, options?.[0]?.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        const body = await response.json();\n        if (!body.output)\n            throw new Error(\"Invalid response from remote runnable\");\n        return revive(body.output);\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw Error(\"returnExceptions is not supported for remote clients\");\n        }\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let finalOutput;\n        let finalOutputSupported = true;\n        try {\n            const response = await this.post(\"/stream\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n            }, config.signal);\n            if (!response.ok) {\n                const json = await response.json();\n                const error = new Error(`RemoteRunnable call failed with status code ${response.status}: ${json.message}`);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.response = response;\n                throw error;\n            }\n            const { body } = response;\n            if (!body) {\n                throw new Error(\"Could not begin remote stream. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const chunk of runnableStream) {\n                const deserializedChunk = deserialize(chunk);\n                yield deserializedChunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = deserializedChunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0, stream_js_1.concat)(finalOutput, deserializedChunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n    async *streamLog(input, options, streamOptions) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        // The type is in camelCase but the API only accepts snake_case.\n        const camelCaseStreamOptions = {\n            include_names: streamOptions?.includeNames,\n            include_types: streamOptions?.includeTypes,\n            include_tags: streamOptions?.includeTags,\n            exclude_names: streamOptions?.excludeNames,\n            exclude_types: streamOptions?.excludeTypes,\n            exclude_tags: streamOptions?.excludeTags,\n        };\n        let runLog;\n        try {\n            const response = await this.post(\"/stream_log\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n                ...camelCaseStreamOptions,\n                diff: false,\n            }, config.signal);\n            const { body, ok } = response;\n            if (!ok) {\n                throw new Error(`${response.status} Error: ${await response.text()}`);\n            }\n            if (!body) {\n                throw new Error(\"Could not begin remote stream log. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const log of runnableStream) {\n                const chunk = revive(JSON.parse(log));\n                const logPatch = new log_stream_js_1.RunLogPatch({ ops: chunk.ops });\n                yield logPatch;\n                if (runLog === undefined) {\n                    runLog = log_stream_js_1.RunLog.fromRunLogPatch(logPatch);\n                }\n                else {\n                    runLog = runLog.concat(logPatch);\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(runLog?.state.final_output);\n    }\n    _streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            const [config, kwargs] = outerThis._separateRunnableConfigFromCallOptions(options);\n            const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n            const runManager = await callbackManager_?.handleChainStart(outerThis.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n            delete config.runId;\n            // The type is in camelCase but the API only accepts snake_case.\n            const camelCaseStreamOptions = {\n                include_names: streamOptions?.includeNames,\n                include_types: streamOptions?.includeTypes,\n                include_tags: streamOptions?.includeTags,\n                exclude_names: streamOptions?.excludeNames,\n                exclude_types: streamOptions?.excludeTypes,\n                exclude_tags: streamOptions?.excludeTags,\n            };\n            const events = [];\n            try {\n                const response = await outerThis.post(\"/stream_events\", {\n                    input,\n                    config: removeCallbacksAndSignal(config),\n                    kwargs,\n                    ...camelCaseStreamOptions,\n                    diff: false,\n                }, config.signal);\n                const { body, ok } = response;\n                if (!ok) {\n                    throw new Error(`${response.status} Error: ${await response.text()}`);\n                }\n                if (!body) {\n                    throw new Error(\"Could not begin remote stream events. Please check the given URL and try again.\");\n                }\n                const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n                for await (const log of runnableStream) {\n                    const chunk = revive(JSON.parse(log));\n                    const event = {\n                        event: chunk.event,\n                        name: chunk.name,\n                        run_id: chunk.run_id,\n                        tags: chunk.tags,\n                        metadata: chunk.metadata,\n                        data: chunk.data,\n                    };\n                    yield event;\n                    events.push(event);\n                }\n            }\n            catch (err) {\n                await runManager?.handleChainError(err);\n                throw err;\n            }\n            await runManager?.handleChainEnd(events);\n        };\n        return generator();\n    }\n    streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\" && options.version !== \"v2\") {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the events schema is currently supported.`);\n        }\n        if (options.encoding !== undefined) {\n            throw new Error(\"Special encodings are not supported for this runnable.\");\n        }\n        const eventStream = this._streamEvents(input, options, streamOptions);\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(eventStream);\n    }\n}\nexports.RemoteRunnable = RemoteRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MsZ0NBQWdDLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3pFLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsaUVBQWlFO0FBQ2pGLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0IsaUJBQWlCLFNBQVMsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixpQkFBaUIsU0FBUyxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1RkFBdUYsZ0JBQWdCLElBQUksYUFBYTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSxtQ0FBbUMsaUJBQWlCLFNBQVMsc0JBQXNCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsV0FBVztBQUNuQztBQUNBLHVDQUF1QyxpQkFBaUIsU0FBUyxzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvcmVtb3RlLmNqcz8xOWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdGVSdW5uYWJsZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9kb2N1bWVudHMvaW5kZXguY2pzXCIpO1xuY29uc3QgcHJvbXB0X3ZhbHVlc19qc18xID0gcmVxdWlyZShcIi4uL3Byb21wdF92YWx1ZXMuY2pzXCIpO1xuY29uc3QgbG9nX3N0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvbG9nX3N0cmVhbS5janNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2luZGV4LmNqc1wiKTtcbmNvbnN0IG91dHB1dHNfanNfMSA9IHJlcXVpcmUoXCIuLi9vdXRwdXRzLmNqc1wiKTtcbmNvbnN0IGV2ZW50X3NvdXJjZV9wYXJzZV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2V2ZW50X3NvdXJjZV9wYXJzZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuZnVuY3Rpb24gaXNTdXBlcnNldChzZXQsIHN1YnNldCkge1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzdWJzZXQpIHtcbiAgICAgICAgaWYgKCFzZXQuaGFzKGVsZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcmV2aXZlKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgICAgIHJldHVybiBvYmoubWFwKHJldml2ZSk7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoIW9iaiB8fCBvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXNBcnIgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFNldChrZXlzQXJyKTtcbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJwYWdlX2NvbnRlbnRcIiwgXCJtZXRhZGF0YVwiXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzEuRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiBvYmoucGFnZV9jb250ZW50LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvYmoubWV0YWRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcImNvbnRlbnRcIiwgXCJ0eXBlXCIsIFwiYWRkaXRpb25hbF9rd2FyZ3NcIl0pKSkge1xuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkh1bWFuTWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiU3lzdGVtTWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLlN5c3RlbU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJDaGF0TWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5DaGF0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBvYmoucm9sZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJGdW5jdGlvbk1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkZ1bmN0aW9uTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvYmoubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJUb29sTWVzc2FnZVwiIHx8IG9iai50eXBlID09PSBcInRvb2xcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5Ub29sTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IG9iai50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogb2JqLnN0YXR1cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJBSU1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJhaVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkFJTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkh1bWFuTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuSHVtYW5NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJTeXN0ZW1NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5TeXN0ZW1NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJDaGF0TWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuQ2hhdE1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBvYmoucm9sZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJGdW5jdGlvbk1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkZ1bmN0aW9uTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIlRvb2xNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5Ub29sTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogb2JqLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBvYmouc3RhdHVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkFJTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcInRleHRcIiwgXCJnZW5lcmF0aW9uX2luZm9cIiwgXCJ0eXBlXCJdKSkpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJDaGF0R2VuZXJhdGlvbkNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfanNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmV2aXZlKG9iai5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb2JqLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiBvYmouZ2VuZXJhdGlvbl9pbmZvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnR5cGUgPT09IFwiQ2hhdEdlbmVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJldml2ZShvYmoubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogb2JqLmdlbmVyYXRpb25faW5mbyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnR5cGUgPT09IFwiR2VuZXJhdGlvbkNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvYmoudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IG9iai5nZW5lcmF0aW9uX2luZm8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoudHlwZSA9PT0gXCJHZW5lcmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvYmoudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IG9iai5nZW5lcmF0aW9uX2luZm8sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcInRvb2xcIiwgXCJ0b29sX2lucHV0XCIsIFwibG9nXCIsIFwidHlwZVwiXSkpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQWdlbnRBY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2w6IG9iai50b29sLFxuICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQ6IG9iai50b29sX2lucHV0LFxuICAgICAgICAgICAgICAgICAgICBsb2c6IG9iai5sb2csXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdXBlcnNldChrZXlzLCBuZXcgU2V0KFtcInJldHVybl92YWx1ZXNcIiwgXCJsb2dcIiwgXCJ0eXBlXCJdKSkpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJBZ2VudEZpbmlzaFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVzOiBvYmoucmV0dXJuX3ZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBvYmoubG9nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJnZW5lcmF0aW9uc1wiLCBcInJ1blwiLCBcInR5cGVcIl0pKSkge1xuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkxMTVJlc3VsdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IHJldml2ZShvYmouZ2VuZXJhdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IG9iai5sbG1fb3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICBbb3V0cHV0c19qc18xLlJVTl9LRVldOiBvYmoucnVuLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJtZXNzYWdlc1wiXSkpKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTdGFydCBjaGVja2luZyBmb3IgdHlwZTogQ2hhdFByb21wdFZhbHVlIGFuZCBDaGF0UHJvbXB0VmFsdWVDb25jcmV0ZVxuICAgICAgICAgICAgLy8gd2hlbiBMYW5nU2VydmUgYnVnIGlzIGZpeGVkXG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb21wdF92YWx1ZXNfanNfMS5DaGF0UHJvbXB0VmFsdWUoe1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IG9iai5tZXNzYWdlcy5tYXAoKG1zZykgPT4gcmV2aXZlKG1zZykpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJ0ZXh0XCJdKSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFN0YXJ0IGNoZWNraW5nIGZvciB0eXBlOiBTdHJpbmdQcm9tcHRWYWx1ZVxuICAgICAgICAgICAgLy8gd2hlbiBMYW5nU2VydmUgYnVnIGlzIGZpeGVkXG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb21wdF92YWx1ZXNfanNfMS5TdHJpbmdQcm9tcHRWYWx1ZShvYmoudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgaW5uZXJSZXZpdmUgPSAoa2V5KSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXZpdmUob2JqW2tleV0pLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBydG4gPSBPYmplY3QuZnJvbUVudHJpZXMoa2V5c0Fyci5tYXAoaW5uZXJSZXZpdmUpKTtcbiAgICAgICAgcmV0dXJuIHJ0bjtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHN0cikge1xuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICByZXR1cm4gcmV2aXZlKG9iaik7XG59XG5mdW5jdGlvbiByZW1vdmVDYWxsYmFja3NBbmRTaWduYWwob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3QgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBkZWxldGUgcmVzdC5jYWxsYmFja3M7XG4gICAgZGVsZXRlIHJlc3Quc2lnbmFsO1xuICAgIHJldHVybiByZXN0O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHNlcmlhbGl6ZShpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChzZXJpYWxpemUpO1xuICAgIGlmICgoMCwgaW5kZXhfanNfMi5pc0Jhc2VNZXNzYWdlKShpbnB1dCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBjb250ZW50OiBpbnB1dC5jb250ZW50LFxuICAgICAgICAgICAgdHlwZTogaW5wdXQuX2dldFR5cGUoKSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBpbnB1dC5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgICAgICBleGFtcGxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4X2pzXzIuVG9vbE1lc3NhZ2UuaXNJbnN0YW5jZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlLnRvb2xfY2FsbF9pZCA9IGlucHV0LnRvb2xfY2FsbF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleF9qc18yLkNoYXRNZXNzYWdlLmlzSW5zdGFuY2UoaW5wdXQpKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkTWVzc2FnZS5yb2xlID0gaW5wdXQucm9sZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZE1lc3NhZ2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoIWlucHV0IHx8IGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXNBcnIgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGlubmVyU2VyaWFsaXplID0gKGtleSkgPT4gW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2VyaWFsaXplKGlucHV0W2tleV0pLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBydG4gPSBPYmplY3QuZnJvbUVudHJpZXMoa2V5c0Fyci5tYXAoaW5uZXJTZXJpYWxpemUpKTtcbiAgICAgICAgcmV0dXJuIHJ0bjtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufVxuLyoqXG4gKiBDbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggTGFuZ0NoYWluIHJ1bm5hYmxlc1xuICogdGhhdCBhcmUgaG9zdGVkIGFzIExhbmdTZXJ2ZSBlbmRwb2ludHMuXG4gKlxuICogQWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIGhvc3RlZCBydW5uYWJsZXMgdXNpbmcgdGhlIHN0YW5kYXJkXG4gKiBgLmludm9rZSgpYCwgYC5zdHJlYW0oKWAsIGAuc3RyZWFtRXZlbnRzKClgLCBldGMuIG1ldGhvZHMgdGhhdFxuICogb3RoZXIgcnVubmFibGVzIHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBiYXNlIFVSTCBvZiB0aGUgTGFuZ1NlcnZlIGVuZHBvaW50LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgcmVtb3RlIHJ1bm5hYmxlLCBpbmNsdWRpbmcgdGltZW91dCBhbmQgaGVhZGVycy5cbiAqIEBwYXJhbSBmZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBmZXRjaFJlcXVlc3RPcHRpb25zIC0gT3B0aW9uYWwgYWRkaXRpb25hbCBvcHRpb25zIGZvciBmZXRjaCByZXF1ZXN0cy5cbiAqL1xuY2xhc3MgUmVtb3RlUnVubmFibGUgZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXcmFwIHRoZSBkZWZhdWx0IGZldGNoIGNhbGwgZHVlIHRvIGlzc3VlcyB3aXRoIGlsbGVnYWwgaW52b2NhdGlvbnNcbiAgICAgICAgLy8gZnJvbSB0aGUgYnJvd3NlcjpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjk4NzY4NTkvd2h5LWRvZXMtYmluZC1maXgtZmFpbGVkLXRvLWV4ZWN1dGUtZmV0Y2gtb24td2luZG93LWlsbGVnYWwtaW52b2NhdGlvbi1lcnJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hJbXBsZW1lbnRhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKC4uLmFyZ3MpID0+IFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBCcm9hZCB0eXBpbmcgdG8gc3VwcG9ydCBhIHJhbmdlIG9mIGZldGNoIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgZmV0Y2goLi4uYXJncylcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoUmVxdWVzdE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzY2hlbWFcIiwgXCJydW5uYWJsZVwiLCBcInJlbW90ZVwiXVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB1cmwsIG9wdGlvbnMsIGZldGNoOiBmZXRjaEltcGxlbWVudGF0aW9uLCBmZXRjaFJlcXVlc3RPcHRpb25zLCB9ID0gZmllbGRzO1xuICAgICAgICB0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7IC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaEltcGxlbWVudGF0aW9uID8/IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgdGhpcy5mZXRjaFJlcXVlc3RPcHRpb25zID0gZmV0Y2hSZXF1ZXN0T3B0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgcG9zdChwYXRoLCBib2R5LCBzaWduYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihgJHt0aGlzLnVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShib2R5KSksXG4gICAgICAgICAgICBzaWduYWw6IHNpZ25hbCA/PyBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMub3B0aW9ucz8udGltZW91dCA/PyA2MDAwMCksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaFJlcXVlc3RPcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBvcHRpb25zLCBfKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWcsIGt3YXJnc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9pbnZva2VcIiwge1xuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBjb25maWc6IHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChjb25maWcpLFxuICAgICAgICAgICAga3dhcmdzOiBrd2FyZ3MgPz8ge30sXG4gICAgICAgIH0sIGNvbmZpZy5zaWduYWwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSBFcnJvcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZSgoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5vdXRwdXQpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBfLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmV0dXJuRXhjZXB0aW9ucyBpcyBub3Qgc3VwcG9ydGVkIGZvciByZW1vdGUgY2xpZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdzQW5kS3dhcmdzQXJyYXkgPSBvcHRpb25zPy5tYXAoKG9wdHMpID0+IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0cykpO1xuICAgICAgICBjb25zdCBbY29uZmlncywga3dhcmdzXSA9IGNvbmZpZ3NBbmRLd2FyZ3NBcnJheT8ucmVkdWNlKChbcGMsIHBrXSwgW2MsIGtdKSA9PiBbXG4gICAgICAgICAgICBbLi4ucGMsIGNdLFxuICAgICAgICAgICAgWy4uLnBrLCBrXSxcbiAgICAgICAgXSwgW1tdLCBbXV0pID8/IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KFwiL2JhdGNoXCIsIHtcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGNvbmZpZzogKGNvbmZpZ3MgPz8gW10pXG4gICAgICAgICAgICAgICAgLm1hcChyZW1vdmVDYWxsYmFja3NBbmRTaWduYWwpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29uZmlnKSA9PiAoeyAuLi5jb25maWcsIC4uLmJhdGNoT3B0aW9ucyB9KSksXG4gICAgICAgICAgICBrd2FyZ3MsXG4gICAgICAgIH0sIG9wdGlvbnM/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c30gRXJyb3I6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghYm9keS5vdXRwdXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gcmVtb3RlIHJ1bm5hYmxlXCIpO1xuICAgICAgICByZXR1cm4gcmV2aXZlKGJvZHkub3V0cHV0KTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJyZXR1cm5FeGNlcHRpb25zIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlbW90ZSBjbGllbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaFdpdGhDb25maWcodGhpcy5fYmF0Y2guYmluZCh0aGlzKSwgaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWcsIGt3YXJnc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvRGljdCkoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9zdHJlYW1cIiwge1xuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcmVtb3ZlQ2FsbGJhY2tzQW5kU2lnbmFsKGNvbmZpZyksXG4gICAgICAgICAgICAgICAga3dhcmdzLFxuICAgICAgICAgICAgfSwgY29uZmlnLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUmVtb3RlUnVubmFibGUgY2FsbCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c306ICR7anNvbi5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYmVnaW4gcmVtb3RlIHN0cmVhbS4gUGxlYXNlIGNoZWNrIHRoZSBnaXZlbiBVUkwgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9ICgwLCBldmVudF9zb3VyY2VfcGFyc2VfanNfMS5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtKShib2R5KTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDaHVuayA9IGRlc2VyaWFsaXplKGNodW5rKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBkZXNlcmlhbGl6ZWRDaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gZGVzZXJpYWxpemVkQ2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgZGVzZXJpYWxpemVkQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9KTtcbiAgICB9XG4gICAgYXN5bmMgKnN0cmVhbUxvZyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnLCBrd2FyZ3NdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb0RpY3QpKGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgLy8gVGhlIHR5cGUgaXMgaW4gY2FtZWxDYXNlIGJ1dCB0aGUgQVBJIG9ubHkgYWNjZXB0cyBzbmFrZV9jYXNlLlxuICAgICAgICBjb25zdCBjYW1lbENhc2VTdHJlYW1PcHRpb25zID0ge1xuICAgICAgICAgICAgaW5jbHVkZV9uYW1lczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZU5hbWVzLFxuICAgICAgICAgICAgaW5jbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVR5cGVzLFxuICAgICAgICAgICAgaW5jbHVkZV90YWdzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlVGFncyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfbmFtZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVOYW1lcyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfdHlwZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUeXBlcyxcbiAgICAgICAgICAgIGV4Y2x1ZGVfdGFnczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZVRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdChcIi9zdHJlYW1fbG9nXCIsIHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChjb25maWcpLFxuICAgICAgICAgICAgICAgIGt3YXJncyxcbiAgICAgICAgICAgICAgICAuLi5jYW1lbENhc2VTdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgICAgIGRpZmY6IGZhbHNlLFxuICAgICAgICAgICAgfSwgY29uZmlnLnNpZ25hbCk7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHksIG9rIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSBFcnJvcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYmVnaW4gcmVtb3RlIHN0cmVhbSBsb2cuIFBsZWFzZSBjaGVjayB0aGUgZ2l2ZW4gVVJMIGFuZCB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSAoMCwgZXZlbnRfc291cmNlX3BhcnNlX2pzXzEuY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbSkoYm9keSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcmV2aXZlKEpTT04ucGFyc2UobG9nKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nUGF0Y2ggPSBuZXcgbG9nX3N0cmVhbV9qc18xLlJ1bkxvZ1BhdGNoKHsgb3BzOiBjaHVuay5vcHMgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQgbG9nUGF0Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bkxvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkxvZyA9IGxvZ19zdHJlYW1fanNfMS5SdW5Mb2cuZnJvbVJ1bkxvZ1BhdGNoKGxvZ1BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nUGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQocnVuTG9nPy5zdGF0ZS5maW5hbF9vdXRwdXQpO1xuICAgIH1cbiAgICBfc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgW2NvbmZpZywga3dhcmdzXSA9IG91dGVyVGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KG91dGVyVGhpcy50b0pTT04oKSwgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9EaWN0KShpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAgICAgLy8gVGhlIHR5cGUgaXMgaW4gY2FtZWxDYXNlIGJ1dCB0aGUgQVBJIG9ubHkgYWNjZXB0cyBzbmFrZV9jYXNlLlxuICAgICAgICAgICAgY29uc3QgY2FtZWxDYXNlU3RyZWFtT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlX25hbWVzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlTmFtZXMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVR5cGVzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVfdGFnczogc3RyZWFtT3B0aW9ucz8uaW5jbHVkZVRhZ3MsXG4gICAgICAgICAgICAgICAgZXhjbHVkZV9uYW1lczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZU5hbWVzLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfdHlwZXM6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUeXBlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlX3RhZ3M6IHN0cmVhbU9wdGlvbnM/LmV4Y2x1ZGVUYWdzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG91dGVyVGhpcy5wb3N0KFwiL3N0cmVhbV9ldmVudHNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiByZW1vdmVDYWxsYmFja3NBbmRTaWduYWwoY29uZmlnKSxcbiAgICAgICAgICAgICAgICAgICAga3dhcmdzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jYW1lbENhc2VTdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkaWZmOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LCBjb25maWcuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJvZHksIG9rIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9IEVycm9yOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBiZWdpbiByZW1vdGUgc3RyZWFtIGV2ZW50cy4gUGxlYXNlIGNoZWNrIHRoZSBnaXZlbiBVUkwgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gKDAsIGV2ZW50X3NvdXJjZV9wYXJzZV9qc18xLmNvbnZlcnRFdmVudFN0cmVhbVRvSXRlcmFibGVSZWFkYWJsZURhdGFTdHJlYW0pKGJvZHkpO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIHJ1bm5hYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcmV2aXZlKEpTT04ucGFyc2UobG9nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGNodW5rLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2h1bmsubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogY2h1bmsucnVuX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogY2h1bmsudGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBjaHVuay5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChldmVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yKCk7XG4gICAgfVxuICAgIHN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uICE9PSBcInYxXCIgJiYgb3B0aW9ucy52ZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSB2ZXJzaW9ucyBcInYxXCIgYW5kIFwidjJcIiBvZiB0aGUgZXZlbnRzIHNjaGVtYSBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwZWNpYWwgZW5jb2RpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHJ1bm5hYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudFN0cmVhbSA9IHRoaXMuX3N0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcihldmVudFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdGVSdW5uYWJsZSA9IFJlbW90ZVJ1bm5hYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/router.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RouterRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nclass RouterRunnable extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\nexports.RouterRunnable = RouterRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JvdXRlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMENBQTBDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9yb3V0ZXIuY2pzPzdhZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdXRlclJ1bm5hYmxlID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCByb3V0ZXMgdG8gYSBzZXQgb2YgcnVubmFibGVzIGJhc2VkIG9uIElucHV0WydrZXknXS5cbiAqIFJldHVybnMgdGhlIG91dHB1dCBvZiB0aGUgc2VsZWN0ZWQgcnVubmFibGUuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUm91dGVyUnVubmFibGUsIFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyUnVubmFibGUoe1xuICogICBydW5uYWJsZXM6IHtcbiAqICAgICB0b1VwcGVyQ2FzZTogUnVubmFibGVMYW1iZGEuZnJvbSgodGV4dDogc3RyaW5nKSA9PiB0ZXh0LnRvVXBwZXJDYXNlKCkpLFxuICogICAgIHJldmVyc2VUZXh0OiBSdW5uYWJsZUxhbWJkYS5mcm9tKCh0ZXh0OiBzdHJpbmcpID0+XG4gKiAgICAgICB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpXG4gKiAgICAgKSxcbiAqICAgfSxcbiAqIH0pO1xuICpcbiAqIC8vIEludm9rZSB0aGUgJ3JldmVyc2VUZXh0JyBydW5uYWJsZVxuICogY29uc3QgcmVzdWx0MSA9IHJvdXRlci5pbnZva2UoeyBrZXk6IFwicmV2ZXJzZVRleHRcIiwgaW5wdXQ6IFwiSGVsbG8gV29ybGRcIiB9KTtcbiAqXG4gKiAvLyBcImRscm9XIG9sbGVIXCJcbiAqXG4gKiAvLyBJbnZva2UgdGhlICd0b1VwcGVyQ2FzZScgcnVubmFibGVcbiAqIGNvbnN0IHJlc3VsdDIgPSByb3V0ZXIuaW52b2tlKHsga2V5OiBcInRvVXBwZXJDYXNlXCIsIGlucHV0OiBcIkhlbGxvIFdvcmxkXCIgfSk7XG4gKlxuICogLy8gXCJIRUxMTyBXT1JMRFwiXG4gKiBgYGBcbiAqL1xuY2xhc3MgUm91dGVyUnVubmFibGUgZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSb3V0ZXJSdW5uYWJsZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZXMgPSBmaWVsZHMucnVubmFibGVzO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIGlucHV0OiBhY3R1YWxJbnB1dCB9ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlID0gdGhpcy5ydW5uYWJsZXNba2V5XTtcbiAgICAgICAgaWYgKHJ1bm5hYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVubmFibGUgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5uYWJsZS5pbnZva2UoYWN0dWFsSW5wdXQsICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5rZXkpO1xuICAgICAgICBjb25zdCBhY3R1YWxJbnB1dHMgPSBpbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpO1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5ID0ga2V5cy5maW5kKChrZXkpID0+IHRoaXMucnVubmFibGVzW2tleV0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtaXNzaW5nS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25lIG9yIG1vcmUga2V5cyBkbyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgcnVubmFibGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5ydW5uYWJsZXNba2V5XSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1heENvbmN1cnJlbmN5ID0gb3B0aW9uc0xpc3RbMF0/Lm1heENvbmN1cnJlbmN5ID8/IGJhdGNoT3B0aW9ucz8ubWF4Q29uY3VycmVuY3k7XG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IG1heENvbmN1cnJlbmN5ICYmIG1heENvbmN1cnJlbmN5ID4gMCA/IG1heENvbmN1cnJlbmN5IDogaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0dWFsSW5wdXRzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBhY3R1YWxJbnB1dHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSlcbiAgICAgICAgICAgICAgICAubWFwKChhY3R1YWxJbnB1dCwgaSkgPT4gcnVubmFibGVzW2ldLmludm9rZShhY3R1YWxJbnB1dCwgb3B0aW9uc0xpc3RbaV0pKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hQcm9taXNlcyk7XG4gICAgICAgICAgICBiYXRjaFJlc3VsdHMucHVzaChiYXRjaFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhdGNoUmVzdWx0cy5mbGF0KCk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgaW5wdXQ6IGFjdHVhbElucHV0IH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgcnVubmFibGUgPSB0aGlzLnJ1bm5hYmxlc1trZXldO1xuICAgICAgICBpZiAocnVubmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5uYWJsZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlLnN0cmVhbShhY3R1YWxJbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5Sb3V0ZXJSdW5uYWJsZSA9IFJvdXRlclJ1bm5hYmxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._RootEventFilter = exports.isRunnableInterface = void 0;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\nexports.isRunnableInterface = isRunnableInterface;\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\nexports._RootEventFilter = _RootEventFilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3V0aWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvdXRpbHMuY2pzPzUwNjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9Sb290RXZlbnRGaWx0ZXIgPSBleHBvcnRzLmlzUnVubmFibGVJbnRlcmZhY2UgPSB2b2lkIDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gaXNSdW5uYWJsZUludGVyZmFjZSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyA/IHRoaW5nLmxjX3J1bm5hYmxlIDogZmFsc2U7XG59XG5leHBvcnRzLmlzUnVubmFibGVJbnRlcmZhY2UgPSBpc1J1bm5hYmxlSW50ZXJmYWNlO1xuLyoqXG4gKiBVdGlsaXR5IHRvIGZpbHRlciB0aGUgcm9vdCBldmVudCBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICogVGhpcyBpcyBzaW1wbHkgYmluZGluZyB0aGUgYXJndW1lbnRzIHRvIHRoZSBuYW1lc3BhY2UgdG8gbWFrZSBzYXZlIG9uXG4gKiBhIGJpdCBvZiB0eXBpbmcgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUT0RPOiBSZWZhY3RvciBhbmQgcmVtb3ZlLlxuICovXG5jbGFzcyBfUm9vdEV2ZW50RmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzLmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHMuaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzLmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzLmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcy5leGNsdWRlVGFncztcbiAgICB9XG4gICAgaW5jbHVkZUV2ZW50KGV2ZW50LCByb290VHlwZSkge1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZXZlbnRUYWdzID0gZXZlbnQudGFncyA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fCBldmVudFRhZ3Muc29tZSgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKGV2ZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocm9vdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgZXZlbnRUYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG59XG5leHBvcnRzLl9Sb290RXZlbnRGaWx0ZXIgPSBfUm9vdEV2ZW50RmlsdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertToHttpEventStream = void 0;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(finalStream);\n}\nexports.convertToHttpEventStream = convertToHttpEventStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3dyYXBwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvd3JhcHBlcnMuY2pzPzkzMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5mdW5jdGlvbiBjb252ZXJ0VG9IdHRwRXZlbnRTdHJlYW0oc3RyZWFtKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGZpbmFsU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoYGV2ZW50OiBkYXRhXFxuZGF0YTogJHtKU09OLnN0cmluZ2lmeShjaHVuayl9XFxuXFxuYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKFwiZXZlbnQ6IGVuZFxcblxcblwiKSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKGZpbmFsU3RyZWFtKTtcbn1cbmV4cG9ydHMuY29udmVydFRvSHR0cEV2ZW50U3RyZWFtID0gY29udmVydFRvSHR0cEV2ZW50U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncLocalStorageProviderSingleton = exports._CONTEXT_VARIABLES_KEY = exports.MockAsyncLocalStorage = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n    enterWith(_store) {\n        return undefined;\n    }\n}\nexports.MockAsyncLocalStorage = MockAsyncLocalStorage;\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\nexports._CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    getRunnableConfig() {\n        const storage = this.getInstance();\n        // this has the runnable config\n        // which means that we should also have an instance of a LangChainTracer\n        // with the run map prepopulated\n        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n    }\n    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n        const callbackManager = manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n        const storage = this.getInstance();\n        const previousValue = storage.getStore();\n        const parentRunId = callbackManager?.getParentRunId();\n        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n        let runTree;\n        if (langChainTracer && parentRunId) {\n            runTree = langChainTracer.convertToRunTree(parentRunId);\n        }\n        else if (!avoidCreatingRootRunTree) {\n            runTree = new langsmith_1.RunTree({\n                name: \"<runnable_lambda>\",\n                tracingEnabled: false,\n            });\n        }\n        if (runTree) {\n            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n        }\n        if (previousValue !== undefined &&\n            previousValue[exports._CONTEXT_VARIABLES_KEY] !== undefined) {\n            runTree[exports._CONTEXT_VARIABLES_KEY] =\n                previousValue[exports._CONTEXT_VARIABLES_KEY];\n        }\n        return storage.run(runTree, callback);\n    }\n    initializeGlobalInstance(instance) {\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nexports.AsyncLocalStorageProviderSingleton = AsyncLocalStorageProviderSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsOEJBQThCLEdBQUcsNkJBQTZCO0FBQzNHO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMkRBQVc7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvaW5kZXguY2pzPzcwMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBleHBvcnRzLl9DT05URVhUX1ZBUklBQkxFU19LRVkgPSBleHBvcnRzLk1vY2tBc3luY0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGxhbmdzbWl0aF8xID0gcmVxdWlyZShcImxhbmdzbWl0aFwiKTtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oX3N0b3JlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZW50ZXJXaXRoKF9zdG9yZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gTW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuY29uc3QgbW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tBc3luY0xvY2FsU3RvcmFnZSgpO1xuY29uc3QgVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmNvbnN0IExDX0NISUxEX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjaGlsZF9jb25maWdcIik7XG5leHBvcnRzLl9DT05URVhUX1ZBUklBQkxFU19LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y29udGV4dF92YXJpYWJsZXNcIik7XG5jbGFzcyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIHtcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA/PyBtb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIGdldFJ1bm5hYmxlQ29uZmlnKCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAvLyB0aGlzIGhhcyB0aGUgcnVubmFibGUgY29uZmlnXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGFsc28gaGF2ZSBhbiBpbnN0YW5jZSBvZiBhIExhbmdDaGFpblRyYWNlclxuICAgICAgICAvLyB3aXRoIHRoZSBydW4gbWFwIHByZXBvcHVsYXRlZFxuICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRTdG9yZSgpPy5leHRyYT8uW0xDX0NISUxEX0tFWV07XG4gICAgfVxuICAgIHJ1bldpdGhDb25maWcoY29uZmlnLCBjYWxsYmFjaywgYXZvaWRDcmVhdGluZ1Jvb3RSdW5UcmVlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuX2NvbmZpZ3VyZVN5bmMoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gc3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQoKTtcbiAgICAgICAgY29uc3QgbGFuZ0NoYWluVHJhY2VyID0gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVycz8uZmluZCgoaGFuZGxlcikgPT4gaGFuZGxlcj8ubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICBsZXQgcnVuVHJlZTtcbiAgICAgICAgaWYgKGxhbmdDaGFpblRyYWNlciAmJiBwYXJlbnRSdW5JZCkge1xuICAgICAgICAgICAgcnVuVHJlZSA9IGxhbmdDaGFpblRyYWNlci5jb252ZXJ0VG9SdW5UcmVlKHBhcmVudFJ1bklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYXZvaWRDcmVhdGluZ1Jvb3RSdW5UcmVlKSB7XG4gICAgICAgICAgICBydW5UcmVlID0gbmV3IGxhbmdzbWl0aF8xLlJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiPHJ1bm5hYmxlX2xhbWJkYT5cIixcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuVHJlZSkge1xuICAgICAgICAgICAgcnVuVHJlZS5leHRyYSA9IHsgLi4ucnVuVHJlZS5leHRyYSwgW0xDX0NISUxEX0tFWV06IGNvbmZpZyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbZXhwb3J0cy5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5UcmVlW2V4cG9ydHMuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPVxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbZXhwb3J0cy5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZS5ydW4ocnVuVHJlZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/stores.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/stores.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryStore = exports.BaseStore = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\n/**\n * Abstract interface for a key-value store.\n */\nclass BaseStore extends serializable_js_1.Serializable {\n}\nexports.BaseStore = BaseStore;\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass InMemoryStore extends BaseStore {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"storage\"]\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    /**\n     * Retrieves the values associated with the given keys from the store.\n     * @param keys Keys to retrieve values for.\n     * @returns Array of values associated with the given keys.\n     */\n    async mget(keys) {\n        return keys.map((key) => this.store[key]);\n    }\n    /**\n     * Sets the values for the given keys in the store.\n     * @param keyValuePairs Array of key-value pairs to set in the store.\n     * @returns Promise that resolves when all key-value pairs have been set.\n     */\n    async mset(keyValuePairs) {\n        for (const [key, value] of keyValuePairs) {\n            this.store[key] = value;\n        }\n    }\n    /**\n     * Deletes the given keys and their associated values from the store.\n     * @param keys Keys to delete from the store.\n     * @returns Promise that resolves when all keys have been deleted.\n     */\n    async mdelete(keys) {\n        for (const key of keys) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * Asynchronous generator that yields keys from the store. If a prefix is\n     * provided, it only yields keys that start with the prefix.\n     * @param prefix Optional prefix to filter keys.\n     * @returns AsyncGenerator that yields keys from the store.\n     */\n    async *yieldKeys(prefix) {\n        const keys = Object.keys(this.store);\n        for (const key of keys) {\n            if (prefix === undefined || key.startsWith(prefix)) {\n                yield key;\n            }\n        }\n    }\n}\nexports.InMemoryStore = InMemoryStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc3RvcmVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc3RvcmVzLmNqcz9mNmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbk1lbW9yeVN0b3JlID0gZXhwb3J0cy5CYXNlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuL2xvYWQvc2VyaWFsaXphYmxlLmNqc1wiKTtcbi8qKlxuICogQWJzdHJhY3QgaW50ZXJmYWNlIGZvciBhIGtleS12YWx1ZSBzdG9yZS5cbiAqL1xuY2xhc3MgQmFzZVN0b3JlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbn1cbmV4cG9ydHMuQmFzZVN0b3JlID0gQmFzZVN0b3JlO1xuLyoqXG4gKiBJbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgdGhlIEJhc2VTdG9yZSB1c2luZyBhIGRpY3Rpb25hcnkuIFVzZWQgZm9yXG4gKiBzdG9yaW5nIGtleS12YWx1ZSBwYWlycyBpbiBtZW1vcnkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3Qgc3RvcmUgPSBuZXcgSW5NZW1vcnlTdG9yZTxCYXNlTWVzc2FnZT4oKTtcbiAqIGF3YWl0IHN0b3JlLm1zZXQoXG4gKiAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSkubWFwKChfLCBpbmRleCkgPT4gW1xuICogICAgIGBtZXNzYWdlOmlkOiR7aW5kZXh9YCxcbiAqICAgICBpbmRleCAlIDIgPT09IDBcbiAqICAgICAgID8gbmV3IEFJTWVzc2FnZShcImFpIHN0dWZmLi4uXCIpXG4gKiAgICAgICA6IG5ldyBIdW1hbk1lc3NhZ2UoXCJodW1hbiBzdHVmZi4uLlwiKSxcbiAqICAgXSksXG4gKiApO1xuICpcbiAqIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gYXdhaXQgc3RvcmUubWdldChbXCJtZXNzYWdlOmlkOjBcIiwgXCJtZXNzYWdlOmlkOjFcIl0pO1xuICogYXdhaXQgc3RvcmUubWRlbGV0ZShhd2FpdCBzdG9yZS55aWVsZEtleXMoXCJtZXNzYWdlOmlkOlwiKS50b0FycmF5KCkpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBJbk1lbW9yeVN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJzdG9yYWdlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ga2V5cyBLZXlzIHRvIHJldHJpZXZlIHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICAgKi9cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IHRoaXMuc3RvcmVba2V5XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBrZXlWYWx1ZVBhaXJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlycyB0byBzZXQgaW4gdGhlIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBrZXktdmFsdWUgcGFpcnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBhc3luYyBtc2V0KGtleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVQYWlycykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZ2l2ZW4ga2V5cyBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGtleXMgS2V5cyB0byBkZWxldGUgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGtleXMgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIGdlbmVyYXRvciB0aGF0IHlpZWxkcyBrZXlzIGZyb20gdGhlIHN0b3JlLiBJZiBhIHByZWZpeCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBvbmx5IHlpZWxkcyBrZXlzIHRoYXQgc3RhcnQgd2l0aCB0aGUgcHJlZml4LlxuICAgICAqIEBwYXJhbSBwcmVmaXggT3B0aW9uYWwgcHJlZml4IHRvIGZpbHRlciBrZXlzLlxuICAgICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHRoYXQgeWllbGRzIGtleXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgKnlpZWxkS2V5cyhwcmVmaXgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQgfHwga2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5NZW1vcnlTdG9yZSA9IEluTWVtb3J5U3RvcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tool = exports.BaseToolkit = exports.DynamicStructuredTool = exports.DynamicTool = exports.Tool = exports.StructuredTool = exports.ToolInputParsingException = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ../messages/tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nObject.defineProperty(exports, \"ToolInputParsingException\", ({ enumerable: true, get: function () { return utils_js_1.ToolInputParsingException; } }));\nconst is_zod_schema_js_1 = __webpack_require__(/*! ../utils/types/is_zod_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs\");\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nclass StructuredTool extends base_js_1.BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        // TODO: Make default in 0.3\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async invoke(input, config) {\n        let tool_call_id;\n        let toolInput;\n        if ((0, utils_js_1._isToolCall)(input)) {\n            tool_call_id = input.id;\n            toolInput = input.args;\n        }\n        else {\n            toolInput = input;\n        }\n        const ensuredConfig = (0, config_js_1.ensureConfig)(config);\n        return this.call(toolInput, {\n            ...ensuredConfig,\n            configurable: {\n                ...ensuredConfig.configurable,\n                tool_call_id,\n            },\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        let parsed;\n        try {\n            parsed = await this.schema.parseAsync(arg);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            let message = `Received tool input did not match expected schema`;\n            if (this.verboseParsingErrors) {\n                message = `${message}\\nDetails: ${e.message}`;\n            }\n            throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n        }\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            result = await this._call(parsed, runManager, config);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        if (config && \"configurable\" in config) {\n            toolCallId = config.configurable\n                .tool_call_id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\nexports.StructuredTool = StructuredTool;\n/**\n * Base class for Tools that accept input as a string.\n */\nclass Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: zod_1.z\n                .object({ input: zod_1.z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call(arg, callbacks) {\n        return super.call(typeof arg === \"string\" || !arg ? { input: arg } : arg, callbacks);\n    }\n}\nexports.Tool = Tool;\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nclass DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\nexports.DynamicTool = DynamicTool;\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nclass DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = ((0, is_zod_schema_js_1.isZodSchema)(fields.schema) ? fields.schema : zod_1.z.object({}).passthrough());\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.func(arg, runManager, parentConfig);\n    }\n}\nexports.DynamicStructuredTool = DynamicStructuredTool;\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nclass BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nexports.BaseToolkit = BaseToolkit;\nfunction tool(func, fields) {\n    // If the schema is not provided, or it's a string schema, create a DynamicTool\n    if (!fields.schema ||\n        ((0, is_zod_schema_js_1.isZodSchema)(fields.schema) &&\n            (!(\"shape\" in fields.schema) || !fields.schema.shape))) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                fields.schema?.description ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schema: fields.schema,\n        // TODO: Consider moving into DynamicStructuredTool constructor\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n                    try {\n                        // TS doesn't restrict the type here based on the guard above\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nexports.tool = tool;\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId } = params;\n    if (toolCallId) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new tool_js_1.ToolMessage({\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n        else {\n            return new tool_js_1.ToolMessage({\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2);\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxtQkFBbUIsR0FBRyw2QkFBNkIsR0FBRyxtQkFBbUIsR0FBRyxZQUFZLEdBQUcsc0JBQXNCLEdBQUcsaUNBQWlDO0FBQ3BLLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsdUdBQTZCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3hDLDZEQUE0RCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUNwSiwyQkFBMkIsbUJBQU8sQ0FBQyxpSEFBa0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxhQUFhLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTEFBa0wsdUJBQXVCO0FBQ3pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCx1QkFBdUI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYTtBQUMzRTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL2luZGV4LmNqcz81MzExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b29sID0gZXhwb3J0cy5CYXNlVG9vbGtpdCA9IGV4cG9ydHMuRHluYW1pY1N0cnVjdHVyZWRUb29sID0gZXhwb3J0cy5EeW5hbWljVG9vbCA9IGV4cG9ydHMuVG9vbCA9IGV4cG9ydHMuU3RydWN0dXJlZFRvb2wgPSBleHBvcnRzLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL2xhbmd1YWdlX21vZGVscy9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9jb25maWcuY2pzXCIpO1xuY29uc3QgdG9vbF9qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL3Rvb2wuY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2luZGV4LmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18xLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb247IH0gfSk7XG5jb25zdCBpc196b2Rfc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdHlwZXMvaXNfem9kX3NjaGVtYS5janNcIik7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFRvb2xzIHRoYXQgYWNjZXB0IGlucHV0IG9mIGFueSBzaGFwZSBkZWZpbmVkIGJ5IGEgWm9kIHNjaGVtYS5cbiAqL1xuY2xhc3MgU3RydWN0dXJlZFRvb2wgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZUxhbmdDaGFpbiB7XG4gICAgZ2V0IGxjX25hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcImxhbmdjaGFpblwiLCBcInRvb2xzXCJdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuRGlyZWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogTWFrZSBkZWZhdWx0IGluIDAuM1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJib3NlUGFyc2luZ0Vycm9yc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbCByZXNwb25zZSBmb3JtYXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIFwiY29udGVudFwiIHRoZW4gdGhlIG91dHB1dCBvZiB0aGUgdG9vbCBpcyBpbnRlcnByZXRlZCBhcyB0aGUgY29udGVudHMgb2YgYVxuICAgICAgICAgKiBUb29sTWVzc2FnZS4gSWYgXCJjb250ZW50X2FuZF9hcnRpZmFjdFwiIHRoZW4gdGhlIG91dHB1dCBpcyBleHBlY3RlZCB0byBiZSBhXG4gICAgICAgICAqIHR3by10dXBsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSAoY29udGVudCwgYXJ0aWZhY3QpIG9mIGEgVG9vbE1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IFwiY29udGVudFwiXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZUZvcm1hdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjb250ZW50XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnMgPVxuICAgICAgICAgICAgZmllbGRzPy52ZXJib3NlUGFyc2luZ0Vycm9ycyA/PyB0aGlzLnZlcmJvc2VQYXJzaW5nRXJyb3JzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlRm9ybWF0ID0gZmllbGRzPy5yZXNwb25zZUZvcm1hdCA/PyB0aGlzLnJlc3BvbnNlRm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRvb2wuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBsZXQgdG9vbF9jYWxsX2lkO1xuICAgICAgICBsZXQgdG9vbElucHV0O1xuICAgICAgICBpZiAoKDAsIHV0aWxzX2pzXzEuX2lzVG9vbENhbGwpKGlucHV0KSkge1xuICAgICAgICAgICAgdG9vbF9jYWxsX2lkID0gaW5wdXQuaWQ7XG4gICAgICAgICAgICB0b29sSW5wdXQgPSBpbnB1dC5hcmdzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5zdXJlZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwodG9vbElucHV0LCB7XG4gICAgICAgICAgICAuLi5lbnN1cmVkQ29uZmlnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB7XG4gICAgICAgICAgICAgICAgLi4uZW5zdXJlZENvbmZpZy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQsIGNvbmZpZ3VyYXRpb24sIGFuZCB0YWdzLiBJdFxuICAgICAqIHBhcnNlcyB0aGUgaW5wdXQgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIGhhbmRsZXMgYW55IGVycm9ycywgYW5kXG4gICAgICogbWFuYWdlcyBjYWxsYmFja3MuXG4gICAgICogQHBhcmFtIGFyZyBUaGUgaW5wdXQgYXJndW1lbnQgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSBjb25maWdBcmcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvciBjYWxsYmFja3MgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSB0YWdzIE9wdGlvbmFsIHRhZ3MgZm9yIHRoZSB0b29sLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgdGFncykge1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkID0gYXdhaXQgdGhpcy5zY2hlbWEucGFyc2VBc3luYyhhcmcpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWA7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlUGFyc2luZ0Vycm9ycykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbkRldGFpbHM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgdXRpbHNfanNfMS5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uKG1lc3NhZ2UsIEpTT04uc3RyaW5naWZ5KGFyZykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBtYW5hZ2VyX2pzXzEucGFyc2VDYWxsYmFja0NvbmZpZ0FyZykoY29uZmlnQXJnKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBjb25maWcudGFncyB8fCB0YWdzLCB0aGlzLnRhZ3MsIGNvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVUb29sU3RhcnQodGhpcy50b0pTT04oKSwgdHlwZW9mIHBhcnNlZCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlZCA6IEpTT04uc3RyaW5naWZ5KHBhcnNlZCksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY2FsbChwYXJzZWQsIHJ1bk1hbmFnZXIsIGNvbmZpZyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUb29sRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICBsZXQgYXJ0aWZhY3Q7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlRm9ybWF0ID09PSBcImNvbnRlbnRfYW5kX2FydGlmYWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIFtjb250ZW50LCBhcnRpZmFjdF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgcmVzcG9uc2UgZm9ybWF0IGlzIFwiY29udGVudF9hbmRfYXJ0aWZhY3RcIiBidXQgdGhlIG91dHB1dCB3YXMgbm90IGEgdHdvLXR1cGxlLlxcblJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbENhbGxJZDtcbiAgICAgICAgaWYgKGNvbmZpZyAmJiBcImNvbmZpZ3VyYWJsZVwiIGluIGNvbmZpZykge1xuICAgICAgICAgICAgdG9vbENhbGxJZCA9IGNvbmZpZy5jb25maWd1cmFibGVcbiAgICAgICAgICAgICAgICAudG9vbF9jYWxsX2lkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE91dHB1dCA9IF9mb3JtYXRUb29sT3V0cHV0KHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBhcnRpZmFjdCxcbiAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUb29sRW5kKGZvcm1hdHRlZE91dHB1dCk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRPdXRwdXQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmVkVG9vbCA9IFN0cnVjdHVyZWRUb29sO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBUb29scyB0aGF0IGFjY2VwdCBpbnB1dCBhcyBhIHN0cmluZy5cbiAqL1xuY2xhc3MgVG9vbCBleHRlbmRzIFN0cnVjdHVyZWRUb29sIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGlucHV0OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCkgfSlcbiAgICAgICAgICAgICAgICAudHJhbnNmb3JtKChvYmopID0+IG9iai5pbnB1dClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQgYW5kIGNhbGxiYWNrcy4gSXQgaGFuZGxlc1xuICAgICAqIHN0cmluZyBpbnB1dHMgc3BlY2lmaWNhbGx5LlxuICAgICAqIEBwYXJhbSBhcmcgVGhlIGlucHV0IGFyZ3VtZW50IGZvciB0aGUgdG9vbCwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nLCB1bmRlZmluZWQsIG9yIGFuIGlucHV0IG9mIHRoZSB0b29sJ3Mgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgT3B0aW9uYWwgY2FsbGJhY2tzIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGNhbGwoYXJnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiB8fCAhYXJnID8geyBpbnB1dDogYXJnIH0gOiBhcmcsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sID0gVG9vbDtcbi8qKlxuICogQSB0b29sIHRoYXQgY2FuIGJlIGNyZWF0ZWQgZHluYW1pY2FsbHkgZnJvbSBhIGZ1bmN0aW9uLCBuYW1lLCBhbmQgZGVzY3JpcHRpb24uXG4gKi9cbmNsYXNzIER5bmFtaWNUb29sIGV4dGVuZHMgVG9vbCB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkR5bmFtaWNUb29sXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgICAgICB0aGlzLnJldHVybkRpcmVjdCA9IGZpZWxkcy5yZXR1cm5EaXJlY3QgPz8gdGhpcy5yZXR1cm5EaXJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwoYXJnLCBjb25maWdBcmcpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIG1hbmFnZXJfanNfMS5wYXJzZUNhbGxiYWNrQ29uZmlnQXJnKShjb25maWdBcmcpO1xuICAgICAgICBpZiAoY29uZmlnLnJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLnJ1bk5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoYXJnLCBjb25maWcpO1xuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGFzeW5jIF9jYWxsKGlucHV0LCBydW5NYW5hZ2VyLCBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhpbnB1dCwgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLkR5bmFtaWNUb29sID0gRHluYW1pY1Rvb2w7XG4vKipcbiAqIEEgdG9vbCB0aGF0IGNhbiBiZSBjcmVhdGVkIGR5bmFtaWNhbGx5IGZyb20gYSBmdW5jdGlvbiwgbmFtZSwgYW5kXG4gKiBkZXNjcmlwdGlvbiwgZGVzaWduZWQgdG8gd29yayB3aXRoIHN0cnVjdHVyZWQgZGF0YS4gSXQgZXh0ZW5kcyB0aGVcbiAqIFN0cnVjdHVyZWRUb29sIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIF9jYWxsIG1ldGhvZCB0byBleGVjdXRlIHRoZVxuICogcHJvdmlkZWQgZnVuY3Rpb24gd2hlbiB0aGUgdG9vbCBpcyBjYWxsZWQuXG4gKlxuICogU2NoZW1hIGNhbiBiZSBwYXNzZWQgYXMgWm9kIG9yIEpTT04gc2NoZW1hLiBUaGUgdG9vbCB3aWxsIG5vdCB2YWxpZGF0ZVxuICogaW5wdXQgaWYgSlNPTiBzY2hlbWEgaXMgcGFzc2VkLlxuICovXG5jbGFzcyBEeW5hbWljU3RydWN0dXJlZFRvb2wgZXh0ZW5kcyBTdHJ1Y3R1cmVkVG9vbCB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkR5bmFtaWNTdHJ1Y3R1cmVkVG9vbFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIHRoaXMucmV0dXJuRGlyZWN0ID0gZmllbGRzLnJldHVybkRpcmVjdCA/PyB0aGlzLnJldHVybkRpcmVjdDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSAoKDAsIGlzX3pvZF9zY2hlbWFfanNfMS5pc1pvZFNjaGVtYSkoZmllbGRzLnNjaGVtYSkgPyBmaWVsZHMuc2NoZW1hIDogem9kXzEuei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKGFyZywgY29uZmlnQXJnLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICB0YWdzKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBtYW5hZ2VyX2pzXzEucGFyc2VDYWxsYmFja0NvbmZpZ0FyZykoY29uZmlnQXJnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5ydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5ydW5OYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5jYWxsKGFyZywgY29uZmlnLCB0YWdzKTtcbiAgICB9XG4gICAgX2NhbGwoYXJnLCBydW5NYW5hZ2VyLCBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhhcmcsIHJ1bk1hbmFnZXIsIHBhcmVudENvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5EeW5hbWljU3RydWN0dXJlZFRvb2wgPSBEeW5hbWljU3RydWN0dXJlZFRvb2w7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRvb2xraXRzIGluIExhbmdDaGFpbi4gVG9vbGtpdHMgYXJlIGNvbGxlY3Rpb25zXG4gKiBvZiB0b29scyB0aGF0IGFnZW50cyBjYW4gdXNlLiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoZSBgdG9vbHNgXG4gKiBwcm9wZXJ0eSB0byBwcm92aWRlIHRoZSBzcGVjaWZpYyB0b29scyBmb3IgdGhlIHRvb2xraXQuXG4gKi9cbmNsYXNzIEJhc2VUb29sa2l0IHtcbiAgICBnZXRUb29scygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbHM7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlVG9vbGtpdCA9IEJhc2VUb29sa2l0O1xuZnVuY3Rpb24gdG9vbChmdW5jLCBmaWVsZHMpIHtcbiAgICAvLyBJZiB0aGUgc2NoZW1hIGlzIG5vdCBwcm92aWRlZCwgb3IgaXQncyBhIHN0cmluZyBzY2hlbWEsIGNyZWF0ZSBhIER5bmFtaWNUb29sXG4gICAgaWYgKCFmaWVsZHMuc2NoZW1hIHx8XG4gICAgICAgICgoMCwgaXNfem9kX3NjaGVtYV9qc18xLmlzWm9kU2NoZW1hKShmaWVsZHMuc2NoZW1hKSAmJlxuICAgICAgICAgICAgKCEoXCJzaGFwZVwiIGluIGZpZWxkcy5zY2hlbWEpIHx8ICFmaWVsZHMuc2NoZW1hLnNoYXBlKSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEeW5hbWljVG9vbCh7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmllbGRzLmRlc2NyaXB0aW9uID8/XG4gICAgICAgICAgICAgICAgZmllbGRzLnNjaGVtYT8uZGVzY3JpcHRpb24gPz9cbiAgICAgICAgICAgICAgICBgJHtmaWVsZHMubmFtZX0gdG9vbGAsXG4gICAgICAgICAgICBmdW5jOiBhc3luYyAoaW5wdXQsIHJ1bk1hbmFnZXIsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoY2hpbGRDb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFMgZG9lc24ndCByZXN0cmljdCB0aGUgdHlwZSBoZXJlIGJhc2VkIG9uIHRoZSBndWFyZCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jKGlucHV0LCBjaGlsZENvbmZpZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uID8/IGZpZWxkcy5zY2hlbWEuZGVzY3JpcHRpb24gPz8gYCR7ZmllbGRzLm5hbWV9IHRvb2xgO1xuICAgIHJldHVybiBuZXcgRHluYW1pY1N0cnVjdHVyZWRUb29sKHtcbiAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgc2NoZW1hOiBmaWVsZHMuc2NoZW1hLFxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgaW50byBEeW5hbWljU3RydWN0dXJlZFRvb2wgY29uc3RydWN0b3JcbiAgICAgICAgZnVuYzogYXN5bmMgKGlucHV0LCBydW5NYW5hZ2VyLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdm9pZCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFMgZG9lc24ndCByZXN0cmljdCB0aGUgdHlwZSBoZXJlIGJhc2VkIG9uIHRoZSBndWFyZCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuYyhpbnB1dCwgY2hpbGRDb25maWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudG9vbCA9IHRvb2w7XG5mdW5jdGlvbiBfZm9ybWF0VG9vbE91dHB1dChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIGFydGlmYWN0LCB0b29sQ2FsbElkIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjb250ZW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbnRlbnQuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9zdHJpbmdpZnkoY29udGVudCksXG4gICAgICAgICAgICAgICAgYXJ0aWZhY3QsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9zdHJpbmdpZnkoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb250ZW50LCBudWxsLCAyKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9ub09wKSB7XG4gICAgICAgIHJldHVybiBgJHtjb250ZW50fWA7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/utils.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolInputParsingException = exports._isToolCall = void 0;\nfunction _isToolCall(toolCall) {\n    return !!(toolCall &&\n        typeof toolCall === \"object\" &&\n        \"type\" in toolCall &&\n        toolCall.type === \"tool_call\");\n}\nexports._isToolCall = _isToolCall;\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nclass ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\nexports.ToolInputParsingException = ToolInputParsingException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL3V0aWxzLmNqcz8zMTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uID0gZXhwb3J0cy5faXNUb29sQ2FsbCA9IHZvaWQgMDtcbmZ1bmN0aW9uIF9pc1Rvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgcmV0dXJuICEhKHRvb2xDYWxsICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInR5cGVcIiBpbiB0b29sQ2FsbCAmJlxuICAgICAgICB0b29sQ2FsbC50eXBlID09PSBcInRvb2xfY2FsbFwiKTtcbn1cbmV4cG9ydHMuX2lzVG9vbENhbGwgPSBfaXNUb29sQ2FsbDtcbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIHVzZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMgcmVsYXRlZCB0byB0b29sIGlucHV0IHBhcnNpbmcuXG4gKiBJdCBleHRlbmRzIHRoZSBidWlsdC1pbiBgRXJyb3JgIGNsYXNzIGFuZCBhZGRzIGFuIG9wdGlvbmFsIGBvdXRwdXRgXG4gKiBwcm9wZXJ0eSB0aGF0IGNhbiBob2xkIHRoZSBvdXRwdXQgdGhhdCBjYXVzZWQgdGhlIGV4Y2VwdGlvbi5cbiAqL1xuY2xhc3MgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvdXRwdXQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24gPSBUb29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseTracer = exports.isBaseTracer = void 0;\nconst base_js_1 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder) {\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n}\nfunction isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nexports.isBaseTracer = isBaseTracer;\nclass BaseTracer extends base_js_1.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    copy() {\n        return this;\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id, run.execution_order);\n        const storedRun = { ...run };\n        if (storedRun.parent_run_id !== undefined) {\n            const parentRun = this.runMap.get(storedRun.parent_run_id);\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n        }\n        this.runMap.set(storedRun.id, storedRun);\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        this.runMap.delete(run.id);\n        await this.onRunUpdate?.(run);\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.runMap.get(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\nexports.BaseTracer = BaseTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxvQkFBb0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQ0FBMkMsRUFBRSxZQUFZO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQsU0FBUztBQUNULGlEQUFpRCxzQkFBc0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvYmFzZS5janM/YjU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVRyYWNlciA9IGV4cG9ydHMuaXNCYXNlVHJhY2VyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9iYXNlLmNqc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyKSB7XG4gICAgY29uc3QgcGFkZGVkT3JkZXIgPSBleGVjdXRpb25PcmRlci50b0ZpeGVkKDApLnNsaWNlKDAsIDMpLnBhZFN0YXJ0KDMsIFwiMFwiKTtcbiAgICByZXR1cm4gKHN0cmlwTm9uQWxwaGFudW1lcmljKGAke25ldyBEYXRlKGVwb2NoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKX0ke3BhZGRlZE9yZGVyfVpgKSArIHJ1bklkKTtcbn1cbmZ1bmN0aW9uIGlzQmFzZVRyYWNlcih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4Ll9hZGRSdW5Ub1J1bk1hcCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0Jhc2VUcmFjZXIgPSBpc0Jhc2VUcmFjZXI7XG5jbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKF9maWVsZHMpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdHJpbmdpZnlFcnJvcihlcnJvcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZSArIChlcnJvcj8uc3RhY2sgPyBgXFxuXFxuJHtlcnJvci5zdGFja31gIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlcnJvcn1gO1xuICAgIH1cbiAgICBfYWRkQ2hpbGRSdW4ocGFyZW50UnVuLCBjaGlsZFJ1bikge1xuICAgICAgICBwYXJlbnRSdW4uY2hpbGRfcnVucy5wdXNoKGNoaWxkUnVuKTtcbiAgICB9XG4gICAgX2FkZFJ1blRvUnVuTWFwKHJ1bikge1xuICAgICAgICBjb25zdCBjdXJyZW50RG90dGVkT3JkZXIgPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChydW4uc3RhcnRfdGltZSwgcnVuLmlkLCBydW4uZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkUnVuID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHN0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHRoaXMucnVuTWFwLmdldChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgICAgICBpZiAocGFyZW50UnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGRSdW4ocGFyZW50UnVuLCBzdG9yZWRSdW4pO1xuICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBzdG9yZWRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgICAgICBzdG9yZWRSdW4udHJhY2VfaWQgPSBwYXJlbnRSdW4udHJhY2VfaWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRSdW4uZG90dGVkX29yZGVyID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREb3R0ZWRPcmRlcixcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBuYXR1cmFsbHkgZm9yIGNhbGxiYWNrcyBhZGRlZCB3aXRoaW4gYSBydW5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgUGFyZW50IHJ1biB3aXRoIFVVSUQgJHtzdG9yZWRSdW4ucGFyZW50X3J1bl9pZH0gaGFzIG5vIGRvdHRlZCBvcmRlci5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gbmF0dXJhbGx5IGZvciBjYWxsYmFja3MgYWRkZWQgd2l0aGluIGEgcnVuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAvLyAgIGBQYXJlbnQgcnVuIHdpdGggVVVJRCAke3N0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkfSBub3QgZm91bmQuYFxuICAgICAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9yZWRSdW4udHJhY2VfaWQgPSBzdG9yZWRSdW4uaWQ7XG4gICAgICAgICAgICBzdG9yZWRSdW4uZG90dGVkX29yZGVyID0gY3VycmVudERvdHRlZE9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuTWFwLnNldChzdG9yZWRSdW4uaWQsIHN0b3JlZFJ1bik7XG4gICAgICAgIHJldHVybiBzdG9yZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIF9lbmRUcmFjZShydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuID0gcnVuLnBhcmVudF9ydW5faWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJ1bk1hcC5nZXQocnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICBpZiAocGFyZW50UnVuKSB7XG4gICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgcnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RSdW4ocnVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bk1hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1blVwZGF0ZT8uKHJ1bik7XG4gICAgfVxuICAgIF9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBwYXJlbnRSdW5JZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucnVuTWFwLmdldChwYXJlbnRSdW5JZCk7XG4gICAgICAgIC8vIElmIGEgcnVuIGhhcyBubyBwYXJlbnQgdGhlbiBleGVjdXRpb24gb3JkZXIgaXMgMVxuICAgICAgICBpZiAoIXBhcmVudFJ1bikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgTExNIHN0YXJ0IGV2ZW50cy5cbiAgICAgKiBUaGlzIG11c3Qgc29tZXRpbWVzIGJlIGRvbmUgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLCBzbyB3ZSBleHBvc2UgaXQgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZS5cbiAgICAgKi9cbiAgICBfY3JlYXRlUnVuRm9yTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcHJvbXB0cyB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAgICAgICAgZXh0cmE6IGZpbmFsRXh0cmFQYXJhbXMgPz8ge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpID8/XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5Gb3JMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciBjaGF0IG1vZGVsIHN0YXJ0IGV2ZW50cy5cbiAgICAgKiBUaGlzIG11c3Qgc29tZXRpbWVzIGJlIGRvbmUgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLCBzbyB3ZSBleHBvc2UgaXQgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZS5cbiAgICAgKi9cbiAgICBfY3JlYXRlUnVuRm9yQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxFeHRyYVBhcmFtcyA9IG1ldGFkYXRhXG4gICAgICAgICAgICA/IHsgLi4uZXh0cmFQYXJhbXMsIG1ldGFkYXRhIH1cbiAgICAgICAgICAgIDogZXh0cmFQYXJhbXM7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gbGxtLmlkW2xsbS5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGxsbSxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICAgICAgICBleHRyYTogZmluYWxFeHRyYVBhcmFtcyA/PyB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpID8/XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhaW4gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHRvb2wgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHJldHJpZXZlciBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyByZXRyaWV2ZXIuaWRbcmV0cmlldmVyLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcmV0cmlldmVyLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcXVlcnkgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwicmV0cmlldmVyXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IHsgZG9jdW1lbnRzIH07XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRleHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25UZXh0Py4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJydW5JZFwiIHByb3ZpZGVkIHRvIFwiaGFuZGxlTExNTmV3VG9rZW5cIiBjYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJuZXdfdG9rZW5cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0b2tlbiwgaWR4LCBjaHVuazogZmllbGRzPy5jaHVuayB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTU5ld1Rva2VuPy4ocnVuLCB0b2tlbiwgeyBjaHVuazogZmllbGRzPy5jaHVuayB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VUcmFjZXIgPSBCYXNlVHJhY2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConsoleCallbackHandler = void 0;\nconst ansi_styles_1 = __importDefault(__webpack_require__(/*! ansi-styles */ \"(rsc)/./node_modules/ansi-styles/index.js\"));\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction formatKVMapItem(value) {\n    if (typeof value === \"string\") {\n        return value.trim();\n    }\n    if (value === null || value === undefined) {\n        return value;\n    }\n    return tryJsonStringify(value, value.toString());\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles_1.default;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends base_js_1.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles_1.default.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\nexports.ConsoleCallbackHandler = ConsoleCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9jb25zb2xlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixzQ0FBc0MsbUJBQU8sQ0FBQyw4REFBYTtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBLGNBQWMsV0FBVyxFQUFFLEtBQUssRUFBRSxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLFlBQVk7QUFDckY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLG1DQUFtQyx5Q0FBeUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUMsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMsMkNBQTJDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxLQUFLLGFBQWEsa0NBQWtDLHVDQUF1QztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxpQ0FBaUMscUNBQXFDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLDRDQUE0QztBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGdDQUFnQyx1Q0FBdUM7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUMsR0FBRyxPQUFPLG1DQUFtQyxrQ0FBa0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMscUNBQXFDO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLHVDQUF1QztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QyxHQUFHLE9BQU8sdUNBQXVDLHlDQUF5QztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQyxHQUFHLE9BQU8sS0FBSyxhQUFhLHVDQUF1QywyQ0FBMkM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0MsR0FBRyxPQUFPLEtBQUssYUFBYSxzQ0FBc0MsdUNBQXVDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLDJCQUEyQiw0RUFBNEU7QUFDNUs7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2NvbnNvbGUuY2pzPzkwNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnNvbGVDYWxsYmFja0hhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBhbnNpX3N0eWxlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNpLXN0eWxlc1wiKSk7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmZ1bmN0aW9uIHdyYXAoc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gYCR7c3R5bGUub3Blbn0ke3RleHR9JHtzdHlsZS5jbG9zZX1gO1xufVxuZnVuY3Rpb24gdHJ5SnNvblN0cmluZ2lmeShvYmosIGZhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEtWTWFwSXRlbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ5SnNvblN0cmluZ2lmeSh2YWx1ZSwgdmFsdWUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBlbGFwc2VkKHJ1bikge1xuICAgIGlmICghcnVuLmVuZF90aW1lKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBlbGFwc2VkID0gcnVuLmVuZF90aW1lIC0gcnVuLnN0YXJ0X3RpbWU7XG4gICAgaWYgKGVsYXBzZWQgPCAxMDAwKSB7XG4gICAgICAgIHJldHVybiBgJHtlbGFwc2VkfW1zYDtcbiAgICB9XG4gICAgcmV0dXJuIGAkeyhlbGFwc2VkIC8gMTAwMCkudG9GaXhlZCgyKX1zYDtcbn1cbmNvbnN0IHsgY29sb3IgfSA9IGFuc2lfc3R5bGVzXzEuZGVmYXVsdDtcbi8qKlxuICogQSB0cmFjZXIgdGhhdCBsb2dzIGFsbCBldmVudHMgdG8gdGhlIGNvbnNvbGUuIEl0IGV4dGVuZHMgZnJvbSB0aGVcbiAqIGBCYXNlVHJhY2VyYCBjbGFzcyBhbmQgb3ZlcnJpZGVzIGl0cyBtZXRob2RzIHRvIHByb3ZpZGUgY3VzdG9tIGxvZ2dpbmdcbiAqIGZ1bmN0aW9uYWxpdHkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqIGNvbnN0IGxsbSA9IG5ldyBDaGF0QW50aHJvcGljKHtcbiAqICAgdGVtcGVyYXR1cmU6IDAsXG4gKiAgIHRhZ3M6IFtcImV4YW1wbGVcIiwgXCJjYWxsYmFja3NcIiwgXCJjb25zdHJ1Y3RvclwiXSxcbiAqICAgY2FsbGJhY2tzOiBbbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKV0sXG4gKiB9KTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29uc29sZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcGVyc2lzdCB0aGUgcnVuLiBJbiB0aGlzIGNhc2UsIGl0IHNpbXBseSByZXR1cm5zIGFcbiAgICAgKiByZXNvbHZlZCBwcm9taXNlIGFzIHRoZXJlJ3Mgbm8gcGVyc2lzdGVuY2UgbG9naWMuXG4gICAgICogQHBhcmFtIF9ydW4gVGhlIHJ1biB0byBwZXJzaXN0LlxuICAgICAqIEByZXR1cm5zIEEgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyB1dGlsaXR5IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBwYXJlbnQgcnVucyBvZiBhIGdpdmVuIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgcGFyZW50cyBhcmUgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHBhcmVudCBydW5zLlxuICAgICAqL1xuICAgIGdldFBhcmVudHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRSdW4gPSBydW47XG4gICAgICAgIHdoaWxlIChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucnVuTWFwLmdldChjdXJyZW50UnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSdW4gPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLCB3aGljaFxuICAgICAqIGlzIHVzZWQgaW4gbG9nZ2luZy5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gd2hvc2UgbGluZWFnZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UuXG4gICAgICovXG4gICAgZ2V0QnJlYWRjcnVtYnMocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzLmdldFBhcmVudHMocnVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFsuLi5wYXJlbnRzLCBydW5dXG4gICAgICAgICAgICAubWFwKChwYXJlbnQsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke3BhcmVudC5leGVjdXRpb25fb3JkZXJ9OiR7cGFyZW50LnJ1bl90eXBlfToke3BhcmVudC5uYW1lfWA7XG4gICAgICAgICAgICByZXR1cm4gaSA9PT0gYXJyLmxlbmd0aCAtIDEgPyB3cmFwKGFuc2lfc3R5bGVzXzEuZGVmYXVsdC5ib2xkLCBuYW1lKSA6IG5hbWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIiA+IFwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXAoY29sb3IuZ3JleSwgc3RyaW5nKTtcbiAgICB9XG4gICAgLy8gbG9nZ2luZyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpblN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2NoYWluL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgQ2hhaW4gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltjaGFpbi9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIENoYWluIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbY2hhaW4vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBDaGFpbiBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gXCJwcm9tcHRzXCIgaW4gcnVuLmlucHV0c1xuICAgICAgICAgICAgPyB7IHByb21wdHM6IHJ1bi5pbnB1dHMucHJvbXB0cy5tYXAoKHApID0+IHAudHJpbSgpKSB9XG4gICAgICAgICAgICA6IHJ1bi5pbnB1dHM7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW2xsbS9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIExMTSBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KGlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2xsbS9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIExMTSBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbcmVzcG9uc2VdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbbGxtL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gTExNIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3Rvb2wvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBUb29sIHJ1biB3aXRoIGlucHV0OiBcIiR7Zm9ybWF0S1ZNYXBJdGVtKHJ1bi5pbnB1dHMuaW5wdXQpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3Rvb2wvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBUb29sIHJ1biB3aXRoIG91dHB1dDogXCIke2Zvcm1hdEtWTWFwSXRlbShydW4ub3V0cHV0cz8ub3V0cHV0KX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uVG9vbEVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIlt0b29sL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gVG9vbCBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltyZXRyaWV2ZXIvc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBSZXRyaWV2ZXIgcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltyZXRyaWV2ZXIvZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBSZXRyaWV2ZXIgcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltyZXRyaWV2ZXIvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBSZXRyaWV2ZXIgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGFjdGlvbiBzZWxlY3RlZCBieSB0aGUgYWdlbnQuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIGluIHdoaWNoIHRoZSBhZ2VudCBhY3Rpb24gb2NjdXJyZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQWdlbnRBY3Rpb24ocnVuKSB7XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuYmx1ZSwgXCJbYWdlbnQvYWN0aW9uXVwiKX0gWyR7Y3J1bWJzfV0gQWdlbnQgc2VsZWN0ZWQgYWN0aW9uOiAke3RyeUpzb25TdHJpbmdpZnkoYWdlbnRSdW4uYWN0aW9uc1thZ2VudFJ1bi5hY3Rpb25zLmxlbmd0aCAtIDFdLCBcIlthY3Rpb25dXCIpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc29sZUNhbGxiYWNrSGFuZGxlciA9IENvbnNvbGVDYWxsYmFja0hhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/event_stream.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventStreamCallbackHandler = exports.isStreamEventsHandler = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\nexports.isStreamEventsHandler = isStreamEventsHandler;\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass EventStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new outputs_js_1.GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new ai_js_1.AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new outputs_js_1.GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\nexports.EventStreamCallbackHandler = EventStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDZCQUE2QjtBQUNsRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM3QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDJCQUEyQixPQUFPLEdBQUc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzP2M0NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gZXhwb3J0cy5pc1N0cmVhbUV2ZW50c0hhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2FpLmNqc1wiKTtcbmNvbnN0IG91dHB1dHNfanNfMSA9IHJlcXVpcmUoXCIuLi9vdXRwdXRzLmNqc1wiKTtcbmZ1bmN0aW9uIGFzc2lnbk5hbWUoeyBuYW1lLCBzZXJpYWxpemVkLCB9KSB7XG4gICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZWQ/Lm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXJpYWxpemVkPy5pZCAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZD8uaWQpKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkLmlkW3NlcmlhbGl6ZWQuaWQubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBcIlVubmFtZWRcIjtcbn1cbmNvbnN0IGlzU3RyZWFtRXZlbnRzSGFuZGxlciA9IChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IFwiZXZlbnRfc3RyZWFtX3RyYWNlclwiO1xuZXhwb3J0cy5pc1N0cmVhbUV2ZW50c0hhbmRsZXIgPSBpc1N0cmVhbUV2ZW50c0hhbmRsZXI7XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuY2xhc3MgRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5JbmZvTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcHBlZFByb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImV2ZW50X3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1blR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBhd2FpdCBvdXRwdXRTdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZmlyc3RDaHVuay5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICAvLyBSdW4gaGFzIGZpbmlzaGVkLCBkb24ndCBpc3N1ZSBhbnkgc3RyZWFtIGV2ZW50cy5cbiAgICAgICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIGlzIGZvciBydW5uYWJsZXMgdGhhdCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgLnN0cmVhbSgpLCB3aGljaCBkZWxlZ2F0ZXMgdG8gLmludm9rZSgpXG4gICAgICAgIC8vIGFuZCBjYWxscyAub25DaGFpbkVuZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXRjaCBmb3JtYXQgZnJvbSBoYW5kbGVycyBiZWxvd1xuICAgICAgICBmdW5jdGlvbiBfZm9ybWF0T3V0cHV0Q2h1bmsoZXZlbnRUeXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImxsbVwiICYmIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzX2pzXzEuR2VuZXJhdGlvbkNodW5rKHsgdGV4dDogZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXBwZWRQcm9taXNlID0gdGhpcy50YXBwZWRQcm9taXNlcy5nZXQocnVuSWQpO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgdGhlIGZpcnN0IHRvIHRhcCwgaXNzdWUgc3RyZWFtIGV2ZW50c1xuICAgICAgICBpZiAodGFwcGVkUHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgdGFwcGVkUHJvbWlzZVJlc29sdmVyO1xuICAgICAgICAgICAgdGFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFwcGVkUHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50YXBwZWRQcm9taXNlcy5zZXQocnVuSWQsIHRhcHBlZFByb21pc2UpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3J1bkluZm8ucnVuVHlwZX1fc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogX2Zvcm1hdE91dHB1dENodW5rKHJ1bkluZm8ucnVuVHlwZSwgZmlyc3RDaHVuay52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG91dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB5aWVsZCB0b29sIGFuZCByZXRyaWV2ZXIgc3RyZWFtIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlICE9PSBcInRvb2xcIiAmJiBydW5JbmZvLnJ1blR5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogX2Zvcm1hdE91dHB1dENodW5rKHJ1bkluZm8ucnVuVHlwZSwgY2h1bmspLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBydW5JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHRhcHBlZFByb21pc2VSZXNvbHZlcigpO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGRlbGV0ZSBmcm9tIHRoZSBwcm9taXNlcyBtYXAgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBydW5zIGhhdmUgYmVlbiB0YXBwZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UganVzdCBwYXNzIHRocm91Z2hcbiAgICAgICAgICAgIHlpZWxkIGZpcnN0Q2h1bmsudmFsdWU7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG91dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmQocGF5bG9hZCwgcnVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmNsdWRlUnVuKHJ1bikpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRFbmRFdmVudChwYXlsb2FkLCBydW4pIHtcbiAgICAgICAgY29uc3QgdGFwcGVkUHJvbWlzZSA9IHRoaXMudGFwcGVkUHJvbWlzZXMuZ2V0KHBheWxvYWQucnVuX2lkKTtcbiAgICAgICAgaWYgKHRhcHBlZFByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdm9pZCB0YXBwZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kKHBheWxvYWQsIHJ1bik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZChwYXlsb2FkLCBydW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uTExNU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBydW4uaW5wdXRzLm1lc3NhZ2VzICE9PSB1bmRlZmluZWQgPyBcImNoYXRfbW9kZWxcIiA6IFwibGxtXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGUsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5zZXQocnVuLmlkLCBydW5JbmZvKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYG9uXyR7cnVuVHlwZX1fc3RhcnRgO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25MTE1OZXdUb2tlbihydW4sIHRva2VuLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgIGxldCBldmVudE5hbWU7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25MTE1OZXdUb2tlbjogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUb3AtbGV2ZWwgc3RyZWFtaW5nIGV2ZW50cyBhcmUgY292ZXJlZCBieSB0YXBPdXRwdXRJdGVyYWJsZVxuICAgICAgICBpZiAodGhpcy5ydW5JbmZvTWFwLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImNoYXRfbW9kZWxcIikge1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9jaGF0X21vZGVsX3N0cmVhbVwiO1xuICAgICAgICAgICAgaWYgKGt3YXJncz8uY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmsoeyBjb250ZW50OiB0b2tlbiwgaWQ6IGBydW4tJHtydW4uaWR9YCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2xsbV9zdHJlYW1cIjtcbiAgICAgICAgICAgIGlmIChrd2FyZ3M/LmNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBvdXRwdXRzX2pzXzEuR2VuZXJhdGlvbkNodW5rKHsgdGV4dDogdG9rZW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGt3YXJncy5jaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBydW4gdHlwZSAke3J1bkluZm8ucnVuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25MTE1FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTUVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IHJ1bi5vdXRwdXRzPy5nZW5lcmF0aW9ucztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJjaGF0X21vZGVsXCIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGlvbiBvZiBnZW5lcmF0aW9ucyA/PyBbXSkge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gZ2VuZXJhdGlvblswXT8ubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25fY2hhdF9tb2RlbF9lbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogZ2VuZXJhdGlvbnM/Lm1hcCgoZ2VuZXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGlvbi5tYXAoKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IGNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbGxtT3V0cHV0OiBydW4ub3V0cHV0cz8ubGxtT3V0cHV0ID8/IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25fbGxtX2VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTUVuZDogVW5leHBlY3RlZCBydW4gdHlwZTogJHtydW5JbmZvLnJ1blR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRW5kRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBydW4ucnVuX3R5cGUgPz8gXCJjaGFpblwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBldmVudERhdGEgPSB7fTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBSdW5uYWJsZSBjb3JlIGNvZGUgbm90IHNlbmRpbmcgaW5wdXQgd2hlbiB0cmFuc2Zvcm0gc3RyZWFtaW5nLlxuICAgICAgICBpZiAocnVuLmlucHV0cy5pbnB1dCA9PT0gXCJcIiAmJiBPYmplY3Qua2V5cyhydW4uaW5wdXRzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICAgICAgcnVuSW5mby5pbnB1dHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW4uaW5wdXRzLmlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5pbnB1dCA9IHJ1bi5pbnB1dHMuaW5wdXQ7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHJ1bi5pbnB1dHMuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudERhdGEuaW5wdXQgPSBydW4uaW5wdXRzO1xuICAgICAgICAgICAgcnVuSW5mby5pbnB1dHMgPSBydW4uaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5zZXQocnVuLmlkLCBydW5JbmZvKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBgb25fJHtydW5UeXBlfV9zdGFydGAsXG4gICAgICAgICAgICBkYXRhOiBldmVudERhdGEsXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25DaGFpbkVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uQ2hhaW5FbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gYG9uXyR7cnVuLnJ1bl90eXBlfV9lbmRgO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBydW4uaW5wdXRzID8/IHJ1bkluZm8uaW5wdXRzID8/IHt9O1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gcnVuLm91dHB1dHM/Lm91dHB1dCA/PyBydW4ub3V0cHV0cztcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0cyxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbnB1dHMuaW5wdXQgJiYgT2JqZWN0LmtleXMoaW5wdXRzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBpbnB1dHMuaW5wdXQ7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IGlucHV0cy5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZTogXCJ0b29sXCIsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMgPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5zZXQocnVuLmlkLCBydW5JbmZvKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3Rvb2xfc3RhcnRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuLmlucHV0cyA/PyB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25Ub29sRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25Ub29sRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JbmZvLmlucHV0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uVG9vbEVuZDogUnVuIElEICR7cnVuLmlkfSBpcyBhIHRvb2wgY2FsbCwgYW5kIGlzIGV4cGVjdGVkIHRvIGhhdmUgdHJhY2VkIGlucHV0cy5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBydW4ub3V0cHV0cz8ub3V0cHV0ID09PSB1bmRlZmluZWQgPyBydW4ub3V0cHV0cyA6IHJ1bi5vdXRwdXRzLm91dHB1dDtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRW5kRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fdG9vbF9lbmRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlclN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5UeXBlID0gXCJyZXRyaWV2ZXJcIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZSxcbiAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBydW4uaW5wdXRzLnF1ZXJ5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fcmV0cmlldmVyX3N0YXJ0XCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHJ1bi5pbnB1dHMucXVlcnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25SZXRyaWV2ZXJFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblJldHJpZXZlckVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9yZXRyaWV2ZXJfZW5kXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiBydW4ub3V0cHV0cz8uZG9jdW1lbnRzID8/IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGlucHV0OiBydW5JbmZvLmlucHV0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBoYW5kbGVDdXN0b21FdmVudChldmVudE5hbWUsIGRhdGEsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYW5kbGVDdXN0b21FdmVudDogUnVuIElEICR7cnVuSWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9jdXN0b21fZXZlbnRcIixcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBmaW5pc2goKSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlcyA9IFsuLi50aGlzLnRhcHBlZFByb21pc2VzLnZhbHVlcygpXTtcbiAgICAgICAgdm9pZCBQcm9taXNlLmFsbChwZW5kaW5nUHJvbWlzZXMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdm9pZCB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogStreamCallbackHandler = exports.isLogStreamHandler = exports.RunLog = exports.RunLogPatch = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLogPatch = RunLogPatch;\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0, index_js_1.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLog = RunLog;\nconst isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\nexports.isLogStreamHandler = isLogStreamHandler;\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new ai_js_1.AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\nexports.LogStreamCallbackHandler = LogStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxjQUFjLEdBQUcsbUJBQW1CO0FBQ3BHLG1CQUFtQixtQkFBTyxDQUFDLHFIQUFvQztBQUMvRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUyxHQUFHLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2xvZ19zdHJlYW0uY2pzP2M5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IGV4cG9ydHMuaXNMb2dTdHJlYW1IYW5kbGVyID0gZXhwb3J0cy5SdW5Mb2cgPSBleHBvcnRzLlJ1bkxvZ1BhdGNoID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3QgYWlfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9haS5janNcIik7XG4vKipcbiAqIExpc3Qgb2YganNvbnBhdGNoIEpTT05QYXRjaE9wZXJhdGlvbnMsIHdoaWNoIGRlc2NyaWJlIGhvdyB0byBjcmVhdGUgdGhlIHJ1biBzdGF0ZVxuICogZnJvbSBhbiBlbXB0eSBkaWN0LiBUaGlzIGlzIHRoZSBtaW5pbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb2csIGRlc2lnbmVkIHRvXG4gKiBiZSBzZXJpYWxpemVkIGFzIEpTT04gYW5kIHNlbnQgb3ZlciB0aGUgd2lyZSB0byByZWNvbnN0cnVjdCB0aGUgbG9nIG9uIHRoZSBvdGhlclxuICogc2lkZS4gUmVjb25zdHJ1Y3Rpb24gb2YgdGhlIHN0YXRlIGNhbiBiZSBkb25lIHdpdGggYW55IGpzb25wYXRjaC1jb21wbGlhbnQgbGlicmFyeSxcbiAqIHNlZSBodHRwczovL2pzb25wYXRjaC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BzID0gZmllbGRzLm9wcyA/PyBbXTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSAoMCwgaW5kZXhfanNfMS5hcHBseVBhdGNoKSh7fSwgb3BzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7XG4gICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5Mb2dQYXRjaCA9IFJ1bkxvZ1BhdGNoO1xuY2xhc3MgUnVuTG9nIGV4dGVuZHMgUnVuTG9nUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gZmllbGRzLnN0YXRlO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHMuY29uY2F0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9ICgwLCBpbmRleF9qc18xLmFwcGx5UGF0Y2gpKHRoaXMuc3RhdGUsIG90aGVyLm9wcyk7XG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHsgb3BzLCBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5Mb2dQYXRjaChwYXRjaCkge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSAoMCwgaW5kZXhfanNfMS5hcHBseVBhdGNoKSh7fSwgcGF0Y2gub3BzKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7XG4gICAgICAgICAgICBvcHM6IHBhdGNoLm9wcyxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bkxvZyA9IFJ1bkxvZztcbmNvbnN0IGlzTG9nU3RyZWFtSGFuZGxlciA9IChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IFwibG9nX3N0cmVhbV90cmFjZXJcIjtcbmV4cG9ydHMuaXNMb2dTdHJlYW1IYW5kbGVyID0gaXNMb2dTdHJlYW1IYW5kbGVyO1xuLyoqXG4gKiBFeHRyYWN0IHN0YW5kYXJkaXplZCBpbnB1dHMgZnJvbSBhIHJ1bi5cbiAqXG4gKiBTdGFuZGFyZGl6ZXMgdGhlIGlucHV0cyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgcnVubmFibGUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuIG9iamVjdFxuICogQHBhcmFtIHNjaGVtYUZvcm1hdCAtIFRoZSBzY2hlbWEgZm9ybWF0IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJucyBWYWxpZCBpbnB1dHMgYXJlIG9ubHkgZGljdC4gQnkgY29udmVudGlvbnMsIGlucHV0cyBhbHdheXMgcmVwcmVzZW50ZWRcbiAqIGludm9jYXRpb24gdXNpbmcgbmFtZWQgYXJndW1lbnRzLlxuICogQSBudWxsIG1lYW5zIHRoYXQgdGhlIGlucHV0IGlzIG5vdCB5ZXQga25vd24hXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGFzc2lnbiBpbnB1dHMgd2l0aCBvcmlnaW5hbCBzY2hlbWEgZHJvcCB0aGUga2V5IGZvciBub3cuIFwiICtcbiAgICAgICAgICAgIFwiV2hlbiBpbnB1dHMgYXJlIGFkZGVkIHRvIHN0cmVhbUxvZyB0aGV5IHNob3VsZCBiZSBhZGRlZCB3aXRoIFwiICtcbiAgICAgICAgICAgIFwic3RhbmRhcmRpemVkIHNjaGVtYSBmb3Igc3RyZWFtaW5nIGV2ZW50cy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaW5wdXRzIH0gPSBydW47XG4gICAgaWYgKFtcInJldHJpZXZlclwiLCBcImxsbVwiLCBcInByb21wdFwiXS5pbmNsdWRlcyhydW4ucnVuX3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHM/LmlucHV0ID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG5ldyBzdHlsZSBjaGFpbnNcbiAgICAvLyBUaGVzZSBuZXN0IGFuIGFkZGl0aW9uYWwgJ2lucHV0JyBrZXkgaW5zaWRlIHRoZSAnaW5wdXRzJyB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgaW5wdXQgaXMgYWx3YXlzIGEgZGljdC4gV2UgbmVlZCB0byB1bnBhY2sgYW5kIHVzZXIgdGhlIGlubmVyIHZhbHVlLlxuICAgIC8vIFdlIHNob3VsZCB0cnkgdG8gZml4IHRoaXMgaW4gUnVubmFibGVzIGFuZCBjYWxsYmFja3MvdHJhY2Vyc1xuICAgIC8vIFJ1bm5hYmxlcyBzaG91bGQgYmUgdXNpbmcgYSBudWxsIHR5cGUgaGVyZSBub3QgYSBwbGFjZWhvbGRlclxuICAgIC8vIGRpY3QuXG4gICAgcmV0dXJuIGlucHV0cy5pbnB1dDtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgc2NoZW1hRm9ybWF0KSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSBydW47XG4gICAgaWYgKHNjaGVtYUZvcm1hdCA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgb2xkIHNjaGVtYSwgd2l0aG91dCBzdGFuZGFyZGl6aW5nIGFueXRoaW5nXG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGhhY2t5IGNoZWNrXG4gICAgaWYgKG91dHB1dHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBPYmplY3Qua2V5cyhvdXRwdXRzKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgb3V0cHV0cz8ub3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHMub3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0cztcbn1cbmZ1bmN0aW9uIGlzQ2hhdEdlbmVyYXRpb25DaHVuayh4KSB7XG4gICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCAmJiB4Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIHRoZSBgQmFzZVRyYWNlcmAgY2xhc3MgZnJvbSB0aGVcbiAqIGBsYW5nY2hhaW4uY2FsbGJhY2tzLnRyYWNlcnMuYmFzZWAgbW9kdWxlLiBJdCByZXByZXNlbnRzIGEgY2FsbGJhY2tcbiAqIGhhbmRsZXIgdGhhdCBsb2dzIHRoZSBleGVjdXRpb24gb2YgcnVucyBhbmQgZW1pdHMgYFJ1bkxvZ2AgaW5zdGFuY2VzIHRvIGFcbiAqIGBSdW5Mb2dTdHJlYW1gLlxuICovXG5jbGFzcyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2NoZW1hRm9ybWF0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIm9yaWdpbmFsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvb3RJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlNYXBCeVJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY291bnRlck1hcEJ5UnVuTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImxvZ19zdHJlYW1fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gZmllbGRzPy5hdXRvQ2xvc2UgPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHM/LmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHM/LmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcz8uaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzPy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzPy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHM/LmV4Y2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLl9zY2hlbWFGb3JtYXQgPSBmaWVsZHM/Ll9zY2hlbWFGb3JtYXQgPz8gdGhpcy5fc2NoZW1hRm9ybWF0O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB0aGlzLnRyYW5zZm9ybVN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlU3RyZWFtID0gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0odGhpcy50cmFuc2Zvcm1TdHJlYW0ucmVhZGFibGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlU3RyZWFtO1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBtZXRob2Qgb25seSBjYWxsZWQgb25jZSBmb3IgYW4gZW50aXJlIHJ1biB0cmVlXG4gICAgICAgIC8vIGFuZCBpcyB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgfVxuICAgIF9pbmNsdWRlUnVuKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkID09PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fFxuICAgICAgICAgICAgICAgICAgICBydW5UYWdzLmZpbmQoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBydW5UYWdzLmV2ZXJ5KCh0YWcpID0+ICF0aGlzLmV4Y2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9XG4gICAgYXN5bmMgKnRhcE91dHB1dEl0ZXJhYmxlKHJ1bklkLCBvdXRwdXQpIHtcbiAgICAgICAgLy8gVGFwIGFuIG91dHB1dCBhc3luYyBpdGVyYXRvciB0byBzdHJlYW0gaXRzIHZhbHVlcyB0byB0aGUgbG9nLlxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG91dHB1dCkge1xuICAgICAgICAgICAgLy8gcm9vdCBydW4gaXMgaGFuZGxlZCBpbiAuc3RyZWFtTG9nKClcbiAgICAgICAgICAgIGlmIChydW5JZCAhPT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBydW4gc2lsZW50bHkgaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gZWcuIGJlY2F1c2UgdGhpcyBydW4gd2Fzbid0IGluY2x1ZGVkIGluIHRoZSBsb2dcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuSWRdO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke2tleX0vc3RyZWFtZWRfb3V0cHV0Ly1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdElkID0gcnVuLmlkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbF9vdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gKz0gMTtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdO1xuICAgICAgICB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXSA9XG4gICAgICAgICAgICBjb3VudCA9PT0gMSA/IHJ1bi5uYW1lIDogYCR7cnVuLm5hbWV9OiR7Y291bnR9YDtcbiAgICAgICAgY29uc3QgbG9nRW50cnkgPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBydW4ucnVuX3R5cGUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgc3RhcnRfdGltZTogbmV3IERhdGUocnVuLnN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0X3N0cjogW10sXG4gICAgICAgICAgICBmaW5hbF9vdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZF90aW1lOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9zY2hlbWFGb3JtYXQgPT09IFwic3RyZWFtaW5nX2V2ZW50c1wiKSB7XG4gICAgICAgICAgICBsb2dFbnRyeS5pbnB1dHMgPSBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7dGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF19YCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvZ0VudHJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnVuTmFtZSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdO1xuICAgICAgICAgICAgaWYgKHJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vaW5wdXRzYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2ZpbmFsX291dHB1dGAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJ1bi5lbmRfdGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZW5kX3RpbWVgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goeyBvcHMgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAocnVuLmlkID09PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiL2ZpbmFsX291dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1OZXdUb2tlbihydW4sIHRva2VuLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdO1xuICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGhhY2tcbiAgICAgICAgY29uc3QgaXNDaGF0TW9kZWwgPSBydW4uaW5wdXRzLm1lc3NhZ2VzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzdHJlYW1lZE91dHB1dFZhbHVlO1xuICAgICAgICBpZiAoaXNDaGF0TW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoa3dhcmdzPy5jaHVuaykpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0ga3dhcmdzPy5jaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBuZXcgYWlfanNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgcnVuLSR7cnVuLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dF9zdHIvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbWVkT3V0cHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RootListenersTracer = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nclass RootListenersTracer extends base_js_1.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            await this.argOnStart(run, this.config);\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                await this.argOnEnd(run, this.config);\n            }\n        }\n        else if (this.argOnError) {\n            await this.argOnError(run, this.config);\n        }\n    }\n}\nexports.RootListenersTracer = RootListenersTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsOEVBQVk7QUFDdEM7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3Jvb3RfbGlzdGVuZXIuY2pzPzM1ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvb3RMaXN0ZW5lcnNUcmFjZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNsYXNzIFJvb3RMaXN0ZW5lcnNUcmFjZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoeyBjb25maWcsIG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJSb290TGlzdGVuZXJzVHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgUnVuJ3MgSUQuIFR5cGUgVVVJRCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uU3RhcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FbmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5hcmdPblN0YXJ0ID0gb25TdGFydDtcbiAgICAgICAgdGhpcy5hcmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmFyZ09uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgKiB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgICogQHBhcmFtIHtSdW59IF8gTm90IHVzZWRcbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF8pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25TdGFydChydW4sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgaWYgKHJ1bi5pZCAhPT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bi5lcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25FbmQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRW5kKHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPbkVycm9yKHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Sb290TGlzdGVuZXJzVHJhY2VyID0gUm9vdExpc3RlbmVyc1RyYWNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangChainTracer = void 0;\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nclass LangChainTracer extends base_js_1.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { exampleId, projectName, client } = fields;\n        this.projectName =\n            projectName ??\n                (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n                (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_SESSION\");\n        this.exampleId = exampleId;\n        const clientParams = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n            ? {\n                // LangSmith has its own backgrounding system\n                blockOnRootRunFinalization: true,\n            }\n            : {};\n        this.client = client ?? new langsmith_1.Client(clientParams);\n        const traceableTree = LangChainTracer.getTraceableRunTree();\n        if (traceableTree) {\n            this.updateFromRunTree(traceableTree);\n        }\n    }\n    async _convertToCreate(run, example_id = undefined) {\n        return {\n            ...run,\n            extra: {\n                ...run.extra,\n                runtime: await (0, env_js_1.getRuntimeEnvironment)(),\n            },\n            child_runs: undefined,\n            session_name: this.projectName,\n            reference_example_id: run.parent_run_id ? undefined : example_id,\n        };\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const persistedRun = await this._convertToCreate(run, this.exampleId);\n        await this.client.createRun(persistedRun);\n    }\n    async onRunUpdate(run) {\n        const runUpdate = {\n            end_time: run.end_time,\n            error: run.error,\n            outputs: run.outputs,\n            events: run.events,\n            inputs: run.inputs,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            parent_run_id: run.parent_run_id,\n        };\n        await this.client.updateRun(run.id, runUpdate);\n    }\n    getRun(id) {\n        return this.runMap.get(id);\n    }\n    updateFromRunTree(runTree) {\n        let rootRun = runTree;\n        const visited = new Set();\n        while (rootRun.parent_run) {\n            if (visited.has(rootRun.id))\n                break;\n            visited.add(rootRun.id);\n            if (!rootRun.parent_run)\n                break;\n            rootRun = rootRun.parent_run;\n        }\n        visited.clear();\n        const queue = [rootRun];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (!current || visited.has(current.id))\n                continue;\n            visited.add(current.id);\n            // @ts-expect-error Types of property 'events' are incompatible.\n            this.runMap.set(current.id, current);\n            if (current.child_runs) {\n                queue.push(...current.child_runs);\n            }\n        }\n        this.client = runTree.client ?? this.client;\n        this.projectName = runTree.project_name ?? this.projectName;\n        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n    }\n    convertToRunTree(id) {\n        const runTreeMap = {};\n        const runTreeList = [];\n        for (const [id, run] of this.runMap) {\n            // by converting the run map to a run tree, we are doing a copy\n            // thus, any mutation performed on the run tree will not be reflected\n            // back in the run map\n            // TODO: Stop using `this.runMap` in favour of LangSmith's `RunTree`\n            const runTree = new run_trees_1.RunTree({\n                ...run,\n                child_runs: [],\n                parent_run: undefined,\n                // inherited properties\n                client: this.client,\n                project_name: this.projectName,\n                reference_example_id: this.exampleId,\n                tracingEnabled: true,\n            });\n            runTreeMap[id] = runTree;\n            runTreeList.push([id, run.dotted_order]);\n        }\n        runTreeList.sort((a, b) => {\n            if (!a[1] || !b[1])\n                return 0;\n            return a[1].localeCompare(b[1]);\n        });\n        for (const [id] of runTreeList) {\n            const run = this.runMap.get(id);\n            const runTree = runTreeMap[id];\n            if (!run || !runTree)\n                continue;\n            if (run.parent_run_id) {\n                const parentRunTree = runTreeMap[run.parent_run_id];\n                if (parentRunTree) {\n                    parentRunTree.child_runs.push(runTree);\n                    runTree.parent_run = parentRunTree;\n                }\n            }\n        }\n        return runTreeMap[id];\n    }\n    static getTraceableRunTree() {\n        try {\n            return (0, traceable_1.getCurrentRunTree)();\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\nexports.LangChainTracer = LangChainTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsMkRBQVc7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUVBQXFCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFnQztBQUM1RCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsOEVBQVk7QUFDdEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uY2pzP2M4MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdDaGFpblRyYWNlciA9IHZvaWQgMDtcbmNvbnN0IGxhbmdzbWl0aF8xID0gcmVxdWlyZShcImxhbmdzbWl0aFwiKTtcbmNvbnN0IHJ1bl90cmVlc18xID0gcmVxdWlyZShcImxhbmdzbWl0aC9ydW5fdHJlZXNcIik7XG5jb25zdCB0cmFjZWFibGVfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGgvc2luZ2xldG9ucy90cmFjZWFibGVcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jbGFzcyBMYW5nQ2hhaW5UcmFjZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsYW5nY2hhaW5fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3ROYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBleGFtcGxlSWQsIHByb2plY3ROYW1lLCBjbGllbnQgfSA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA/P1xuICAgICAgICAgICAgICAgICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgKDAsIGVudl9qc18xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiTEFOR0NIQUlOX1NFU1NJT05cIik7XG4gICAgICAgIHRoaXMuZXhhbXBsZUlkID0gZXhhbXBsZUlkO1xuICAgICAgICBjb25zdCBjbGllbnRQYXJhbXMgPSAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJMQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkRcIikgPT09IFwiZmFsc2VcIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLy8gTGFuZ1NtaXRoIGhhcyBpdHMgb3duIGJhY2tncm91bmRpbmcgc3lzdGVtXG4gICAgICAgICAgICAgICAgYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb246IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudCA/PyBuZXcgbGFuZ3NtaXRoXzEuQ2xpZW50KGNsaWVudFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYWNlYWJsZVRyZWUgPSBMYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICBpZiAodHJhY2VhYmxlVHJlZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUnVuVHJlZSh0cmFjZWFibGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhhbXBsZV9pZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICAgICAgcnVudGltZTogYXdhaXQgKDAsIGVudl9qc18xLmdldFJ1bnRpbWVFbnZpcm9ubWVudCkoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZXNzaW9uX25hbWU6IHRoaXMucHJvamVjdE5hbWUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogcnVuLnBhcmVudF9ydW5faWQgPyB1bmRlZmluZWQgOiBleGFtcGxlX2lkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHsgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSBhd2FpdCB0aGlzLl9jb252ZXJ0VG9DcmVhdGUocnVuLCB0aGlzLmV4YW1wbGVJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihwZXJzaXN0ZWRSdW4pO1xuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcnVuVXBkYXRlID0ge1xuICAgICAgICAgICAgZW5kX3RpbWU6IHJ1bi5lbmRfdGltZSxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIGV2ZW50czogcnVuLmV2ZW50cyxcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBydW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBydW4ucGFyZW50X3J1bl9pZCxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudXBkYXRlUnVuKHJ1bi5pZCwgcnVuVXBkYXRlKTtcbiAgICB9XG4gICAgZ2V0UnVuKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bk1hcC5nZXQoaWQpO1xuICAgIH1cbiAgICB1cGRhdGVGcm9tUnVuVHJlZShydW5UcmVlKSB7XG4gICAgICAgIGxldCByb290UnVuID0gcnVuVHJlZTtcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgd2hpbGUgKHJvb3RSdW4ucGFyZW50X3J1bikge1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKHJvb3RSdW4uaWQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQocm9vdFJ1bi5pZCk7XG4gICAgICAgICAgICBpZiAoIXJvb3RSdW4ucGFyZW50X3J1bilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJvb3RSdW4gPSByb290UnVuLnBhcmVudF9ydW47XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5jbGVhcigpO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtyb290UnVuXTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IHZpc2l0ZWQuaGFzKGN1cnJlbnQuaWQpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFR5cGVzIG9mIHByb3BlcnR5ICdldmVudHMnIGFyZSBpbmNvbXBhdGlibGUuXG4gICAgICAgICAgICB0aGlzLnJ1bk1hcC5zZXQoY3VycmVudC5pZCwgY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5jaGlsZF9ydW5zKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCguLi5jdXJyZW50LmNoaWxkX3J1bnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50ID0gcnVuVHJlZS5jbGllbnQgPz8gdGhpcy5jbGllbnQ7XG4gICAgICAgIHRoaXMucHJvamVjdE5hbWUgPSBydW5UcmVlLnByb2plY3RfbmFtZSA/PyB0aGlzLnByb2plY3ROYW1lO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IHJ1blRyZWUucmVmZXJlbmNlX2V4YW1wbGVfaWQgPz8gdGhpcy5leGFtcGxlSWQ7XG4gICAgfVxuICAgIGNvbnZlcnRUb1J1blRyZWUoaWQpIHtcbiAgICAgICAgY29uc3QgcnVuVHJlZU1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5UcmVlTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgcnVuXSBvZiB0aGlzLnJ1bk1hcCkge1xuICAgICAgICAgICAgLy8gYnkgY29udmVydGluZyB0aGUgcnVuIG1hcCB0byBhIHJ1biB0cmVlLCB3ZSBhcmUgZG9pbmcgYSBjb3B5XG4gICAgICAgICAgICAvLyB0aHVzLCBhbnkgbXV0YXRpb24gcGVyZm9ybWVkIG9uIHRoZSBydW4gdHJlZSB3aWxsIG5vdCBiZSByZWZsZWN0ZWRcbiAgICAgICAgICAgIC8vIGJhY2sgaW4gdGhlIHJ1biBtYXBcbiAgICAgICAgICAgIC8vIFRPRE86IFN0b3AgdXNpbmcgYHRoaXMucnVuTWFwYCBpbiBmYXZvdXIgb2YgTGFuZ1NtaXRoJ3MgYFJ1blRyZWVgXG4gICAgICAgICAgICBjb25zdCBydW5UcmVlID0gbmV3IHJ1bl90cmVlc18xLlJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgICAgICBwYXJlbnRfcnVuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogdGhpcy5leGFtcGxlSWQsXG4gICAgICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJ1blRyZWVNYXBbaWRdID0gcnVuVHJlZTtcbiAgICAgICAgICAgIHJ1blRyZWVMaXN0LnB1c2goW2lkLCBydW4uZG90dGVkX29yZGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuVHJlZUxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKCFhWzFdIHx8ICFiWzFdKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIGFbMV0ubG9jYWxlQ29tcGFyZShiWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW2lkXSBvZiBydW5UcmVlTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1blRyZWUgPSBydW5UcmVlTWFwW2lkXTtcbiAgICAgICAgICAgIGlmICghcnVuIHx8ICFydW5UcmVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bi5wYXJlbnRfcnVuX2lkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UnVuVHJlZSA9IHJ1blRyZWVNYXBbcnVuLnBhcmVudF9ydW5faWRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1blRyZWUuY2hpbGRfcnVucy5wdXNoKHJ1blRyZWUpO1xuICAgICAgICAgICAgICAgICAgICBydW5UcmVlLnBhcmVudF9ydW4gPSBwYXJlbnRSdW5UcmVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuVHJlZU1hcFtpZF07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUcmFjZWFibGVSdW5UcmVlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0cmFjZWFibGVfMS5nZXRDdXJyZW50UnVuVHJlZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nQ2hhaW5UcmFjZXIgPSBMYW5nQ2hhaW5UcmFjZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/index.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/index.cjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./src/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/index.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNEdBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9pbmRleC5janM/MDA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9pbmRleC5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.cjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.cjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deepCompareStrict = void 0;\nfunction deepCompareStrict(a, b) {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === \"object\") {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\nexports.deepCompareStrict = deepCompareStrict;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9kZWVwLWNvbXBhcmUtc3RyaWN0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9AY2Z3b3JrZXIvanNvbi1zY2hlbWEvc3JjL2RlZXAtY29tcGFyZS1zdHJpY3QuY2pzP2VkNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZXBDb21wYXJlU3RyaWN0ID0gdm9pZCAwO1xuZnVuY3Rpb24gZGVlcENvbXBhcmVTdHJpY3QoYSwgYikge1xuICAgIGNvbnN0IHR5cGVvZmEgPSB0eXBlb2YgYTtcbiAgICBpZiAodHlwZW9mYSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBDb21wYXJlU3RyaWN0KGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFLZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBDb21wYXJlU3RyaWN0KGFba10sIGJba10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbmV4cG9ydHMuZGVlcENvbXBhcmVTdHJpY3QgPSBkZWVwQ29tcGFyZVN0cmljdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dereference = exports.initialBaseURI = exports.ignoredKeyword = exports.schemaMapKeyword = exports.schemaArrayKeyword = exports.schemaKeyword = void 0;\nconst pointer_js_1 = __webpack_require__(/*! ./pointer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs\");\nexports.schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true,\n};\nexports.schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true,\n};\nexports.schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true,\n};\nexports.ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true,\n};\n/**\n * Default base URI for schemas without an $id.\n * https://json-schema.org/draft/2019-09/json-schema-core.html#initial-base\n * https://tools.ietf.org/html/rfc3986#section-5.1\n */\nexports.initialBaseURI = \n// @ts-ignore\ntypeof self !== \"undefined\" &&\n    self.location &&\n    self.location.origin !== \"null\"\n    ? //@ts-ignore\n        /* #__PURE__ */ new URL(self.location.origin + self.location.pathname + location.search)\n    : /* #__PURE__ */ new URL(\"https://github.com/cfworker\");\nfunction dereference(schema, lookup = Object.create(null), baseURI = exports.initialBaseURI, basePointer = \"\") {\n    if (schema && typeof schema === \"object\" && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = \"\"; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n                if (basePointer === \"\") {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    // compute the schema's URI and add it to the mapping.\n    const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    // exit early if this is a boolean schema.\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    // set the schema's absolute URI.\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, \"__absolute_uri__\", {\n            enumerable: false,\n            value: schemaURI,\n        });\n    }\n    // if a $ref is found, resolve it's absolute URI.\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if a $recursiveRef is found, resolve it's absolute URI.\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        Object.defineProperty(schema, \"__absolute_recursive_ref__\", {\n            enumerable: false,\n            value: url.href,\n        });\n    }\n    // if an $anchor is found, compute it's URI and add it to the mapping.\n    if (schema.$anchor) {\n        const url = new URL(\"#\" + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    // process subschemas.\n    for (let key in schema) {\n        if (exports.ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${(0, pointer_js_1.encodePointer)(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (exports.schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (exports.schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${(0, pointer_js_1.encodePointer)(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\nexports.dereference = dereference;\n// schema identification examples\n// https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.A\n// $ref delegation\n// https://github.com/json-schema-org/json-schema-spec/issues/514\n// output format\n// https://json-schema.org/draft/2019-09/json-schema-core.html#output\n// JSON pointer\n// https://tools.ietf.org/html/rfc6901\n// JSON relative pointer\n// https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9kZXJlZmVyZW5jZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ3JKLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFlO0FBQzVDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVksR0FBRyxxQ0FBcUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QyxrRUFBa0UsUUFBUSxHQUFHLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxRQUFRLEdBQUcsd0NBQXdDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9kZXJlZmVyZW5jZS5janM/MTNkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVyZWZlcmVuY2UgPSBleHBvcnRzLmluaXRpYWxCYXNlVVJJID0gZXhwb3J0cy5pZ25vcmVkS2V5d29yZCA9IGV4cG9ydHMuc2NoZW1hTWFwS2V5d29yZCA9IGV4cG9ydHMuc2NoZW1hQXJyYXlLZXl3b3JkID0gZXhwb3J0cy5zY2hlbWFLZXl3b3JkID0gdm9pZCAwO1xuY29uc3QgcG9pbnRlcl9qc18xID0gcmVxdWlyZShcIi4vcG9pbnRlci5janNcIik7XG5leHBvcnRzLnNjaGVtYUtleXdvcmQgPSB7XG4gICAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICAgIHVuZXZhbHVhdGVkSXRlbXM6IHRydWUsXG4gICAgaXRlbXM6IHRydWUsXG4gICAgY29udGFpbnM6IHRydWUsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gICAgbm90OiB0cnVlLFxuICAgIGlmOiB0cnVlLFxuICAgIHRoZW46IHRydWUsXG4gICAgZWxzZTogdHJ1ZSxcbn07XG5leHBvcnRzLnNjaGVtYUFycmF5S2V5d29yZCA9IHtcbiAgICBwcmVmaXhJdGVtczogdHJ1ZSxcbiAgICBpdGVtczogdHJ1ZSxcbiAgICBhbGxPZjogdHJ1ZSxcbiAgICBhbnlPZjogdHJ1ZSxcbiAgICBvbmVPZjogdHJ1ZSxcbn07XG5leHBvcnRzLnNjaGVtYU1hcEtleXdvcmQgPSB7XG4gICAgJGRlZnM6IHRydWUsXG4gICAgZGVmaW5pdGlvbnM6IHRydWUsXG4gICAgcHJvcGVydGllczogdHJ1ZSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgICBkZXBlbmRlbnRTY2hlbWFzOiB0cnVlLFxufTtcbmV4cG9ydHMuaWdub3JlZEtleXdvcmQgPSB7XG4gICAgaWQ6IHRydWUsXG4gICAgJGlkOiB0cnVlLFxuICAgICRyZWY6IHRydWUsXG4gICAgJHNjaGVtYTogdHJ1ZSxcbiAgICAkYW5jaG9yOiB0cnVlLFxuICAgICR2b2NhYnVsYXJ5OiB0cnVlLFxuICAgICRjb21tZW50OiB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgZW51bTogdHJ1ZSxcbiAgICBjb25zdDogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIG1heGltdW06IHRydWUsXG4gICAgbWluaW11bTogdHJ1ZSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gICAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgICBtYXhMZW5ndGg6IHRydWUsXG4gICAgbWluTGVuZ3RoOiB0cnVlLFxuICAgIHBhdHRlcm46IHRydWUsXG4gICAgZm9ybWF0OiB0cnVlLFxuICAgIG1heEl0ZW1zOiB0cnVlLFxuICAgIG1pbkl0ZW1zOiB0cnVlLFxuICAgIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICAgIG1heFByb3BlcnRpZXM6IHRydWUsXG4gICAgbWluUHJvcGVydGllczogdHJ1ZSxcbn07XG4vKipcbiAqIERlZmF1bHQgYmFzZSBVUkkgZm9yIHNjaGVtYXMgd2l0aG91dCBhbiAkaWQuXG4gKiBodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L2pzb24tc2NoZW1hLWNvcmUuaHRtbCNpbml0aWFsLWJhc2VcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4xXG4gKi9cbmV4cG9ydHMuaW5pdGlhbEJhc2VVUkkgPSBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgc2VsZi5sb2NhdGlvbiAmJlxuICAgIHNlbGYubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIlxuICAgID8gLy9AdHMtaWdub3JlXG4gICAgICAgIC8qICNfX1BVUkVfXyAqLyBuZXcgVVJMKHNlbGYubG9jYXRpb24ub3JpZ2luICsgc2VsZi5sb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaClcbiAgICA6IC8qICNfX1BVUkVfXyAqLyBuZXcgVVJMKFwiaHR0cHM6Ly9naXRodWIuY29tL2Nmd29ya2VyXCIpO1xuZnVuY3Rpb24gZGVyZWZlcmVuY2Uoc2NoZW1hLCBsb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBiYXNlVVJJID0gZXhwb3J0cy5pbml0aWFsQmFzZVVSSSwgYmFzZVBvaW50ZXIgPSBcIlwiKSB7XG4gICAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGlkLCBiYXNlVVJJLmhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5oYXNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBbdXJsLmhyZWZdID0gc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsLmhhc2ggPSBcIlwiOyAvLyBub3JtYWxpemUgaGFzaCBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUG9pbnRlciA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBiYXNlVVJJID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVyZWZlcmVuY2Uoc2NoZW1hLCBsb29rdXAsIGJhc2VVUkkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgIT09IHRydWUgJiYgc2NoZW1hICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cbiAgICAvLyBjb21wdXRlIHRoZSBzY2hlbWEncyBVUkkgYW5kIGFkZCBpdCB0byB0aGUgbWFwcGluZy5cbiAgICBjb25zdCBzY2hlbWFVUkkgPSBiYXNlVVJJLmhyZWYgKyAoYmFzZVBvaW50ZXIgPyBcIiNcIiArIGJhc2VQb2ludGVyIDogXCJcIik7XG4gICAgaWYgKGxvb2t1cFtzY2hlbWFVUkldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgc2NoZW1hIFVSSSBcIiR7c2NoZW1hVVJJfVwiLmApO1xuICAgIH1cbiAgICBsb29rdXBbc2NoZW1hVVJJXSA9IHNjaGVtYTtcbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoaXMgaXMgYSBib29sZWFuIHNjaGVtYS5cbiAgICBpZiAoc2NoZW1hID09PSB0cnVlIHx8IHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBzY2hlbWEncyBhYnNvbHV0ZSBVUkkuXG4gICAgaWYgKHNjaGVtYS5fX2Fic29sdXRlX3VyaV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgXCJfX2Fic29sdXRlX3VyaV9fXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHNjaGVtYVVSSSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGlmIGEgJHJlZiBpcyBmb3VuZCwgcmVzb2x2ZSBpdCdzIGFic29sdXRlIFVSSS5cbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgc2NoZW1hLl9fYWJzb2x1dGVfcmVmX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHNjaGVtYS4kcmVmLCBiYXNlVVJJLmhyZWYpO1xuICAgICAgICB1cmwuaGFzaCA9IHVybC5oYXNoOyAvLyBub3JtYWxpemUgaGFzaCBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBcIl9fYWJzb2x1dGVfcmVmX19cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXJsLmhyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiBhICRyZWN1cnNpdmVSZWYgaXMgZm91bmQsIHJlc29sdmUgaXQncyBhYnNvbHV0ZSBVUkkuXG4gICAgaWYgKHNjaGVtYS4kcmVjdXJzaXZlUmVmICYmIHNjaGVtYS5fX2Fic29sdXRlX3JlY3Vyc2l2ZV9yZWZfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc2NoZW1hLiRyZWN1cnNpdmVSZWYsIGJhc2VVUkkuaHJlZik7XG4gICAgICAgIHVybC5oYXNoID0gdXJsLmhhc2g7IC8vIG5vcm1hbGl6ZSBoYXNoIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsIFwiX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX19cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXJsLmhyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiBhbiAkYW5jaG9yIGlzIGZvdW5kLCBjb21wdXRlIGl0J3MgVVJJIGFuZCBhZGQgaXQgdG8gdGhlIG1hcHBpbmcuXG4gICAgaWYgKHNjaGVtYS4kYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCIjXCIgKyBzY2hlbWEuJGFuY2hvciwgYmFzZVVSSS5ocmVmKTtcbiAgICAgICAgbG9va3VwW3VybC5ocmVmXSA9IHNjaGVtYTtcbiAgICB9XG4gICAgLy8gcHJvY2VzcyBzdWJzY2hlbWFzLlxuICAgIGZvciAobGV0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuaWdub3JlZEtleXdvcmRba2V5XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5QmFzZSA9IGAke2Jhc2VQb2ludGVyfS8keygwLCBwb2ludGVyX2pzXzEuZW5jb2RlUG9pbnRlcikoa2V5KX1gO1xuICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViU2NoZW1hKSkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuc2NoZW1hQXJyYXlLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBzdWJTY2hlbWEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVyZWZlcmVuY2Uoc3ViU2NoZW1hW2ldLCBsb29rdXAsIGJhc2VVUkksIGAke2tleUJhc2V9LyR7aX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwb3J0cy5zY2hlbWFNYXBLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YktleSBpbiBzdWJTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZShzdWJTY2hlbWFbc3ViS2V5XSwgbG9va3VwLCBiYXNlVVJJLCBgJHtrZXlCYXNlfS8keygwLCBwb2ludGVyX2pzXzEuZW5jb2RlUG9pbnRlcikoc3ViS2V5KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcmVmZXJlbmNlKHN1YlNjaGVtYSwgbG9va3VwLCBiYXNlVVJJLCBrZXlCYXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9va3VwO1xufVxuZXhwb3J0cy5kZXJlZmVyZW5jZSA9IGRlcmVmZXJlbmNlO1xuLy8gc2NoZW1hIGlkZW50aWZpY2F0aW9uIGV4YW1wbGVzXG4vLyBodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L2pzb24tc2NoZW1hLWNvcmUuaHRtbCNyZmMuYXBwZW5kaXguQVxuLy8gJHJlZiBkZWxlZ2F0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanNvbi1zY2hlbWEtb3JnL2pzb24tc2NoZW1hLXNwZWMvaXNzdWVzLzUxNFxuLy8gb3V0cHV0IGZvcm1hdFxuLy8gaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAxOS0wOS9qc29uLXNjaGVtYS1jb3JlLmh0bWwjb3V0cHV0XG4vLyBKU09OIHBvaW50ZXJcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4vLyBKU09OIHJlbGF0aXZlIHBvaW50ZXJcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oYW5kcmV3cy1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDFcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// based on https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fastFormat = exports.fullFormat = void 0;\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n// const URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\nconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n// date: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTDATE = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/;\n// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTTIME = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst FASTDATETIME = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i;\n// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n// const FASTURI = /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i;\nconst FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst EMAIL = (input) => {\n    if (input[0] === '\"')\n        return false;\n    const [name, host, ...rest] = input.split(\"@\");\n    if (!name ||\n        !host ||\n        rest.length !== 0 ||\n        name.length > 64 ||\n        host.length > 253)\n        return false;\n    if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\"))\n        return false;\n    if (!/^[a-z0-9.-]+$/i.test(host) ||\n        !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n        return false;\n    return host\n        .split(\".\")\n        .every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n};\n// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\nconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n// optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\nconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst DURATION = (input) => input.length > 1 &&\n    input.length < 80 &&\n    (/^P\\d+([.,]\\d+)?W$/.test(input) ||\n        (/^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) &&\n            /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input)));\nfunction bind(r) {\n    return r.test.bind(r);\n}\nexports.fullFormat = {\n    date,\n    time: /* #__PURE__ */ time.bind(undefined, false),\n    \"date-time\": date_time,\n    duration: DURATION,\n    uri,\n    \"uri-reference\": /* #__PURE__ */ bind(URIREF),\n    \"uri-template\": /* #__PURE__ */ bind(URITEMPLATE),\n    url: /* #__PURE__ */ bind(URL_),\n    email: EMAIL,\n    hostname: /* #__PURE__ */ bind(HOSTNAME),\n    ipv4: /* #__PURE__ */ bind(IPV4),\n    ipv6: /* #__PURE__ */ bind(IPV6),\n    regex: regex,\n    uuid: /* #__PURE__ */ bind(UUID),\n    \"json-pointer\": /* #__PURE__ */ bind(JSON_POINTER),\n    \"json-pointer-uri-fragment\": /* #__PURE__ */ bind(JSON_POINTER_URI_FRAGMENT),\n    \"relative-json-pointer\": /* #__PURE__ */ bind(RELATIVE_JSON_POINTER),\n};\nexports.fastFormat = {\n    ...exports.fullFormat,\n    date: /* #__PURE__ */ bind(FASTDATE),\n    time: /* #__PURE__ */ bind(FASTTIME),\n    \"date-time\": /* #__PURE__ */ bind(FASTDATETIME),\n    \"uri-reference\": /* #__PURE__ */ bind(FASTURIREFERENCE),\n};\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = str.match(DATE);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction time(full, str) {\n    const matches = str.match(TIME);\n    if (!matches)\n        return false;\n    const hour = +matches[1];\n    const minute = +matches[2];\n    const second = +matches[3];\n    const timeZone = !!matches[5];\n    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n        (hour == 23 && minute == 59 && second == 60)) &&\n        (!full || timeZone));\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n    // http://tools.ietf.org/html/rfc3339#section-5.6\n    const dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9mb3JtYXQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNLDBCQUEwQixLQUFLLG9DQUFvQyxLQUFLO0FBQ3RHLDRFQUE0RSxjQUFjLEVBQUUsK0JBQStCLElBQUksR0FBRyxFQUFFLGVBQWUsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxpQkFBaUIsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGlCQUFpQixJQUFJLFVBQVUsSUFBSSx1Q0FBdUMsRUFBRSxnREFBZ0QsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLDJDQUEyQyw4Q0FBOEMsRUFBRSx5REFBeUQsYUFBYSxFQUFFLDBDQUEwQyxlQUFlLEVBQUUsbUNBQW1DLGVBQWUsRUFBRSxnQ0FBZ0MsZUFBZSxFQUFFLGdDQUFnQyxlQUFlLEVBQUUsZ0NBQWdDLGVBQWUsRUFBRSxtQ0FBbUMsaUJBQWlCLEVBQUUsaUNBQWlDLGlCQUFpQixFQUFFO0FBQ3RvQyw2RUFBNkUsY0FBYyxFQUFFLCtCQUErQixJQUFJLEdBQUcsRUFBRSxlQUFlLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxhQUFhLElBQUksaUJBQWlCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxpQkFBaUIsSUFBSSxVQUFVLElBQUksdUNBQXVDLEVBQUUsZ0RBQWdELElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxhQUFhLElBQUksZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSwyQ0FBMkMsOENBQThDLEVBQUUsMERBQTBELGFBQWEsRUFBRSwyQ0FBMkMsZUFBZSxFQUFFLG9DQUFvQyxlQUFlLEVBQUUsaUNBQWlDLGVBQWUsRUFBRSxpQ0FBaUMsZUFBZSxFQUFFLGlDQUFpQyxlQUFlLEVBQUUscUNBQXFDLGlCQUFpQixFQUFFLGtDQUFrQyxpQkFBaUIsRUFBRTtBQUNocEM7QUFDQSxpREFBaUQsRUFBRSxZQUFZLEVBQUUsSUFBSSxNQUFNLGdDQUFnQyxFQUFFLGlCQUFpQixJQUFJLGdDQUFnQyxFQUFFLGlCQUFpQixJQUFJLFNBQVM7QUFDbE07QUFDQTtBQUNBLHdFQUF3RSxJQUFJLEVBQUUsRUFBRSxlQUFlLElBQUksRUFBRSxFQUFFLG9CQUFvQixJQUFJLEVBQUUsRUFBRSxvQkFBb0IsSUFBSSxFQUFFLEVBQUUsc0NBQXNDLElBQUksRUFBRSxFQUFFLGdEQUFnRCxJQUFJLG9CQUFvQixFQUFFLHVEQUF1RCxLQUFLLElBQUksS0FBSyxnQkFBZ0IsS0FBSyxJQUFJLEtBQUsscUJBQXFCLEtBQUssSUFBSSxLQUFLLGdCQUFnQixLQUFLLElBQUksS0FBSyxzQkFBc0IsS0FBSyxJQUFJLEtBQUssRUFBRSxHQUFHLFVBQVUsSUFBSTtBQUNsZixzQ0FBc0MsRUFBRSxhQUFhLEVBQUUsR0FBRyxFQUFFLFNBQVMsR0FBRztBQUN4RTtBQUNBLGtFQUFrRSxlQUFlLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQSxxREFBcUQsRUFBRTtBQUN2RDtBQUNBLDJCQUEyQixJQUFJLEdBQUcsRUFBRSxVQUFVLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSx5RUFBeUUsRUFBRSxpQkFBaUIsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLEVBQUUsSUFBSSwyRUFBMkUsRUFBRSxpQkFBaUIsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksMkVBQTJFLEVBQUUsa0JBQWtCLElBQUksR0FBRyxFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRSxrQkFBa0IsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLHlFQUF5RSxFQUFFLGtCQUFrQixJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksRUFBRSxJQUFJLGNBQWMsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUsc0JBQXNCLElBQUksRUFBRSxJQUFJLGNBQWMsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUU7QUFDci9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGNBQWMsRUFBRSwrQkFBK0IsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksYUFBYSxJQUFJLGlCQUFpQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksaUJBQWlCLElBQUksVUFBVSxJQUFJLHVDQUF1QyxFQUFFLGdEQUFnRCxJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksMkNBQTJDLDhDQUE4QyxFQUFFLHlEQUF5RCxhQUFhLEVBQUUsMENBQTBDLGVBQWUsRUFBRSxtQ0FBbUMsZUFBZSxFQUFFLGdDQUFnQyxlQUFlLEVBQUUsZ0NBQWdDLGVBQWUsRUFBRSxnQ0FBZ0MsZUFBZSxFQUFFLG1DQUFtQyxpQkFBaUIsRUFBRSxpQ0FBaUMsaUJBQWlCLEVBQUU7QUFDM29DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9zcmMvZm9ybWF0LmNqcz84YTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Fqdi9ibG9iL21hc3Rlci9saWIvY29tcGlsZS9mb3JtYXRzLmpzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZhc3RGb3JtYXQgPSBleHBvcnRzLmZ1bGxGb3JtYXQgPSB2b2lkIDA7XG5jb25zdCBEQVRFID0gL14oXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0oXFxkXFxkKSQvO1xuY29uc3QgREFZUyA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLlxcZCspPyh6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG5jb25zdCBIT1NUTkFNRSA9IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2k7XG4vLyBjb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuY29uc3QgVVJJUkVGID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbi8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbmNvbnN0IFVSSVRFTVBMQVRFID0gL14oPzooPzpbXlxceDAwLVxceDIwXCInPD4lXFxcXF5ge3x9XXwlWzAtOWEtZl17Mn0pfFxce1srIy4vOz8mPSwhQHxdPyg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8oPzosKD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPykqXFx9KSokL2k7XG4vLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbi8vIEZvciB0ZXN0IGNhc2VzOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbmNvbnN0IFVSTF8gPSAvXig/Oig/Omh0dHBzP3xmdHApOlxcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ITEwKD86XFwuXFxkezEsM30pezN9KSg/ITEyNyg/OlxcLlxcZHsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTkyXFwuMTY4KD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstPykqW2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKykoPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rLT8pKlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXU7XG5jb25zdCBVVUlEID0gL14oPzp1cm46dXVpZDopP1swLTlhLWZdezh9LSg/OlswLTlhLWZdezR9LSl7M31bMC05YS1mXXsxMn0kL2k7XG5jb25zdCBKU09OX1BPSU5URVIgPSAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvO1xuY29uc3QgSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCA9IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2k7XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC87XG4vLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG5jb25zdCBGQVNUREFURSA9IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC87XG4vLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbmNvbnN0IEZBU1RUSU1FID0gL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG5jb25zdCBGQVNUREFURVRJTUUgPSAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pO1xuLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuLy8gY29uc3QgRkFTVFVSSSA9IC9eKD86W2Etel1bYS16MC05Ky0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2k7XG5jb25zdCBGQVNUVVJJUkVGRVJFTkNFID0gL14oPzooPzpbYS16XVthLXowLTkrLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0V4b2R1c01vdmVtZW50L3NjaGVtYXNhZmUvYmxvYi9tYXN0ZXIvc3JjL2Zvcm1hdHMuanNcbmNvbnN0IEVNQUlMID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0WzBdID09PSAnXCInKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgW25hbWUsIGhvc3QsIC4uLnJlc3RdID0gaW5wdXQuc3BsaXQoXCJAXCIpO1xuICAgIGlmICghbmFtZSB8fFxuICAgICAgICAhaG9zdCB8fFxuICAgICAgICByZXN0Lmxlbmd0aCAhPT0gMCB8fFxuICAgICAgICBuYW1lLmxlbmd0aCA+IDY0IHx8XG4gICAgICAgIGhvc3QubGVuZ3RoID4gMjUzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hbWVbMF0gPT09IFwiLlwiIHx8IG5hbWUuZW5kc1dpdGgoXCIuXCIpIHx8IG5hbWUuaW5jbHVkZXMoXCIuLlwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghL15bYS16MC05Li1dKyQvaS50ZXN0KGhvc3QpIHx8XG4gICAgICAgICEvXlthLXowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rJC9pLnRlc3QobmFtZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaG9zdFxuICAgICAgICAuc3BsaXQoXCIuXCIpXG4gICAgICAgIC5ldmVyeSgocGFydCkgPT4gL15bYS16MC05XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JC9pLnRlc3QocGFydCkpO1xufTtcbi8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbmNvbnN0IElQVjQgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvO1xuLy8gb3B0aW1pemVkIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTM0OTcvcmVndWxhci1leHByZXNzaW9uLXRoYXQtbWF0Y2hlcy12YWxpZC1pcHY2LWFkZHJlc3Nlc1xuY29uc3QgSVBWNiA9IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0V4b2R1c01vdmVtZW50L3NjaGVtYXNhZmUvYmxvYi9tYXN0ZXIvc3JjL2Zvcm1hdHMuanNcbmNvbnN0IERVUkFUSU9OID0gKGlucHV0KSA9PiBpbnB1dC5sZW5ndGggPiAxICYmXG4gICAgaW5wdXQubGVuZ3RoIDwgODAgJiZcbiAgICAoL15QXFxkKyhbLixdXFxkKyk/VyQvLnRlc3QoaW5wdXQpIHx8XG4gICAgICAgICgvXlBbXFxkWU1EVEhTXSooXFxkWy4sXVxcZCspP1tZTURIU10kLy50ZXN0KGlucHV0KSAmJlxuICAgICAgICAgICAgL15QKFsuLFxcZF0rWSk/KFsuLFxcZF0rTSk/KFsuLFxcZF0rRCk/KFQoWy4sXFxkXStIKT8oWy4sXFxkXStNKT8oWy4sXFxkXStTKT8pPyQvLnRlc3QoaW5wdXQpKSk7XG5mdW5jdGlvbiBiaW5kKHIpIHtcbiAgICByZXR1cm4gci50ZXN0LmJpbmQocik7XG59XG5leHBvcnRzLmZ1bGxGb3JtYXQgPSB7XG4gICAgZGF0ZSxcbiAgICB0aW1lOiAvKiAjX19QVVJFX18gKi8gdGltZS5iaW5kKHVuZGVmaW5lZCwgZmFsc2UpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGRhdGVfdGltZSxcbiAgICBkdXJhdGlvbjogRFVSQVRJT04sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvKiAjX19QVVJFX18gKi8gYmluZChVUklSRUYpLFxuICAgIFwidXJpLXRlbXBsYXRlXCI6IC8qICNfX1BVUkVfXyAqLyBiaW5kKFVSSVRFTVBMQVRFKSxcbiAgICB1cmw6IC8qICNfX1BVUkVfXyAqLyBiaW5kKFVSTF8pLFxuICAgIGVtYWlsOiBFTUFJTCxcbiAgICBob3N0bmFtZTogLyogI19fUFVSRV9fICovIGJpbmQoSE9TVE5BTUUpLFxuICAgIGlwdjQ6IC8qICNfX1BVUkVfXyAqLyBiaW5kKElQVjQpLFxuICAgIGlwdjY6IC8qICNfX1BVUkVfXyAqLyBiaW5kKElQVjYpLFxuICAgIHJlZ2V4OiByZWdleCxcbiAgICB1dWlkOiAvKiAjX19QVVJFX18gKi8gYmluZChVVUlEKSxcbiAgICBcImpzb24tcG9pbnRlclwiOiAvKiAjX19QVVJFX18gKi8gYmluZChKU09OX1BPSU5URVIpLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvKiAjX19QVVJFX18gKi8gYmluZChKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5UKSxcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvKiAjX19QVVJFX18gKi8gYmluZChSRUxBVElWRV9KU09OX1BPSU5URVIpLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdCA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXQsXG4gICAgZGF0ZTogLyogI19fUFVSRV9fICovIGJpbmQoRkFTVERBVEUpLFxuICAgIHRpbWU6IC8qICNfX1BVUkVfXyAqLyBiaW5kKEZBU1RUSU1FKSxcbiAgICBcImRhdGUtdGltZVwiOiAvKiAjX19QVVJFX18gKi8gYmluZChGQVNUREFURVRJTUUpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvKiAjX19QVVJFX18gKi8gYmluZChGQVNUVVJJUkVGRVJFTkNFKSxcbn07XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB5ZWFyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbW9udGggPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBkYXkgPSArbWF0Y2hlc1szXTtcbiAgICByZXR1cm4gKG1vbnRoID49IDEgJiZcbiAgICAgICAgbW9udGggPD0gMTIgJiZcbiAgICAgICAgZGF5ID49IDEgJiZcbiAgICAgICAgZGF5IDw9IChtb250aCA9PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiB0aW1lKGZ1bGwsIHN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goVElNRSk7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaG91ciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1pbnV0ZSA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IHNlY29uZCA9ICttYXRjaGVzWzNdO1xuICAgIGNvbnN0IHRpbWVab25lID0gISFtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09IDIzICYmIG1pbnV0ZSA9PSA1OSAmJiBzZWNvbmQgPT0gNjApKSAmJlxuICAgICAgICAoIWZ1bGwgfHwgdGltZVpvbmUpKTtcbn1cbmNvbnN0IERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgZGF0ZVRpbWUgPSBzdHIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUodHJ1ZSwgZGF0ZVRpbWVbMV0pO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUklfUEFUVEVSTiA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gICAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJX1BBVFRFUk4udGVzdChzdHIpO1xufVxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaLztcbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHN0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/index.cjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/index.cjs ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./deep-compare-strict.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./dereference.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./format.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./pointer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./ucs2-length.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/ucs2-length.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./validate.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./validator.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validator.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG9JQUEyQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsb0hBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQywwR0FBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsNEdBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHdHQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLDhHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsZ0hBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9zcmMvaW5kZXguY2pzP2JiYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kZWVwLWNvbXBhcmUtc3RyaWN0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVyZWZlcmVuY2UuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mb3JtYXQuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wb2ludGVyLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91Y3MyLWxlbmd0aC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdG9yLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escapePointer = exports.encodePointer = void 0;\nfunction encodePointer(p) {\n    return encodeURI(escapePointer(p));\n}\nexports.encodePointer = encodePointer;\nfunction escapePointer(p) {\n    return p.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapePointer = escapePointer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy9wb2ludGVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9AY2Z3b3JrZXIvanNvbi1zY2hlbWEvc3JjL3BvaW50ZXIuY2pzPzEwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzY2FwZVBvaW50ZXIgPSBleHBvcnRzLmVuY29kZVBvaW50ZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbmNvZGVQb2ludGVyKHApIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJKGVzY2FwZVBvaW50ZXIocCkpO1xufVxuZXhwb3J0cy5lbmNvZGVQb2ludGVyID0gZW5jb2RlUG9pbnRlcjtcbmZ1bmN0aW9uIGVzY2FwZVBvaW50ZXIocCkge1xuICAgIHJldHVybiBwLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlUG9pbnRlciA9IGVzY2FwZVBvaW50ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/types.cjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/types.cjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy90eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy90eXBlcy5janM/YTI5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/ucs2-length.cjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/ucs2-length.cjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ucs2length = void 0;\n/**\n * Get UCS-2 length of a string\n * https://mathiasbynens.be/notes/javascript-encoding\n * https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\n */\nfunction ucs2length(s) {\n    let result = 0;\n    let length = s.length;\n    let index = 0;\n    let charCode;\n    while (index < length) {\n        result++;\n        charCode = s.charCodeAt(index++);\n        if (charCode >= 0xd800 && charCode <= 0xdbff && index < length) {\n            // high surrogate, and there is a next character\n            charCode = s.charCodeAt(index);\n            if ((charCode & 0xfc00) == 0xdc00) {\n                // low surrogate\n                index++;\n            }\n        }\n    }\n    return result;\n}\nexports.ucs2length = ucs2length;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy91Y3MyLWxlbmd0aC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9AY2Z3b3JrZXIvanNvbi1zY2hlbWEvc3JjL3VjczItbGVuZ3RoLmNqcz9mZWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51Y3MybGVuZ3RoID0gdm9pZCAwO1xuLyoqXG4gKiBHZXQgVUNTLTIgbGVuZ3RoIG9mIGEgc3RyaW5nXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbiAqL1xuZnVuY3Rpb24gdWNzMmxlbmd0aChzKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGNoYXJDb2RlO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHQrKztcbiAgICAgICAgY2hhckNvZGUgPSBzLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gcy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICgoY2hhckNvZGUgJiAweGZjMDApID09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVjczJsZW5ndGggPSB1Y3MybGVuZ3RoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/ucs2-length.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.cjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validate = void 0;\nconst deep_compare_strict_js_1 = __webpack_require__(/*! ./deep-compare-strict.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.cjs\");\nconst dereference_js_1 = __webpack_require__(/*! ./dereference.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs\");\nconst format_js_1 = __webpack_require__(/*! ./format.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.cjs\");\nconst pointer_js_1 = __webpack_require__(/*! ./pointer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/pointer.cjs\");\nconst ucs2_length_js_1 = __webpack_require__(/*! ./ucs2-length.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/ucs2-length.cjs\");\nfunction validate(instance, schema, draft = \"2019-09\", lookup = (0, dereference_js_1.dereference)(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: \"false\",\n                    keywordLocation: instanceLocation,\n                    error: \"False boolean schema.\",\n                },\n            ],\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            instanceType = rawInstanceType;\n            break;\n        case \"object\":\n            if (instance === null) {\n                instanceType = \"null\";\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = \"array\";\n            }\n            else {\n                instanceType = \"object\";\n            }\n            break;\n        default:\n            // undefined, bigint, function, symbol\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__, } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === \"#\") {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$recursiveRef\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$ref\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n        if (draft === \"4\" || draft === \"7\") {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === \"integer\" &&\n                    instanceType === \"number\" &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`,\n            });\n        }\n    }\n    else if ($type === \"integer\") {\n        if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: \"type\",\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!(0, deep_compare_strict_js_1.deepCompareStrict)(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"const\",\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`,\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: \"const\",\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`,\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!$enum.some((value) => (0, deep_compare_strict_js_1.deepCompareStrict)(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"enum\",\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n                });\n            }\n        }\n        else if (!$enum.some((value) => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"enum\",\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n        evaluated*/);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"not\",\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.',\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"anyOf\",\n                keywordLocation,\n                error: \"Instance does not match any subschemas.\",\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"allOf\",\n                keywordLocation,\n                error: `Instance does not match every subschema.`,\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"oneOf\",\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`,\n            });\n        }\n    }\n    if (instanceType === \"object\" || instanceType === \"array\") {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"if\",\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`,\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"if\",\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`,\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === \"object\") {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"required\",\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`,\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minProperties\",\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`,\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxProperties\",\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`,\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"propertyNames\",\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependentRequired\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"dependentSchemas\",\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: \"dependencies\",\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependencies\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`,\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"properties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern);\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"patternProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"additionalProperties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"unevaluatedProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"array\") {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxItems\",\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`,\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minItems\",\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`,\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"prefixItems\",\n                        keywordLocation,\n                        error: `Items did not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"additionalItems\",\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"contains\",\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`,\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minContains\",\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`,\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: \"contains\",\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`,\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"minContains\",\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`,\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"maxContains\",\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`,\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"unevaluatedItems\",\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === \"object\" && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === \"object\" && b !== null;\n                    if (a === b || (ao && bo && (0, deep_compare_strict_js_1.deepCompareStrict)(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"uniqueItems\",\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`,\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"number\") {\n        if (draft === \"4\") {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`,\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`,\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMinimum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`,\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMaximum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`,\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"multipleOf\",\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`,\n                });\n            }\n        }\n    }\n    else if (instanceType === \"string\") {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : (0, ucs2_length_js_1.ucs2length)(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minLength\",\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`,\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxLength\",\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`,\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"pattern\",\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`,\n            });\n        }\n        if ($format !== undefined &&\n            format_js_1.fastFormat[$format] &&\n            !format_js_1.fastFormat[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"format\",\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`,\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\nexports.validate = validate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy92YWxpZGF0ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLGlDQUFpQyxtQkFBTyxDQUFDLG9JQUEyQjtBQUNwRSx5QkFBeUIsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsMEdBQWM7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsNEdBQWU7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsb0hBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBLFlBQVksK2lDQUEraUM7QUFDM2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQSw4Q0FBOEMsaUNBQWlDO0FBQy9FO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25ELHlDQUF5QyxhQUFhLDBCQUEwQixtQkFBbUI7QUFDbkcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQseUNBQXlDLGFBQWEsMEJBQTBCLE1BQU07QUFDdEYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DLHFDQUFxQyxhQUFhLDBCQUEwQixNQUFNO0FBQ2xGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELHNEQUFzRCx1QkFBdUI7QUFDN0UsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25ELGtEQUFrRCx1QkFBdUI7QUFDekUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCw2REFBNkQsc0JBQXNCO0FBQ25GLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRCx5REFBeUQsc0JBQXNCO0FBQy9FLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLCtKQUErSixnQkFBZ0IsR0FBRyxFQUFFO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsK0pBQStKLGdCQUFnQixHQUFHLEVBQUU7QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtKQUErSixnQkFBZ0IsR0FBRyxFQUFFO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTO0FBQ2xGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0ksZUFBZTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsZUFBZTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRCw0RUFBNEUsSUFBSTtBQUNoRixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25ELDBEQUEwRCxnQkFBZ0I7QUFDMUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRCwwREFBMEQsZ0JBQWdCO0FBQzFFLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQSw4Q0FBOEMsaUJBQWlCLEdBQUcscUNBQXFDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJLHVCQUF1QixhQUFhO0FBQ2hHLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EsaUpBQWlKLGdCQUFnQixHQUFHLHFDQUFxQztBQUN6TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJLHVCQUF1QixhQUFhO0FBQ3BHLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxnQkFBZ0IsR0FBRyxxQ0FBcUM7QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCLEdBQUcscUNBQXFDO0FBQ3ZHLDhJQUE4SSxnQkFBZ0IsR0FBRyxxQ0FBcUM7QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQixHQUFHLHFDQUFxQztBQUMzRywySUFBMkksZ0JBQWdCLEdBQUcseUNBQXlDO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJLHFCQUFxQixRQUFRO0FBQ2pGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCLEdBQUcscUNBQXFDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLGtEQUFrRCxpQkFBaUIsR0FBRyxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQsb0RBQW9ELGlCQUFpQixJQUFJLFVBQVU7QUFDbkYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRCxtREFBbUQsaUJBQWlCLElBQUksVUFBVTtBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEMsdUhBQXVILGlCQUFpQixHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHFIQUFxSCxpQkFBaUIsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRTtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLGtIQUFrSCxpQkFBaUIsR0FBRyxFQUFFO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQsdUJBQXVCLFlBQVk7QUFDbkMsNEhBQTRILGlCQUFpQixHQUFHLEVBQUU7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsb0RBQW9ELE9BQU8sc0JBQXNCLGFBQWE7QUFDOUYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMscUhBQXFILGlCQUFpQixHQUFHLEVBQUU7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELDhEQUE4RCxjQUFjLDhCQUE4QixXQUFXO0FBQ3JILHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsNERBQTRELGNBQWMseUJBQXlCLFdBQVc7QUFDOUcscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUhBQXlILGlCQUFpQixHQUFHLEVBQUU7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0QsaUVBQWlFLEdBQUcsTUFBTSxFQUFFO0FBQzVFLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCw4QkFBOEIsVUFBVSxlQUFlLHlDQUF5QyxFQUFFLFNBQVM7QUFDM0csaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsOEJBQThCLFVBQVUsa0JBQWtCLHlDQUF5QyxFQUFFLFNBQVM7QUFDOUcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsOEJBQThCLFVBQVUsZUFBZSxTQUFTO0FBQ2hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsOEJBQThCLFVBQVUsa0JBQWtCLFNBQVM7QUFDbkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCw4QkFBOEIsVUFBVSxlQUFlLGtCQUFrQjtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELDhCQUE4QixVQUFVLDhCQUE4QixrQkFBa0I7QUFDeEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELDhCQUE4QixVQUFVLHVCQUF1QixZQUFZO0FBQzNFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQsK0NBQStDLFFBQVEsSUFBSSxXQUFXO0FBQ3RFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQsOENBQThDLFFBQVEsSUFBSSxXQUFXO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRCx3REFBd0QsUUFBUTtBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9AY2Z3b3JrZXIvanNvbi1zY2hlbWEvc3JjL3ZhbGlkYXRlLmNqcz9jY2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGRlZXBfY29tcGFyZV9zdHJpY3RfanNfMSA9IHJlcXVpcmUoXCIuL2RlZXAtY29tcGFyZS1zdHJpY3QuY2pzXCIpO1xuY29uc3QgZGVyZWZlcmVuY2VfanNfMSA9IHJlcXVpcmUoXCIuL2RlcmVmZXJlbmNlLmNqc1wiKTtcbmNvbnN0IGZvcm1hdF9qc18xID0gcmVxdWlyZShcIi4vZm9ybWF0LmNqc1wiKTtcbmNvbnN0IHBvaW50ZXJfanNfMSA9IHJlcXVpcmUoXCIuL3BvaW50ZXIuY2pzXCIpO1xuY29uc3QgdWNzMl9sZW5ndGhfanNfMSA9IHJlcXVpcmUoXCIuL3VjczItbGVuZ3RoLmNqc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlKGluc3RhbmNlLCBzY2hlbWEsIGRyYWZ0ID0gXCIyMDE5LTA5XCIsIGxvb2t1cCA9ICgwLCBkZXJlZmVyZW5jZV9qc18xLmRlcmVmZXJlbmNlKShzY2hlbWEpLCBzaG9ydENpcmN1aXQgPSB0cnVlLCByZWN1cnNpdmVBbmNob3IgPSBudWxsLCBpbnN0YW5jZUxvY2F0aW9uID0gXCIjXCIsIHNjaGVtYUxvY2F0aW9uID0gXCIjXCIsIGV2YWx1YXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICBpZiAoc2NoZW1hID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJGYWxzZSBib29sZWFuIHNjaGVtYS5cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmF3SW5zdGFuY2VUeXBlID0gdHlwZW9mIGluc3RhbmNlO1xuICAgIGxldCBpbnN0YW5jZVR5cGU7XG4gICAgc3dpdGNoIChyYXdJbnN0YW5jZVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBpbnN0YW5jZVR5cGUgPSByYXdJbnN0YW5jZVR5cGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VUeXBlID0gXCJudWxsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlVHlwZSA9IFwib2JqZWN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCwgYmlnaW50LCBmdW5jdGlvbiwgc3ltYm9sXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlcyBvZiBcIiR7cmF3SW5zdGFuY2VUeXBlfVwiIHR5cGUgYXJlIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgJHJlZiwgJHJlY3Vyc2l2ZVJlZiwgJHJlY3Vyc2l2ZUFuY2hvciwgdHlwZTogJHR5cGUsIGNvbnN0OiAkY29uc3QsIGVudW06ICRlbnVtLCByZXF1aXJlZDogJHJlcXVpcmVkLCBub3Q6ICRub3QsIGFueU9mOiAkYW55T2YsIGFsbE9mOiAkYWxsT2YsIG9uZU9mOiAkb25lT2YsIGlmOiAkaWYsIHRoZW46ICR0aGVuLCBlbHNlOiAkZWxzZSwgZm9ybWF0OiAkZm9ybWF0LCBwcm9wZXJ0aWVzOiAkcHJvcGVydGllcywgcGF0dGVyblByb3BlcnRpZXM6ICRwYXR0ZXJuUHJvcGVydGllcywgYWRkaXRpb25hbFByb3BlcnRpZXM6ICRhZGRpdGlvbmFsUHJvcGVydGllcywgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiAkdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzLCBtaW5Qcm9wZXJ0aWVzOiAkbWluUHJvcGVydGllcywgbWF4UHJvcGVydGllczogJG1heFByb3BlcnRpZXMsIHByb3BlcnR5TmFtZXM6ICRwcm9wZXJ0eU5hbWVzLCBkZXBlbmRlbnRSZXF1aXJlZDogJGRlcGVuZGVudFJlcXVpcmVkLCBkZXBlbmRlbnRTY2hlbWFzOiAkZGVwZW5kZW50U2NoZW1hcywgZGVwZW5kZW5jaWVzOiAkZGVwZW5kZW5jaWVzLCBwcmVmaXhJdGVtczogJHByZWZpeEl0ZW1zLCBpdGVtczogJGl0ZW1zLCBhZGRpdGlvbmFsSXRlbXM6ICRhZGRpdGlvbmFsSXRlbXMsIHVuZXZhbHVhdGVkSXRlbXM6ICR1bmV2YWx1YXRlZEl0ZW1zLCBjb250YWluczogJGNvbnRhaW5zLCBtaW5Db250YWluczogJG1pbkNvbnRhaW5zLCBtYXhDb250YWluczogJG1heENvbnRhaW5zLCBtaW5JdGVtczogJG1pbkl0ZW1zLCBtYXhJdGVtczogJG1heEl0ZW1zLCB1bmlxdWVJdGVtczogJHVuaXF1ZUl0ZW1zLCBtaW5pbXVtOiAkbWluaW11bSwgbWF4aW11bTogJG1heGltdW0sIGV4Y2x1c2l2ZU1pbmltdW06ICRleGNsdXNpdmVNaW5pbXVtLCBleGNsdXNpdmVNYXhpbXVtOiAkZXhjbHVzaXZlTWF4aW11bSwgbXVsdGlwbGVPZjogJG11bHRpcGxlT2YsIG1pbkxlbmd0aDogJG1pbkxlbmd0aCwgbWF4TGVuZ3RoOiAkbWF4TGVuZ3RoLCBwYXR0ZXJuOiAkcGF0dGVybiwgX19hYnNvbHV0ZV9yZWZfXywgX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX18sIH0gPSBzY2hlbWE7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKCRyZWN1cnNpdmVBbmNob3IgPT09IHRydWUgJiYgcmVjdXJzaXZlQW5jaG9yID09PSBudWxsKSB7XG4gICAgICAgIHJlY3Vyc2l2ZUFuY2hvciA9IHNjaGVtYTtcbiAgICB9XG4gICAgaWYgKCRyZWN1cnNpdmVSZWYgPT09IFwiI1wiKSB7XG4gICAgICAgIGNvbnN0IHJlZlNjaGVtYSA9IHJlY3Vyc2l2ZUFuY2hvciA9PT0gbnVsbFxuICAgICAgICAgICAgPyBsb29rdXBbX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX19dXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZUFuY2hvcjtcbiAgICAgICAgY29uc3Qga2V5d29yZExvY2F0aW9uID0gYCR7c2NoZW1hTG9jYXRpb259LyRyZWN1cnNpdmVSZWZgO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgcmVjdXJzaXZlQW5jaG9yID09PSBudWxsID8gc2NoZW1hIDogcmVjdXJzaXZlQW5jaG9yLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlZlNjaGVtYSwgaW5zdGFuY2VMb2NhdGlvbiwga2V5d29yZExvY2F0aW9uLCBldmFsdWF0ZWQpO1xuICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCIkcmVjdXJzaXZlUmVmXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGVycm9yOiBcIkEgc3Vic2NoZW1hIGhhZCBlcnJvcnMuXCIsXG4gICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IF9fYWJzb2x1dGVfcmVmX18gfHwgJHJlZjtcbiAgICAgICAgY29uc3QgcmVmU2NoZW1hID0gbG9va3VwW3VyaV07XG4gICAgICAgIGlmIChyZWZTY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVW5yZXNvbHZlZCAkcmVmIFwiJHskcmVmfVwiLmA7XG4gICAgICAgICAgICBpZiAoX19hYnNvbHV0ZV9yZWZfXyAmJiBfX2Fic29sdXRlX3JlZl9fICE9PSAkcmVmKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgICBBYnNvbHV0ZSBVUkkgXCIke19fYWJzb2x1dGVfcmVmX199XCIuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYFxcbktub3duIHNjaGVtYXM6XFxuLSAke09iamVjdC5rZXlzKGxvb2t1cCkuam9pbihcIlxcbi0gXCIpfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5d29yZExvY2F0aW9uID0gYCR7c2NoZW1hTG9jYXRpb259LyRyZWZgO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgcmVmU2NoZW1hLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgaW5zdGFuY2VMb2NhdGlvbiwga2V5d29yZExvY2F0aW9uLCBldmFsdWF0ZWQpO1xuICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGVycm9yOiBcIkEgc3Vic2NoZW1hIGhhZCBlcnJvcnMuXCIsXG4gICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhZnQgPT09IFwiNFwiIHx8IGRyYWZ0ID09PSBcIjdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsIGVycm9ycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KCR0eXBlKSkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gJHR5cGUubGVuZ3RoO1xuICAgICAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gJHR5cGVbaV0gfHxcbiAgICAgICAgICAgICAgICAoJHR5cGVbaV0gPT09IFwiaW50ZWdlclwiICYmXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlVHlwZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSAlIDEgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPT09IGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS90eXBlYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIHR5cGUgXCIke2luc3RhbmNlVHlwZX1cIiBpcyBpbnZhbGlkLiBFeHBlY3RlZCBcIiR7JHR5cGUuam9pbignXCIsIFwiJyl9XCIuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCR0eXBlID09PSBcImludGVnZXJcIikge1xuICAgICAgICBpZiAoaW5zdGFuY2VUeXBlICE9PSBcIm51bWJlclwiIHx8IGluc3RhbmNlICUgMSB8fCBpbnN0YW5jZSAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L3R5cGVgLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgdHlwZSBcIiR7aW5zdGFuY2VUeXBlfVwiIGlzIGludmFsaWQuIEV4cGVjdGVkIFwiJHskdHlwZX1cIi5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoJHR5cGUgIT09IHVuZGVmaW5lZCAmJiBpbnN0YW5jZVR5cGUgIT09ICR0eXBlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L3R5cGVgLFxuICAgICAgICAgICAgZXJyb3I6IGBJbnN0YW5jZSB0eXBlIFwiJHtpbnN0YW5jZVR5cGV9XCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgXCIkeyR0eXBlfVwiLmAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJGNvbnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gXCJvYmplY3RcIiB8fCBpbnN0YW5jZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKCEoMCwgZGVlcF9jb21wYXJlX3N0cmljdF9qc18xLmRlZXBDb21wYXJlU3RyaWN0KShpbnN0YW5jZSwgJGNvbnN0KSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9jb25zdGAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgZG9lcyBub3QgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeSgkY29uc3QpfS5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlICE9PSAkY29uc3QpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9jb25zdGAsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBJbnN0YW5jZSBkb2VzIG5vdCBtYXRjaCAke0pTT04uc3RyaW5naWZ5KCRjb25zdCl9LmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGVudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5zdGFuY2VUeXBlID09PSBcIm9iamVjdFwiIHx8IGluc3RhbmNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoISRlbnVtLnNvbWUoKHZhbHVlKSA9PiAoMCwgZGVlcF9jb21wYXJlX3N0cmljdF9qc18xLmRlZXBDb21wYXJlU3RyaWN0KShpbnN0YW5jZSwgdmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L2VudW1gLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IG1hdGNoIGFueSBvZiAke0pTT04uc3RyaW5naWZ5KCRlbnVtKX0uYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghJGVudW0uc29tZSgodmFsdWUpID0+IGluc3RhbmNlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L2VudW1gLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgZG9lcyBub3QgbWF0Y2ggYW55IG9mICR7SlNPTi5zdHJpbmdpZnkoJGVudW0pfS5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vbm90YDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUoaW5zdGFuY2UsICRub3QsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBpbnN0YW5jZUxvY2F0aW9uLCBrZXl3b3JkTG9jYXRpb24gLyosXG4gICAgICAgIGV2YWx1YXRlZCovKTtcbiAgICAgICAgaWYgKHJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdJbnN0YW5jZSBtYXRjaGVkIFwibm90XCIgc2NoZW1hLicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3ViRXZhbHVhdGVkcyA9IFtdO1xuICAgIGlmICgkYW55T2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vYW55T2ZgO1xuICAgICAgICBjb25zdCBlcnJvcnNMZW5ndGggPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgICBsZXQgYW55VmFsaWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkYW55T2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlNjaGVtYSA9ICRhbnlPZltpXTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkV2YWx1YXRlZCA9IE9iamVjdC5jcmVhdGUoZXZhbHVhdGVkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlLCBzdWJTY2hlbWEsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgJHJlY3Vyc2l2ZUFuY2hvciA9PT0gdHJ1ZSA/IHJlY3Vyc2l2ZUFuY2hvciA6IG51bGwsIGluc3RhbmNlTG9jYXRpb24sIGAke2tleXdvcmRMb2NhdGlvbn0vJHtpfWAsIHN1YkV2YWx1YXRlZCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgIGFueVZhbGlkID0gYW55VmFsaWQgfHwgcmVzdWx0LnZhbGlkO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgIHN1YkV2YWx1YXRlZHMucHVzaChzdWJFdmFsdWF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWxpZCkge1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCA9IGVycm9yc0xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5zcGxpY2UoZXJyb3JzTGVuZ3RoLCAwLCB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGVycm9yOiBcIkluc3RhbmNlIGRvZXMgbm90IG1hdGNoIGFueSBzdWJzY2hlbWFzLlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRhbGxPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9hbGxPZmA7XG4gICAgICAgIGNvbnN0IGVycm9yc0xlbmd0aCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICAgIGxldCBhbGxWYWxpZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGFsbE9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSAkYWxsT2ZbaV07XG4gICAgICAgICAgICBjb25zdCBzdWJFdmFsdWF0ZWQgPSBPYmplY3QuY3JlYXRlKGV2YWx1YXRlZCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgc3ViU2NoZW1hLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsICRyZWN1cnNpdmVBbmNob3IgPT09IHRydWUgPyByZWN1cnNpdmVBbmNob3IgOiBudWxsLCBpbnN0YW5jZUxvY2F0aW9uLCBgJHtrZXl3b3JkTG9jYXRpb259LyR7aX1gLCBzdWJFdmFsdWF0ZWQpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICBhbGxWYWxpZCA9IGFsbFZhbGlkICYmIHJlc3VsdC52YWxpZDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzdWJFdmFsdWF0ZWRzLnB1c2goc3ViRXZhbHVhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsVmFsaWQpIHtcbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggPSBlcnJvcnNMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMuc3BsaWNlKGVycm9yc0xlbmd0aCwgMCwge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhbGxPZlwiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IG1hdGNoIGV2ZXJ5IHN1YnNjaGVtYS5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRvbmVPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9vbmVPZmA7XG4gICAgICAgIGNvbnN0IGVycm9yc0xlbmd0aCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSAkb25lT2YuZmlsdGVyKChzdWJTY2hlbWEsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkV2YWx1YXRlZCA9IE9iamVjdC5jcmVhdGUoZXZhbHVhdGVkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlLCBzdWJTY2hlbWEsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgJHJlY3Vyc2l2ZUFuY2hvciA9PT0gdHJ1ZSA/IHJlY3Vyc2l2ZUFuY2hvciA6IG51bGwsIGluc3RhbmNlTG9jYXRpb24sIGAke2tleXdvcmRMb2NhdGlvbn0vJHtpfWAsIHN1YkV2YWx1YXRlZCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzdWJFdmFsdWF0ZWRzLnB1c2goc3ViRXZhbHVhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsaWQ7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IDEpIHtcbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggPSBlcnJvcnNMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMuc3BsaWNlKGVycm9yc0xlbmd0aCwgMCwge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IG1hdGNoIGV4YWN0bHkgb25lIHN1YnNjaGVtYSAoJHttYXRjaGVzfSBtYXRjaGVzKS5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gXCJvYmplY3RcIiB8fCBpbnN0YW5jZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBPYmplY3QuYXNzaWduKGV2YWx1YXRlZCwgLi4uc3ViRXZhbHVhdGVkcyk7XG4gICAgfVxuICAgIGlmICgkaWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vaWZgO1xuICAgICAgICBjb25zdCBjb25kaXRpb25SZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgJGlmLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgaW5zdGFuY2VMb2NhdGlvbiwga2V5d29yZExvY2F0aW9uLCBldmFsdWF0ZWQpLnZhbGlkO1xuICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoJHRoZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoZW5SZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgJHRoZW4sIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBpbnN0YW5jZUxvY2F0aW9uLCBgJHtzY2hlbWFMb2NhdGlvbn0vdGhlbmAsIGV2YWx1YXRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGVuUmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IG1hdGNoIFwidGhlblwiIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICB9LCAuLi50aGVuUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRlbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsc2VSZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZSwgJGVsc2UsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBpbnN0YW5jZUxvY2F0aW9uLCBgJHtzY2hlbWFMb2NhdGlvbn0vZWxzZWAsIGV2YWx1YXRlZCk7XG4gICAgICAgICAgICBpZiAoIWVsc2VSZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IG1hdGNoIFwiZWxzZVwiIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgIH0sIC4uLmVsc2VSZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICgkcmVxdWlyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgJHJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vcmVxdWlyZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBJbnN0YW5jZSBkb2VzIG5vdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZSk7XG4gICAgICAgIGlmICgkbWluUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICYmIGtleXMubGVuZ3RoIDwgJG1pblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWluUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L21pblByb3BlcnRpZXNgLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCAkeyRtaW5Qcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJG1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJiBrZXlzLmxlbmd0aCA+ICRtYXhQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm1heFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9tYXhQcm9wZXJ0aWVzYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEluc3RhbmNlIGRvZXMgbm90IGhhdmUgYXQgbGVhc3QgJHskbWF4UHJvcGVydGllc30gcHJvcGVydGllcy5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRwcm9wZXJ0eU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9wcm9wZXJ0eU5hbWVzYDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViSW5zdGFuY2VQb2ludGVyID0gYCR7aW5zdGFuY2VMb2NhdGlvbn0vJHsoMCwgcG9pbnRlcl9qc18xLmVuY29kZVBvaW50ZXIpKGtleSl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShrZXksICRwcm9wZXJ0eU5hbWVzLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgc3ViSW5zdGFuY2VQb2ludGVyLCBrZXl3b3JkTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgUHJvcGVydHkgbmFtZSBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRkZXBlbmRlbnRSZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vZGVwZW5kYW50UmVxdWlyZWRgO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gJGRlcGVuZGVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZCA9ICRkZXBlbmRlbnRSZXF1aXJlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGFudEtleSBvZiByZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVwZW5kYW50S2V5IGluIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJkZXBlbmRlbnRSZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgaGFzIFwiJHtrZXl9XCIgYnV0IGRvZXMgbm90IGhhdmUgXCIke2RlcGVuZGFudEtleX1cIi5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkZGVwZW5kZW50U2NoZW1hcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiAkZGVwZW5kZW50U2NoZW1hcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9kZXBlbmRlbnRTY2hlbWFzYDtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlLCAkZGVwZW5kZW50U2NoZW1hc1trZXldLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgaW5zdGFuY2VMb2NhdGlvbiwgYCR7a2V5d29yZExvY2F0aW9ufS8keygwLCBwb2ludGVyX2pzXzEuZW5jb2RlUG9pbnRlcikoa2V5KX1gLCBldmFsdWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJkZXBlbmRlbnRTY2hlbWFzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgaGFzIFwiJHtrZXl9XCIgYnV0IGRvZXMgbm90IG1hdGNoIGRlcGVuZGFudCBzY2hlbWEuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkZGVwZW5kZW5jaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9kZXBlbmRlbmNpZXNgO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gJGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNPclNjaGVtYSA9ICRkZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNPclNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kYW50S2V5IG9mIHByb3BzT3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXBlbmRhbnRLZXkgaW4gaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBJbnN0YW5jZSBoYXMgXCIke2tleX1cIiBidXQgZG9lcyBub3QgaGF2ZSBcIiR7ZGVwZW5kYW50S2V5fVwiLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlLCBwcm9wc09yU2NoZW1hLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgaW5zdGFuY2VMb2NhdGlvbiwgYCR7a2V5d29yZExvY2F0aW9ufS8keygwLCBwb2ludGVyX2pzXzEuZW5jb2RlUG9pbnRlcikoa2V5KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgSW5zdGFuY2UgaGFzIFwiJHtrZXl9XCIgYnV0IGRvZXMgbm90IG1hdGNoIGRlcGVuZGFudCBzY2hlbWEuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlzRXZhbHVhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKCRwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9wcm9wZXJ0aWVzYDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluICRwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViSW5zdGFuY2VQb2ludGVyID0gYCR7aW5zdGFuY2VMb2NhdGlvbn0vJHsoMCwgcG9pbnRlcl9qc18xLmVuY29kZVBvaW50ZXIpKGtleSl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZVtrZXldLCAkcHJvcGVydGllc1trZXldLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgc3ViSW5zdGFuY2VQb2ludGVyLCBgJHtrZXl3b3JkTG9jYXRpb259LyR7KDAsIHBvaW50ZXJfanNfMS5lbmNvZGVQb2ludGVyKShrZXkpfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkW2tleV0gPSB0aGlzRXZhbHVhdGVkW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHNob3J0Q2lyY3VpdDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBQcm9wZXJ0eSBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdG9wICYmICRwYXR0ZXJuUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vcGF0dGVyblByb3BlcnRpZXNgO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIGluICRwYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSAkcGF0dGVyblByb3BlcnRpZXNbcGF0dGVybl07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ykluc3RhbmNlUG9pbnRlciA9IGAke2luc3RhbmNlTG9jYXRpb259LyR7KDAsIHBvaW50ZXJfanNfMS5lbmNvZGVQb2ludGVyKShrZXkpfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2tleV0sIHN1YlNjaGVtYSwgZHJhZnQsIGxvb2t1cCwgc2hvcnRDaXJjdWl0LCByZWN1cnNpdmVBbmNob3IsIHN1Ykluc3RhbmNlUG9pbnRlciwgYCR7a2V5d29yZExvY2F0aW9ufS8keygwLCBwb2ludGVyX2pzXzEuZW5jb2RlUG9pbnRlcikocGF0dGVybil9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFtrZXldID0gdGhpc0V2YWx1YXRlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBzaG9ydENpcmN1aXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgUHJvcGVydHkgXCIke2tleX1cIiBtYXRjaGVzIHBhdHRlcm4gXCIke3BhdHRlcm59XCIgYnV0IGRvZXMgbm90IG1hdGNoIGFzc29jaWF0ZWQgc2NoZW1hLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0b3AgJiYgJGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9hZGRpdGlvbmFsUHJvcGVydGllc2A7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzRXZhbHVhdGVkW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ykluc3RhbmNlUG9pbnRlciA9IGAke2luc3RhbmNlTG9jYXRpb259LyR7KDAsIHBvaW50ZXJfanNfMS5lbmNvZGVQb2ludGVyKShrZXkpfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUoaW5zdGFuY2Vba2V5XSwgJGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgc3ViSW5zdGFuY2VQb2ludGVyLCBrZXl3b3JkTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHNob3J0Q2lyY3VpdDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgUHJvcGVydHkgXCIke2tleX1cIiBkb2VzIG5vdCBtYXRjaCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgc2NoZW1hLmAsXG4gICAgICAgICAgICAgICAgICAgIH0sIC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc3RvcCAmJiAkdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS91bmV2YWx1YXRlZFByb3BlcnRpZXNgO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2YWx1YXRlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ykluc3RhbmNlUG9pbnRlciA9IGAke2luc3RhbmNlTG9jYXRpb259LyR7KDAsIHBvaW50ZXJfanNfMS5lbmNvZGVQb2ludGVyKShrZXkpfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2tleV0sICR1bmV2YWx1YXRlZFByb3BlcnRpZXMsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBzdWJJbnN0YW5jZVBvaW50ZXIsIGtleXdvcmRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgUHJvcGVydHkgXCIke2tleX1cIiBkb2VzIG5vdCBtYXRjaCB1bmV2YWx1YXRlZCBwcm9wZXJ0aWVzIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgaWYgKCRtYXhJdGVtcyAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlLmxlbmd0aCA+ICRtYXhJdGVtcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJtYXhJdGVtc1wiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L21heEl0ZW1zYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEFycmF5IGhhcyB0b28gbWFueSBpdGVtcyAoJHtpbnN0YW5jZS5sZW5ndGh9ID4gJHskbWF4SXRlbXN9KS5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRtaW5JdGVtcyAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlLmxlbmd0aCA8ICRtaW5JdGVtcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJtaW5JdGVtc1wiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L21pbkl0ZW1zYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEFycmF5IGhhcyB0b28gZmV3IGl0ZW1zICgke2luc3RhbmNlLmxlbmd0aH0gPCAkeyRtaW5JdGVtc30pLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBpbnN0YW5jZS5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKCRwcmVmaXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vcHJlZml4SXRlbXNgO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGgubWluKCRwcmVmaXhJdGVtcy5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2ldLCAkcHJlZml4SXRlbXNbaV0sIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBgJHtpbnN0YW5jZUxvY2F0aW9ufS8ke2l9YCwgYCR7a2V5d29yZExvY2F0aW9ufS8ke2l9YCk7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gc2hvcnRDaXJjdWl0O1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJwcmVmaXhJdGVtc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBJdGVtcyBkaWQgbm90IG1hdGNoIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vaXRlbXNgO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoJGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLm1pbigkaXRlbXMubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2ldLCAkaXRlbXNbaV0sIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBgJHtpbnN0YW5jZUxvY2F0aW9ufS8ke2l9YCwgYCR7a2V5d29yZExvY2F0aW9ufS8ke2l9YCk7XG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gc2hvcnRDaXJjdWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEl0ZW1zIGRpZCBub3QgbWF0Y2ggc2NoZW1hLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShpbnN0YW5jZVtpXSwgJGl0ZW1zLCBkcmFmdCwgbG9va3VwLCBzaG9ydENpcmN1aXQsIHJlY3Vyc2l2ZUFuY2hvciwgYCR7aW5zdGFuY2VMb2NhdGlvbn0vJHtpfWAsIGtleXdvcmRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gc2hvcnRDaXJjdWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEl0ZW1zIGRpZCBub3QgbWF0Y2ggc2NoZW1hLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdG9wICYmICRhZGRpdGlvbmFsSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9hZGRpdGlvbmFsSXRlbXNgO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUoaW5zdGFuY2VbaV0sICRhZGRpdGlvbmFsSXRlbXMsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBgJHtpbnN0YW5jZUxvY2F0aW9ufS8ke2l9YCwga2V5d29yZExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBzaG9ydENpcmN1aXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEl0ZW1zIGRpZCBub3QgbWF0Y2ggYWRkaXRpb25hbCBpdGVtcyBzY2hlbWEuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkY29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiAkbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9jb250YWluc2AsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQXJyYXkgaXMgZW1wdHkuIEl0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgaXRlbSBtYXRjaGluZyB0aGUgc2NoZW1hLmAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkbWluQ29udGFpbnMgIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPCAkbWluQ29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWluQ29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vbWluQ29udGFpbnNgLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEFycmF5IGhhcyBsZXNzIGl0ZW1zICgke2xlbmd0aH0pIHRoYW4gbWluQ29udGFpbnMgKCR7JG1pbkNvbnRhaW5zfSkuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmRMb2NhdGlvbiA9IGAke3NjaGVtYUxvY2F0aW9ufS9jb250YWluc2A7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzTGVuZ3RoID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVkID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2pdLCAkY29udGFpbnMsIGRyYWZ0LCBsb29rdXAsIHNob3J0Q2lyY3VpdCwgcmVjdXJzaXZlQW5jaG9yLCBgJHtpbnN0YW5jZUxvY2F0aW9ufS8ke2p9YCwga2V5d29yZExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lZCA+PSAoJG1pbkNvbnRhaW5zIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5sZW5ndGggPSBlcnJvcnNMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAkbWF4Q29udGFpbnMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnNwbGljZShlcnJvcnNMZW5ndGgsIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEFycmF5IGRvZXMgbm90IGNvbnRhaW4gaXRlbSBtYXRjaGluZyBzY2hlbWEuYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCRtaW5Db250YWlucyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lZCA8ICRtaW5Db250YWlucykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJtaW5Db250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vbWluQ29udGFpbnNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBBcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHskbWluQ29udGFpbnN9IGl0ZW1zIG1hdGNoaW5nIHNjaGVtYS4gT25seSAke2NvbnRhaW5lZH0gaXRlbXMgd2VyZSBmb3VuZC5gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJG1heENvbnRhaW5zICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVkID4gJG1heENvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm1heENvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9tYXhDb250YWluc2AsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEFycmF5IG1heSBjb250YWluIGF0IG1vc3QgJHskbWF4Q29udGFpbnN9IGl0ZW1zIG1hdGNoaW5nIHNjaGVtYS4gJHtjb250YWluZWR9IGl0ZW1zIHdlcmUgZm91bmQuYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcCAmJiAkdW5ldmFsdWF0ZWRJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkTG9jYXRpb24gPSBgJHtzY2hlbWFMb2NhdGlvbn0vdW5ldmFsdWF0ZWRJdGVtc2A7XG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKGluc3RhbmNlW2ldLCAkdW5ldmFsdWF0ZWRJdGVtcywgZHJhZnQsIGxvb2t1cCwgc2hvcnRDaXJjdWl0LCByZWN1cnNpdmVBbmNob3IsIGAke2luc3RhbmNlTG9jYXRpb259LyR7aX1gLCBrZXl3b3JkTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwidW5ldmFsdWF0ZWRJdGVtc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBJdGVtcyBkaWQgbm90IG1hdGNoIHVuZXZhbHVhdGVkIGl0ZW1zIHNjaGVtYS5gLFxuICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCR1bmlxdWVJdGVtcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpbnN0YW5jZVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbyA9IHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IGluc3RhbmNlW2tdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibyA9IHR5cGVvZiBiID09PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiIHx8IChhbyAmJiBibyAmJiAoMCwgZGVlcF9jb21wYXJlX3N0cmljdF9qc18xLmRlZXBDb21wYXJlU3RyaWN0KShhLCBiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS91bmlxdWVJdGVtc2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBEdXBsaWNhdGUgaXRlbXMgYXQgaW5kZXhlcyAke2p9IGFuZCAke2t9LmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGRyYWZ0ID09PSBcIjRcIikge1xuICAgICAgICAgICAgaWYgKCRtaW5pbXVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAoKCRleGNsdXNpdmVNaW5pbXVtID09PSB0cnVlICYmIGluc3RhbmNlIDw9ICRtaW5pbXVtKSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA8ICRtaW5pbXVtKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJtaW5pbXVtXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L21pbmltdW1gLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYCR7aW5zdGFuY2V9IGlzIGxlc3MgdGhhbiAkeyRleGNsdXNpdmVNaW5pbXVtID8gXCJvciBlcXVhbCB0byBcIiA6IFwiXCJ9ICR7JG1pbmltdW19LmAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJG1heGltdW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICgoJGV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUgJiYgaW5zdGFuY2UgPj0gJG1heGltdW0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID4gJG1heGltdW0pKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm1heGltdW1cIixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vbWF4aW11bWAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgJHtpbnN0YW5jZX0gaXMgZ3JlYXRlciB0aGFuICR7JGV4Y2x1c2l2ZU1heGltdW0gPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIn0gJHskbWF4aW11bX0uYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgkbWluaW11bSAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlIDwgJG1pbmltdW0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWluaW11bVwiLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9taW5pbXVtYCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGAke2luc3RhbmNlfSBpcyBsZXNzIHRoYW4gJHskbWluaW11bX0uYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkbWF4aW11bSAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlID4gJG1heGltdW0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWF4aW11bVwiLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9tYXhpbXVtYCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGAke2luc3RhbmNlfSBpcyBncmVhdGVyIHRoYW4gJHskbWF4aW11bX0uYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkZXhjbHVzaXZlTWluaW11bSAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlIDw9ICRleGNsdXNpdmVNaW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImV4Y2x1c2l2ZU1pbmltdW1cIixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vZXhjbHVzaXZlTWluaW11bWAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgJHtpbnN0YW5jZX0gaXMgbGVzcyB0aGFuICR7JGV4Y2x1c2l2ZU1pbmltdW19LmAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJGV4Y2x1c2l2ZU1heGltdW0gIT09IHVuZGVmaW5lZCAmJiBpbnN0YW5jZSA+PSAkZXhjbHVzaXZlTWF4aW11bSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJleGNsdXNpdmVNYXhpbXVtXCIsXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L2V4Y2x1c2l2ZU1heGltdW1gLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYCR7aW5zdGFuY2V9IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAkeyRleGNsdXNpdmVNYXhpbXVtfS5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkbXVsdGlwbGVPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBpbnN0YW5jZSAlICRtdWx0aXBsZU9mO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKDAgLSByZW1haW5kZXIpID49IDEuMTkyMDkyOWUtNyAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKCRtdWx0aXBsZU9mIC0gcmVtYWluZGVyKSA+PSAxLjE5MjA5MjllLTcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTG9jYXRpb246IGAke3NjaGVtYUxvY2F0aW9ufS9tdWx0aXBsZU9mYCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGAke2luc3RhbmNlfSBpcyBub3QgYSBtdWx0aXBsZSBvZiAkeyRtdWx0aXBsZU9mfS5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkbWluTGVuZ3RoID09PSB1bmRlZmluZWQgJiYgJG1heExlbmd0aCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogKDAsIHVjczJfbGVuZ3RoX2pzXzEudWNzMmxlbmd0aCkoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoJG1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGxlbmd0aCA8ICRtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vbWluTGVuZ3RoYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYFN0cmluZyBpcyB0b28gc2hvcnQgKCR7bGVuZ3RofSA8ICR7JG1pbkxlbmd0aH0pLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJG1heExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGxlbmd0aCA+ICRtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwibWF4TGVuZ3RoXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vbWF4TGVuZ3RoYCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYFN0cmluZyBpcyB0b28gbG9uZyAoJHtsZW5ndGh9ID4gJHskbWF4TGVuZ3RofSkuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmICFuZXcgUmVnRXhwKCRwYXR0ZXJuKS50ZXN0KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluc3RhbmNlTG9jYXRpb24sXG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgICAgICAgICAgICAga2V5d29yZExvY2F0aW9uOiBgJHtzY2hlbWFMb2NhdGlvbn0vcGF0dGVybmAsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBTdHJpbmcgZG9lcyBub3QgbWF0Y2ggcGF0dGVybi5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRmb3JtYXQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZm9ybWF0X2pzXzEuZmFzdEZvcm1hdFskZm9ybWF0XSAmJlxuICAgICAgICAgICAgIWZvcm1hdF9qc18xLmZhc3RGb3JtYXRbJGZvcm1hdF0oaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VMb2NhdGlvbixcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGtleXdvcmRMb2NhdGlvbjogYCR7c2NoZW1hTG9jYXRpb259L2Zvcm1hdGAsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBTdHJpbmcgZG9lcyBub3QgbWF0Y2ggZm9ybWF0IFwiJHskZm9ybWF0fVwiLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCwgZXJyb3JzIH07XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validator.cjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validator.cjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = void 0;\nconst dereference_js_1 = __webpack_require__(/*! ./dereference.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.cjs\");\nconst validate_js_1 = __webpack_require__(/*! ./validate.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.cjs\");\nclass Validator {\n    constructor(schema, draft = \"2019-09\", shortCircuit = true) {\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"draft\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: draft\n        });\n        Object.defineProperty(this, \"shortCircuit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: shortCircuit\n        });\n        Object.defineProperty(this, \"lookup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.lookup = (0, dereference_js_1.dereference)(schema);\n    }\n    validate(instance) {\n        return (0, validate_js_1.validate)(instance, this.schema, this.draft, this.lookup, this.shortCircuit);\n    }\n    addSchema(schema, id) {\n        if (id) {\n            schema = { ...schema, $id: id };\n        }\n        (0, dereference_js_1.dereference)(schema, this.lookup);\n    }\n}\nexports.Validator = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvQGNmd29ya2VyL2pzb24tc2NoZW1hL3NyYy92YWxpZGF0b3IuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQix5QkFBeUIsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDcEQsc0JBQXNCLG1CQUFPLENBQUMsOEdBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9zcmMvdmFsaWRhdG9yLmNqcz8xOTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWxpZGF0b3IgPSB2b2lkIDA7XG5jb25zdCBkZXJlZmVyZW5jZV9qc18xID0gcmVxdWlyZShcIi4vZGVyZWZlcmVuY2UuY2pzXCIpO1xuY29uc3QgdmFsaWRhdGVfanNfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmNqc1wiKTtcbmNsYXNzIFZhbGlkYXRvciB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBkcmFmdCA9IFwiMjAxOS0wOVwiLCBzaG9ydENpcmN1aXQgPSB0cnVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFmdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZHJhZnRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0Q2lyY3VpdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogc2hvcnRDaXJjdWl0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb29rdXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sb29rdXAgPSAoMCwgZGVyZWZlcmVuY2VfanNfMS5kZXJlZmVyZW5jZSkoc2NoZW1hKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuICgwLCB2YWxpZGF0ZV9qc18xLnZhbGlkYXRlKShpbnN0YW5jZSwgdGhpcy5zY2hlbWEsIHRoaXMuZHJhZnQsIHRoaXMubG9va3VwLCB0aGlzLnNob3J0Q2lyY3VpdCk7XG4gICAgfVxuICAgIGFkZFNjaGVtYShzY2hlbWEsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgc2NoZW1hID0geyAuLi5zY2hlbWEsICRpZDogaWQgfTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgZGVyZWZlcmVuY2VfanNfMS5kZXJlZmVyZW5jZSkoc2NoZW1hLCB0aGlzLmxvb2t1cCk7XG4gICAgfVxufVxuZXhwb3J0cy5WYWxpZGF0b3IgPSBWYWxpZGF0b3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validator.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.cjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncCaller = void 0;\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue = \"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default;\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => (0, p_retry_1.default)(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\nexports.AsyncCaller = AsyncCaller;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcz8yMjMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY0NhbGxlciA9IHZvaWQgMDtcbmNvbnN0IHBfcmV0cnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicC1yZXRyeVwiKSk7XG5jb25zdCBwX3F1ZXVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInAtcXVldWVcIikpO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAyLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikgfHxcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgaWYgKHN0YXR1cyAmJiBTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGVycm9yPy5lcnJvcj8uY29kZSA9PT0gXCJpbnN1ZmZpY2llbnRfcXVvdGFcIikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgICBlcnIubmFtZSA9IFwiSW5zdWZmaWNpZW50UXVvdGFFcnJvclwiO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPVxuICAgICAgICAgICAgcGFyYW1zLm9uRmFpbGVkQXR0ZW1wdCA/PyBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIHBfcXVldWVfMS5kZWZhdWx0ID8gcF9xdWV1ZV8xLmRlZmF1bHQuZGVmYXVsdCA6IHBfcXVldWVfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZSh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+ICgwLCBwX3JldHJ5XzEuZGVmYXVsdCkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogdGhpcy5vbkZhaWxlZEF0dGVtcHQsXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG5leHBvcnRzLkFzeW5jQ2FsbGVyID0gQXN5bmNDYWxsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/callbacks.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracingEnabled = void 0;\nconst env_js_1 = __webpack_require__(/*! ./env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGSMITH_TRACING\",\n        \"LANGCHAIN_TRACING\",\n    ];\n    return !!envVars.find((envVar) => (0, env_js_1.getEnvironmentVariable)(envVar) === \"true\");\n};\nexports.isTracingEnabled = isTracingEnabled;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2NhbGxiYWNrcy5janM/Y2YyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUcmFjaW5nRW5hYmxlZCA9IHZvaWQgMDtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4vZW52LmNqc1wiKTtcbmNvbnN0IGlzVHJhY2luZ0VuYWJsZWQgPSAodHJhY2luZ0VuYWJsZWQpID0+IHtcbiAgICBpZiAodHJhY2luZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJhY2luZ0VuYWJsZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVudlZhcnMgPSBbXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdcIixcbiAgICBdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiAoMCwgZW52X2pzXzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbmV4cG9ydHMuaXNUcmFjaW5nRW5hYmxlZCA9IGlzVHJhY2luZ0VuYWJsZWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/chunk_array.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chunkArray = void 0;\nconst chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n    const chunk = chunks[chunkIndex] || [];\n    // eslint-disable-next-line no-param-reassign\n    chunks[chunkIndex] = chunk.concat([elem]);\n    return chunks;\n}, []);\nexports.chunkArray = chunkArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2h1bmtfYXJyYXkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2NodW5rX2FycmF5LmNqcz8xOTVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaHVua0FycmF5ID0gdm9pZCAwO1xuY29uc3QgY2h1bmtBcnJheSA9IChhcnIsIGNodW5rU2l6ZSkgPT4gYXJyLnJlZHVjZSgoY2h1bmtzLCBlbGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNodW5rSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gY2h1bmtTaXplKTtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tjaHVua0luZGV4XSB8fCBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5jb25jYXQoW2VsZW1dKTtcbiAgICByZXR1cm4gY2h1bmtzO1xufSwgW10pO1xuZXhwb3J0cy5jaHVua0FycmF5ID0gY2h1bmtBcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnvironmentVariable = exports.getRuntimeEnvironment = exports.getEnv = exports.isNode = exports.isDeno = exports.isJsDom = exports.isWebWorker = exports.isBrowser = void 0;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nexports.isBrowser = isBrowser;\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nexports.isWebWorker = isWebWorker;\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" &&\n        (navigator.userAgent.includes(\"Node.js\") ||\n            navigator.userAgent.includes(\"jsdom\")));\nexports.isJsDom = isJsDom;\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\nexports.isDeno = isDeno;\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !(0, exports.isDeno)();\nexports.isNode = isNode;\nconst getEnv = () => {\n    let env;\n    if ((0, exports.isBrowser)()) {\n        env = \"browser\";\n    }\n    else if ((0, exports.isNode)()) {\n        env = \"node\";\n    }\n    else if ((0, exports.isWebWorker)()) {\n        env = \"webworker\";\n    }\n    else if ((0, exports.isJsDom)()) {\n        env = \"jsdom\";\n    }\n    else if ((0, exports.isDeno)()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nexports.getEnv = getEnv;\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = (0, exports.getEnv)();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nexports.getRuntimeEnvironment = getRuntimeEnvironment;\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nexports.getEnvironmentVariable = getEnvironmentVariable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQzdLO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Vudi5janM/MTk3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGV4cG9ydHMuZ2V0UnVudGltZUVudmlyb25tZW50ID0gZXhwb3J0cy5nZXRFbnYgPSBleHBvcnRzLmlzTm9kZSA9IGV4cG9ydHMuaXNEZW5vID0gZXhwb3J0cy5pc0pzRG9tID0gZXhwb3J0cy5pc1dlYldvcmtlciA9IGV4cG9ydHMuaXNCcm93c2VyID0gdm9pZCAwO1xuY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5jb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0cy5pc1dlYldvcmtlciA9IGlzV2ViV29ya2VyO1xuY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG5leHBvcnRzLmlzSnNEb20gPSBpc0pzRG9tO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLmlzRGVubyA9IGlzRGVubztcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhKDAsIGV4cG9ydHMuaXNEZW5vKSgpO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5jb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgbGV0IGVudjtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgIGVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZXhwb3J0cy5pc05vZGUpKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzV2ViV29ya2VyKSgpKSB7XG4gICAgICAgIGVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzSnNEb20pKCkpIHtcbiAgICAgICAgZW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZXhwb3J0cy5pc0Rlbm8pKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xuZXhwb3J0cy5nZXRFbnYgPSBnZXRFbnY7XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSAoMCwgZXhwb3J0cy5nZXRFbnYpKCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ2NoYWluLWpzXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG5leHBvcnRzLmdldFJ1bnRpbWVFbnZpcm9ubWVudCA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudDtcbmZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGdldEVudmlyb25tZW50VmFyaWFibGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/event_source_parse.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertEventStreamToIterableReadableDataStream = exports.getMessages = exports.getLines = exports.getBytes = exports.EventStreamContentType = void 0;\n/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nconst stream_js_1 = __webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nexports.EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nstream, onChunk) {\n    // TODO: Use Async iteration for both cases?\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (stream instanceof ReadableStream) {\n        const reader = stream.getReader();\n        // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n        //          This change is essential to ensure that we capture every last piece of information from streams,\n        //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n        //          mechanism, we risk ignoring a possibly significant last message.\n        //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                onChunk(new Uint8Array(), true);\n                break;\n            }\n            onChunk(result.value);\n        }\n    }\n    else {\n        try {\n            // Handle Node.js Readable streams with async iteration\n            for await (const chunk of stream) {\n                onChunk(new Uint8Array(chunk));\n            }\n            onChunk(new Uint8Array(), true);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new Error([\n                \"Parsing event source stream failed.\",\n                \"Ensure your implementation of fetch returns a web or Node readable stream.\",\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n}\nexports.getBytes = getBytes;\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr, flush) {\n        if (flush) {\n            onLine(arr, 0, true);\n            return;\n        }\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\nexports.getLines = getLines;\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength, flush) {\n        if (flush) {\n            if (!isEmpty(message)) {\n                onMessage?.(message);\n                message = newMessage();\n            }\n            return;\n        }\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nexports.getMessages = getMessages;\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\nfunction convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {\n    const dataStream = new ReadableStream({\n        async start(controller) {\n            const enqueueLine = getMessages((msg) => {\n                if (msg.event === \"error\") {\n                    throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n                }\n                else if (msg.event === \"metadata\") {\n                    onMetadataEvent?.(msg);\n                }\n                else {\n                    if (msg.data)\n                        controller.enqueue(msg.data);\n                }\n            });\n            const onLine = (line, fieldLength, flush) => {\n                enqueueLine(line, fieldLength, flush);\n                if (flush)\n                    controller.close();\n            };\n            await getBytes(stream, getLines(onLine));\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(dataStream);\n}\nexports.convertEventStreamToIterableReadableDataStream = convertEventStreamToIterableReadableDataStream;\nfunction isEmpty(message) {\n    return (message.data === \"\" &&\n        message.event === \"\" &&\n        message.id === \"\" &&\n        message.retry === undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZXZlbnRfc291cmNlX3BhcnNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzREFBc0QsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyw4QkFBOEI7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWM7QUFDMUMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZXZlbnRfc291cmNlX3BhcnNlLmNqcz83YzY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtID0gZXhwb3J0cy5nZXRNZXNzYWdlcyA9IGV4cG9ydHMuZ2V0TGluZXMgPSBleHBvcnRzLmdldEJ5dGVzID0gZXhwb3J0cy5FdmVudFN0cmVhbUNvbnRlbnRUeXBlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXRlbXBsYXRlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBkZWZhdWx0LWNhc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dmb3J0YWluZS9mZXRjaC1ldmVudC1zb3VyY2UvYmxvYi9tYWluL3NyYy9wYXJzZS50c1xuLy8gZHVlIHRvIGEgcGFja2FnaW5nIGlzc3VlIGluIHRoZSBvcmlnaW5hbC5cbi8vIE1JVCBMaWNlbnNlXG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS5janNcIik7XG5leHBvcnRzLkV2ZW50U3RyZWFtQ29udGVudFR5cGUgPSBcInRleHQvZXZlbnQtc3RyZWFtXCI7XG4vKipcbiAqIENvbnZlcnRzIGEgUmVhZGFibGVTdHJlYW0gaW50byBhIGNhbGxiYWNrIHBhdHRlcm4uXG4gKiBAcGFyYW0gc3RyZWFtIFRoZSBpbnB1dCBSZWFkYWJsZVN0cmVhbS5cbiAqIEBwYXJhbSBvbkNodW5rIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIG5ldyBieXRlIGNodW5rIGluIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBzdHJlYW0gY2xvc2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRCeXRlcyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5zdHJlYW0sIG9uQ2h1bmspIHtcbiAgICAvLyBUT0RPOiBVc2UgQXN5bmMgaXRlcmF0aW9uIGZvciBib3RoIGNhc2VzP1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAvLyBDSEFOR0VEOiBJbnRyb2R1Y2VkIGEgXCJmbHVzaFwiIG1lY2hhbmlzbSB0byBwcm9jZXNzIHBvdGVudGlhbCBwZW5kaW5nIG1lc3NhZ2VzIHdoZW4gdGhlIHN0cmVhbSBlbmRzLlxuICAgICAgICAvLyAgICAgICAgICBUaGlzIGNoYW5nZSBpcyBlc3NlbnRpYWwgdG8gZW5zdXJlIHRoYXQgd2UgY2FwdHVyZSBldmVyeSBsYXN0IHBpZWNlIG9mIGluZm9ybWF0aW9uIGZyb20gc3RyZWFtcyxcbiAgICAgICAgLy8gICAgICAgICAgc3VjaCBhcyB0aG9zZSBmcm9tIEF6dXJlIE9wZW5BSSwgd2hpY2ggbWF5IG5vdCB0ZXJtaW5hdGUgd2l0aCBhIGJsYW5rIGxpbmUuIFdpdGhvdXQgdGhpc1xuICAgICAgICAvLyAgICAgICAgICBtZWNoYW5pc20sIHdlIHJpc2sgaWdub3JpbmcgYSBwb3NzaWJseSBzaWduaWZpY2FudCBsYXN0IG1lc3NhZ2UuXG4gICAgICAgIC8vICAgICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL2lzc3Vlcy8xMjk5IGZvciBkZXRhaWxzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheSgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2h1bmsocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBOb2RlLmpzIFJlYWRhYmxlIHN0cmVhbXMgd2l0aCBhc3luYyBpdGVyYXRpb25cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheShjaHVuaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheSgpLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICAgICAgXCJQYXJzaW5nIGV2ZW50IHNvdXJjZSBzdHJlYW0gZmFpbGVkLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHlvdXIgaW1wbGVtZW50YXRpb24gb2YgZmV0Y2ggcmV0dXJucyBhIHdlYiBvciBOb2RlIHJlYWRhYmxlIHN0cmVhbS5cIixcbiAgICAgICAgICAgICAgICBgRXJyb3I6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5nZXRCeXRlcyA9IGdldEJ5dGVzO1xuLyoqXG4gKiBQYXJzZXMgYXJiaXRhcnkgYnl0ZSBjaHVua3MgaW50byBFdmVudFNvdXJjZSBsaW5lIGJ1ZmZlcnMuXG4gKiBFYWNoIGxpbmUgc2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgXCJmaWVsZDogdmFsdWVcIiBhbmQgZW5kcyB3aXRoIFxcciwgXFxuLCBvciBcXHJcXG4uXG4gKiBAcGFyYW0gb25MaW5lIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIG5ldyBFdmVudFNvdXJjZSBsaW5lLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgZm9yIGVhY2ggaW5jb21pbmcgYnl0ZSBjaHVuay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXMob25MaW5lKSB7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBsZXQgcG9zaXRpb247IC8vIGN1cnJlbnQgcmVhZCBwb3NpdGlvblxuICAgIGxldCBmaWVsZExlbmd0aDsgLy8gbGVuZ3RoIG9mIHRoZSBgZmllbGRgIHBvcnRpb24gb2YgdGhlIGxpbmVcbiAgICBsZXQgZGlzY2FyZFRyYWlsaW5nTmV3bGluZSA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIHByb2Nlc3MgZWFjaCBpbmNvbWluZyBieXRlIGNodW5rOlxuICAgIHJldHVybiBmdW5jdGlvbiBvbkNodW5rKGFyciwgZmx1c2gpIHtcbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICBvbkxpbmUoYXJyLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGFycjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBzdGlsbCBwYXJzaW5nIHRoZSBvbGQgbGluZS4gQXBwZW5kIHRoZSBuZXcgYnl0ZXMgaW50byBidWZmZXI6XG4gICAgICAgICAgICBidWZmZXIgPSBjb25jYXQoYnVmZmVyLCBhcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Zkxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSAwOyAvLyBpbmRleCB3aGVyZSB0aGUgY3VycmVudCBsaW5lIHN0YXJ0c1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBidWZMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaXNjYXJkVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcltwb3NpdGlvbl0gPT09IDEwIC8qIENvbnRyb2xDaGFycy5OZXdMaW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9ICsrcG9zaXRpb247IC8vIHNraXAgdG8gbmV4dCBjaGFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0YXJ0IGxvb2tpbmcgZm9yd2FyZCB0aWxsIHRoZSBlbmQgb2YgbGluZTpcbiAgICAgICAgICAgIGxldCBsaW5lRW5kID0gLTE7IC8vIGluZGV4IG9mIHRoZSBcXHIgb3IgXFxuIGNoYXJcbiAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGJ1Zkxlbmd0aCAmJiBsaW5lRW5kID09PSAtMTsgKytwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyW3Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU4IC8qIENvbnRyb2xDaGFycy5Db2xvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjb2xvbiBpbiBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRMZW5ndGggPSBwb3NpdGlvbiAtIGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6NzAyOSBcXHIgY2FzZSBiZWxvdyBzaG91bGQgZmFsbHRocm91Z2ggdG8gXFxuOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIENvbnRyb2xDaGFycy5DYXJyaWFnZVJldHVybiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBDb250cm9sQ2hhcnMuTmV3TGluZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbmQgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lRW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGJ1dCB0aGUgbGluZSBoYXNuJ3QgZW5kZWQuXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIG5leHQgYXJyIGFuZCB0aGVuIGNvbnRpbnVlIHBhcnNpbmc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSd2ZSByZWFjaGVkIHRoZSBsaW5lIGVuZCwgc2VuZCBpdCBvdXQ6XG4gICAgICAgICAgICBvbkxpbmUoYnVmZmVyLnN1YmFycmF5KGxpbmVTdGFydCwgbGluZUVuZCksIGZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IHBvc2l0aW9uOyAvLyB3ZSdyZSBub3cgb24gdGhlIG5leHQgbGluZVxuICAgICAgICAgICAgZmllbGRMZW5ndGggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVN0YXJ0ID09PSBidWZMZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDsgLy8gd2UndmUgZmluaXNoZWQgcmVhZGluZyBpdFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZpZXcgaW50byBidWZmZXIgYmVnaW5uaW5nIGF0IGxpbmVTdGFydCBzbyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb3B5IG92ZXIgdGhlIHByZXZpb3VzIGxpbmVzIHdoZW4gd2UgZ2V0IHRoZSBuZXcgYXJyOlxuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KGxpbmVTdGFydCk7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSBsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5nZXRMaW5lcyA9IGdldExpbmVzO1xuLyoqXG4gKiBQYXJzZXMgbGluZSBidWZmZXJzIGludG8gRXZlbnRTb3VyY2VNZXNzYWdlcy5cbiAqIEBwYXJhbSBvbklkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGBpZGAgZmllbGQuXG4gKiBAcGFyYW0gb25SZXRyeSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBgcmV0cnlgIGZpZWxkLlxuICogQHBhcmFtIG9uTWVzc2FnZSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBtZXNzYWdlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgZm9yIGVhY2ggaW5jb21pbmcgbGluZSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzKG9uTWVzc2FnZSwgb25JZCwgb25SZXRyeSkge1xuICAgIGxldCBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBwcm9jZXNzIGVhY2ggaW5jb21pbmcgbGluZSBidWZmZXI6XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTGluZShsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpIHtcbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2U/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBkZW5vdGVzIGVuZCBvZiBtZXNzYWdlLiBUcmlnZ2VyIHRoZSBjYWxsYmFjayBhbmQgc3RhcnQgYSBuZXcgbWVzc2FnZTpcbiAgICAgICAgICAgIG9uTWVzc2FnZT8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG5ld01lc3NhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGV4Y2x1ZGUgY29tbWVudHMgYW5kIGxpbmVzIHdpdGggbm8gdmFsdWVzXG4gICAgICAgICAgICAvLyBsaW5lIGlzIG9mIGZvcm1hdCBcIjxmaWVsZD46PHZhbHVlPlwiIG9yIFwiPGZpZWxkPjogPHZhbHVlPlwiXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNldmVudC1zdHJlYW0taW50ZXJwcmV0YXRpb25cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSgwLCBmaWVsZExlbmd0aCkpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBmaWVsZExlbmd0aCArIChsaW5lW2ZpZWxkTGVuZ3RoICsgMV0gPT09IDMyIC8qIENvbnRyb2xDaGFycy5TcGFjZSAqLyA/IDIgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSh2YWx1ZU9mZnNldCkpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbWVzc2FnZSBhbHJlYWR5IGhhcyBkYXRhLCBhcHBlbmQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgb2xkLlxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3Qgc2V0IHRvIHRoZSBuZXcgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YSA/IG1lc3NhZ2UuZGF0YSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlOyAvLyBvdGhlcndpc2UsXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgICAgICAgICAgICBvbklkPy4oKG1lc3NhZ2UuaWQgPSB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmV0cnlcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHNwZWMsIGlnbm9yZSBub24taW50ZWdlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmV0cnk/LigobWVzc2FnZS5yZXRyeSA9IHJldHJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0TWVzc2FnZXMgPSBnZXRNZXNzYWdlcztcbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgcmVzLnNldChhKTtcbiAgICByZXMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbmV3TWVzc2FnZSgpIHtcbiAgICAvLyBkYXRhLCBldmVudCwgYW5kIGlkIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gZW1wdHkgc3RyaW5nczpcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNldmVudC1zdHJlYW0taW50ZXJwcmV0YXRpb25cbiAgICAvLyByZXRyeSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIHNvIHdlIHJldHVybiBhIGNvbnNpc3RlbnQgc2hhcGVcbiAgICAvLyB0byB0aGUganMgZW5naW5lIGFsbCB0aGUgdGltZTogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL3NoYXBlcy1pY3MjdGFrZWF3YXlzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogXCJcIixcbiAgICAgICAgZXZlbnQ6IFwiXCIsXG4gICAgICAgIGlkOiBcIlwiLFxuICAgICAgICByZXRyeTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtKHN0cmVhbSwgb25NZXRhZGF0YUV2ZW50KSB7XG4gICAgY29uc3QgZGF0YVN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVucXVldWVMaW5lID0gZ2V0TWVzc2FnZXMoKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuZXZlbnQgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnLmRhdGEgPz8gXCJVbnNwZWNpZmllZCBldmVudCBzdHJlYW1pbmcgZXJyb3IuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtc2cuZXZlbnQgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgICAgICBvbk1ldGFkYXRhRXZlbnQ/Lihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9uTGluZSA9IChsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpID0+IHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlTGluZShsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpO1xuICAgICAgICAgICAgICAgIGlmIChmbHVzaClcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGdldEJ5dGVzKHN0cmVhbSwgZ2V0TGluZXMob25MaW5lKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKGRhdGFTdHJlYW0pO1xufVxuZXhwb3J0cy5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtID0gY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbTtcbmZ1bmN0aW9uIGlzRW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiAobWVzc2FnZS5kYXRhID09PSBcIlwiICYmXG4gICAgICAgIG1lc3NhZ2UuZXZlbnQgPT09IFwiXCIgJiZcbiAgICAgICAgbWVzc2FnZS5pZCA9PT0gXCJcIiAmJlxuICAgICAgICBtZXNzYWdlLnJldHJ5ID09PSB1bmRlZmluZWQpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescapePathComponent = exports.escapePathComponent = exports.deepClone = exports.JsonPatchError = void 0;\n__exportStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./src/duplex.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\"), exports);\nvar helpers_js_1 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nObject.defineProperty(exports, \"JsonPatchError\", ({ enumerable: true, get: function () { return helpers_js_1.PatchError; } }));\nObject.defineProperty(exports, \"deepClone\", ({ enumerable: true, get: function () { return helpers_js_1._deepClone; } }));\nObject.defineProperty(exports, \"escapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.escapePathComponent; } }));\nObject.defineProperty(exports, \"unescapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.unescapePathComponent; } }));\n/**\n * Default export for backwards compat\n */\nconst core = __importStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"));\nconst helpers_js_2 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports[\"default\"] = {\n    ...core,\n    // ...duplex,\n    JsonPatchError: helpers_js_2.PatchError,\n    deepClone: helpers_js_2._deepClone,\n    escapePathComponent: helpers_js_2.escapePathComponent,\n    unescapePathComponent: helpers_js_2.unescapePathComponent,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCO0FBQ3hHLGFBQWEsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHdHQUFrQjtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDOUMsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILDZDQUE0QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN2SCx1REFBc0QsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDMUkseURBQXdELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLG9HQUFnQjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDaEQsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguY2pzPzU4ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IGV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGV4cG9ydHMuZGVlcENsb25lID0gZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvY29yZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9kdXBsZXguY2pzXCIpLCBleHBvcnRzKTtcbnZhciBoZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9zcmMvaGVscGVycy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUGF0Y2hFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGVscGVyc19qc18xLlBhdGNoRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWVwQ2xvbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlbHBlcnNfanNfMS5fZGVlcENsb25lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlUGF0aENvbXBvbmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmVzY2FwZVBhdGhDb21wb25lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlbHBlcnNfanNfMS51bmVzY2FwZVBhdGhDb21wb25lbnQ7IH0gfSk7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmNvbnN0IGNvcmUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2NvcmUuY2pzXCIpKTtcbmNvbnN0IGhlbHBlcnNfanNfMiA9IHJlcXVpcmUoXCIuL3NyYy9oZWxwZXJzLmNqc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAuLi5jb3JlLFxuICAgIC8vIC4uLmR1cGxleCxcbiAgICBKc29uUGF0Y2hFcnJvcjogaGVscGVyc19qc18yLlBhdGNoRXJyb3IsXG4gICAgZGVlcENsb25lOiBoZWxwZXJzX2pzXzIuX2RlZXBDbG9uZSxcbiAgICBlc2NhcGVQYXRoQ29tcG9uZW50OiBoZWxwZXJzX2pzXzIuZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQ6IGhlbHBlcnNfanNfMi51bmVzY2FwZVBhdGhDb21wb25lbnQsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._areEquals = exports.validate = exports.validator = exports.applyReducer = exports.applyPatch = exports.applyOperation = exports.getValueByPointer = exports.deepClone = exports.JsonPatchError = void 0;\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports.JsonPatchError = helpers_js_1.PatchError;\nexports.deepClone = helpers_js_1._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0, helpers_js_1._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0, helpers_js_1._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0, helpers_js_1.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\nexports.getValueByPointer = getValueByPointer;\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0, helpers_js_1._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0, helpers_js_1.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0, helpers_js_1.isInteger)(key)) {\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0, helpers_js_1.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new exports.JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\nexports.applyOperation = applyOperation;\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0, helpers_js_1._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\nexports.applyPatch = applyPatch;\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\nexports.applyReducer = applyReducer;\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new exports.JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0, helpers_js_1.hasUndefined)(operation.value)) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new exports.JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new exports.JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new exports.JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\nexports.validator = validator;\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0, helpers_js_1._deepClone)(document), (0, helpers_js_1._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof exports.JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\nexports.validate = validate;\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nexports._areEquals = _areEquals;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQjtBQUN2TSxxQkFBcUIsbUJBQU8sQ0FBQyxzR0FBZTtBQUM1QyxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmNqcz8yNjgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLW5vY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2FyZUVxdWFscyA9IGV4cG9ydHMudmFsaWRhdGUgPSBleHBvcnRzLnZhbGlkYXRvciA9IGV4cG9ydHMuYXBwbHlSZWR1Y2VyID0gZXhwb3J0cy5hcHBseVBhdGNoID0gZXhwb3J0cy5hcHBseU9wZXJhdGlvbiA9IGV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBleHBvcnRzLmRlZXBDbG9uZSA9IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBoZWxwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmNqc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzX2pzXzEuUGF0Y2hFcnJvcjtcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbmNvbnN0IG9iak9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICAvKiBpbiBjYXNlIG1vdmUgdGFyZ2V0IG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xuICAgICAgICBsZXQgcmVtb3ZlZCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLnBhdGgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkocmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7XG4gICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuZnJvbSxcbiAgICAgICAgfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIGNvcHk6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgdmFsdWU6ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkodmFsdWVUb0NvcHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxufTtcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXG52YXIgYXJyT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaXNJbnRlZ2VyKShpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFycmF5IHByb3BzXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZExpc3RbMF0gfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gYXJyW2ldO1xuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxuICAgIHRlc3Q6IG9iak9wcy50ZXN0LFxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0LFxufTtcbi8qKlxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICogQHBhcmFtIHBvaW50ZXIgYW4gZXNjYXBlZCBKU09OIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuZXhwb3J0cy5nZXRWYWx1ZUJ5UG9pbnRlciA9IGdldFZhbHVlQnlQb2ludGVyO1xuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uLCB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlLCBtdXRhdGVEb2N1bWVudCA9IHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlLCBpbmRleCA9IDApIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIG9wZXJhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihvcGVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcImFkZFwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgbW92ZSBvciBjb3B5IHRvIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCByZW1vdmVkIGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IF9hcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgICAgLy8gYSByZW1vdmUgb24gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJfZ2V0XCIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogYmFkIG9wZXJhdGlvbiAqL1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSAoMCwgaGVscGVyc19qc18xLnVuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhKDAsIGhlbHBlcnNfanNfMS5pc0ludGVnZXIpKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaXNJbnRlZ2VyKShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXJyT3BzW29wZXJhdGlvbi5vcF0uY2FsbChvcGVyYXRpb24sIG9iaiwga2V5LCBkb2N1bWVudCk7IC8vIEFwcGx5IHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIGtleXMgaW4gdGhlIHBhdGgsIGJ1dCB0aGUgbmV4dCB2YWx1ZSBpc24ndCBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIE9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRSBlcnJvciBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiB0IDwgbGVuICYmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gYXBwbHlPcGVyYXRpb247XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKGRvY3VtZW50KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBwYXRjaC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbXV0YXRlRG9jdW1lbnQgYXJndW1lbnQgYmVjYXVzZSBpZiBpdCB3YXMgdHJ1ZSwgd2UgYWxyZWFkeSBkZWVwIGNsb25lZCB0aGUgb2JqZWN0LCB3ZSdsbCBqdXN0IHBhc3MgYHRydWVgXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uLCB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpKTtcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXG4gICAgfVxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uLCBpbmRleCkge1xuICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdCA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24pO1xuICAgIGlmIChvcGVyYXRpb25SZXN1bHQudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZmFpbGVkIHRlc3RcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBhcHBseVJlZHVjZXI7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgb3BlcmF0aW9uID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0XCIsIFwiT1BFUkFUSU9OX05PVF9BTl9PQkpFQ1RcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmdcIiwgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZihcIi9cIikgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgXCJPUEVSQVRJT05fUEFUSF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikgJiZcbiAgICAgICAgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgICgwLCBoZWxwZXJzX2pzXzEuaGFzVW5kZWZpbmVkKShvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuICsgMSAmJiBwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0ge1xuICAgICAgICAgICAgICAgIG9wOiBcIl9nZXRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBvcGVyYXRpb24uZnJvbSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlKFtleGlzdGluZ1ZhbHVlXSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoc2VxdWVuY2UsIGRvY3VtZW50LCBleHRlcm5hbFZhbGlkYXRvcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaCgoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKGRvY3VtZW50KSwgKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShzZXF1ZW5jZSksIGV4dGVybmFsVmFsaWRhdG9yIHx8IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3IgPSBleHRlcm5hbFZhbGlkYXRvciB8fCB2YWxpZGF0b3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3Ioc2VxdWVuY2VbaV0sIGksIGRvY3VtZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5mdW5jdGlvbiBfYXJlRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGFyckEgPSBBcnJheS5pc0FycmF5KGEpLCBhcnJCID0gQXJyYXkuaXNBcnJheShiKSwgaSwgbGVuZ3RoLCBrZXk7XG4gICAgICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyQSAhPSBhcnJCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cbmV4cG9ydHMuX2FyZUVxdWFscyA9IF9hcmVFcXVhbHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compare = exports.generate = exports.observe = exports.unobserve = void 0;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nconst core_js_1 = __webpack_require__(/*! ./core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\");\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\nexports.unobserve = unobserve;\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0, helpers_js_1._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\nexports.observe = observe;\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0, core_js_1.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\nexports.generate = generate;\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0, helpers_js_1._objectKeys)(obj);\n    var oldKeys = (0, helpers_js_1._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0, helpers_js_1.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0, helpers_js_1.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                            value: (0, helpers_js_1._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                        value: (0, helpers_js_1._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                    value: (0, helpers_js_1._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0, helpers_js_1.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                value: (0, helpers_js_1._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\nexports.compare = compare;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsc0dBQWU7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsZ0dBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2R1cGxleC5janM/ZDI3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1ub2NoZWNrXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBhcmUgPSBleHBvcnRzLmdlbmVyYXRlID0gZXhwb3J0cy5vYnNlcnZlID0gZXhwb3J0cy51bm9ic2VydmUgPSB2b2lkIDA7XG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTMtMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuY29uc3QgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vaGVscGVycy5janNcIik7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmNqc1wiKTtcbnZhciBiZWZvcmVEaWN0ID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIE1pcnJvciB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ialwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYnNlcnZlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxufVxuY2xhc3MgT2JzZXJ2ZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbmV4cG9ydHMudW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xuICAgIGlmICghbWlycm9yKSB7XG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcbiAgICAgICAgYmVmb3JlRGljdC5zZXQob2JqLCBtaXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJJbmZvID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlciA9IG9ic2VydmVySW5mbyAmJiBvYnNlcnZlckluZm8ub2JzZXJ2ZXI7XG4gICAgfVxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIG9ic2VydmVyID0ge307XG4gICAgbWlycm9yLnZhbHVlID0gKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShvYmopO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcnR5Q2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYXN0Q2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vbm90IE5vZGVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlci5wYXRjaGVzID0gcGF0Y2hlcztcbiAgICBvYnNlcnZlci5vYmplY3QgPSBvYmo7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlID0gKCkgPT4ge1xuICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLnNldChjYWxsYmFjaywgbmV3IE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpKTtcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gYW4gb2JzZXJ2ZXJcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUob2JzZXJ2ZXIsIGludmVydGlibGUgPSBmYWxzZSkge1xuICAgIHZhciBtaXJyb3IgPSBiZWZvcmVEaWN0LmdldChvYnNlcnZlci5vYmplY3QpO1xuICAgIF9nZW5lcmF0ZShtaXJyb3IudmFsdWUsIG9ic2VydmVyLm9iamVjdCwgb2JzZXJ2ZXIucGF0Y2hlcywgXCJcIiwgaW52ZXJ0aWJsZSk7XG4gICAgaWYgKG9ic2VydmVyLnBhdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICgwLCBjb3JlX2pzXzEuYXBwbHlQYXRjaCkobWlycm9yLnZhbHVlLCBvYnNlcnZlci5wYXRjaGVzKTtcbiAgICB9XG4gICAgdmFyIHRlbXAgPSBvYnNlcnZlci5wYXRjaGVzO1xuICAgIGlmICh0ZW1wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHRlbXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wO1xufVxuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuLy8gRGlydHkgY2hlY2sgaWYgb2JqIGlzIGRpZmZlcmVudCBmcm9tIG1pcnJvciwgZ2VuZXJhdGUgcGF0Y2hlcyBhbmQgdXBkYXRlIG1pcnJvclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKG9iaiA9PT0gbWlycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICB2YXIgbmV3S2V5cyA9ICgwLCBoZWxwZXJzX2pzXzEuX29iamVjdEtleXMpKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSAoMCwgaGVscGVyc19qc18xLl9vYmplY3RLZXlzKShtaXJyb3IpO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAvL2lmIGV2ZXIgXCJtb3ZlXCIgb3BlcmF0aW9uIGlzIGltcGxlbWVudGVkIGhlcmUsIG1ha2Ugc3VyZSB0aGlzIHRlc3QgcnVucyBPSzogXCJzaG91bGQgbm90IGdlbmVyYXRlIHRoZSBzYW1lIHBhdGNoIHR3aWNlIChtb3ZlKVwiXG4gICAgZm9yICh2YXIgdCA9IG9sZEtleXMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9sZEtleXNbdF07XG4gICAgICAgIHZhciBvbGRWYWwgPSBtaXJyb3Jba2V5XTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaGFzT3duUHJvcGVydHkpKG9iaiwga2V5KSAmJlxuICAgICAgICAgICAgIShvYmpba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2xkVmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5ld1ZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgbmV3VmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9sZFZhbCkgPT09IEFycmF5LmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIF9nZW5lcmF0ZShvbGRWYWwsIG5ld1ZhbCwgcGF0Y2hlcywgcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLCBpbnZlcnRpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShvbGRWYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG5ld1ZhbCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJ0ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkob2xkVmFsKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghKDAsIGhlbHBlcnNfanNfMS5oYXNPd25Qcm9wZXJ0eSkobWlycm9yLCBrZXkpICYmIG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG9ialtrZXldKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIHRoZSBkaWZmZXJlbmNlcyBpbiB0d28gb2JqZWN0c1xuICovXG5mdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMiwgaW52ZXJ0aWJsZSA9IGZhbHNlKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbn1cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchError = exports.hasUndefined = exports.getPath = exports._getPathRecursive = exports.unescapePathComponent = exports.escapePathComponent = exports.isInteger = exports._deepClone = exports._objectKeys = exports.hasOwnProperty = void 0;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nexports.hasOwnProperty = hasOwnProperty;\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\nexports._objectKeys = _objectKeys;\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\nexports._deepClone = _deepClone;\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nexports.isInteger = isInteger;\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapePathComponent = escapePathComponent;\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapePathComponent = unescapePathComponent;\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nexports._getPathRecursive = _getPathRecursive;\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\nexports.getPath = getPath;\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nexports.hasUndefined = hasUndefined;\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\nexports.PatchError = PatchError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxzQkFBc0I7QUFDN087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQ0FBaUMsSUFBSSxJQUFJLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhCQUE4QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmNqcz84M2M3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLW5vY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0Y2hFcnJvciA9IGV4cG9ydHMuaGFzVW5kZWZpbmVkID0gZXhwb3J0cy5nZXRQYXRoID0gZXhwb3J0cy5fZ2V0UGF0aFJlY3Vyc2l2ZSA9IGV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXhwb3J0cy5pc0ludGVnZXIgPSBleHBvcnRzLl9kZWVwQ2xvbmUgPSBleHBvcnRzLl9vYmplY3RLZXlzID0gZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eSA9IHZvaWQgMDtcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIyIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZWRcbiAqL1xuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmV4cG9ydHMuaGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xuLyoqXG4gKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cbiAqIGh0dHBzOi8vanNwZXJmLmNvbS9kZWVwLWNvcHktdnMtanNvbi1zdHJpbmdpZnktanNvbi1wYXJzZS8yNSAocmVjdXJzaXZlRGVlcENvcHkpXG4gKiBAcGFyYW0gIHthbnl9IG9iaiB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXG4gKi9cbmZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuZXhwb3J0cy5fZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8vM3ggZmFzdGVyIHRoYW4gY2FjaGVkIC9eXFxkKyQvLnRlc3Qoc3RyKVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbi8qKlxuICogRXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcbiAqIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxuICovXG5mdW5jdGlvbiBlc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKFwiflwiKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGVzY2FwZVBhdGhDb21wb25lbnQ7XG4vKipcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IHVuZXNjYXBlUGF0aENvbXBvbmVudDtcbmZ1bmN0aW9uIF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaikge1xuICAgIGxldCBmb3VuZDtcbiAgICBmb3IgKGxldCBrZXkgaW4gcm9vdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkocm9vdCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKHJvb3Rba2V5XSA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArIFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIiArIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmV4cG9ydHMuX2dldFBhdGhSZWN1cnNpdmUgPSBfZ2V0UGF0aFJlY3Vyc2l2ZTtcbmZ1bmN0aW9uIGdldFBhdGgocm9vdCwgb2JqKSB7XG4gICAgaWYgKHJvb3QgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xuICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBub3QgZm91bmQgaW4gcm9vdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAvJHtwYXRofWA7XG59XG5leHBvcnRzLmdldFBhdGggPSBnZXRQYXRoO1xuLyoqXG4gKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cbiAqL1xuZnVuY3Rpb24gaGFzVW5kZWZpbmVkKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXNMZW5ndGggPSBvYmpLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmhhc1VuZGVmaW5lZCA9IGhhc1VuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbbWVzc2FnZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbihcIlxcblwiKTtcbn1cbmNsYXNzIFBhdGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSkge1xuICAgICAgICBzdXBlcihwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7IG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmRleFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wZXJhdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cmVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpOyAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpbiwgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODM0MjM1OVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGNoRXJyb3IgPSBQYXRjaEVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/function_calling.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLangChainTool = exports.isStructuredToolParams = exports.isRunnableToolLike = exports.isStructuredTool = exports.convertToOpenAITool = exports.convertToOpenAIFunction = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst is_zod_schema_js_1 = __webpack_require__(/*! ./types/is_zod_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs\");\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. It uses the `zodToJsonSchema`\n * function to convert the schema of the `StructuredTool` or `RunnableToolLike`\n * into a JSON schema, which is then used as the parameters for the OpenAI function.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nfunction convertToOpenAIFunction(tool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    return {\n        name: tool.name,\n        description: tool.description,\n        parameters: (0, zod_to_json_schema_1.zodToJsonSchema)(tool.schema),\n        // Do not include the `strict` field if it is `undefined`.\n        ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n    };\n}\nexports.convertToOpenAIFunction = convertToOpenAIFunction;\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. It uses the\n * `zodToJsonSchema` function to convert the schema of the `StructuredTool`\n * or `RunnableToolLike` into a JSON schema, which is then used as the\n * parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nfunction convertToOpenAITool(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    let toolDef;\n    if (isLangChainTool(tool)) {\n        toolDef = {\n            type: \"function\",\n            function: convertToOpenAIFunction(tool),\n        };\n    }\n    else {\n        toolDef = tool;\n    }\n    if (fieldsCopy?.strict !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        toolDef.function.strict = fieldsCopy.strict;\n    }\n    return toolDef;\n}\nexports.convertToOpenAITool = convertToOpenAITool;\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | Record<string, any> | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nfunction isStructuredTool(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntool) {\n    return (tool !== undefined &&\n        Array.isArray(tool.lc_namespace));\n}\nexports.isStructuredTool = isStructuredTool;\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nfunction isRunnableToolLike(tool) {\n    return (tool !== undefined &&\n        base_js_1.Runnable.isRunnable(tool) &&\n        \"lc_name\" in tool.constructor &&\n        typeof tool.constructor.lc_name === \"function\" &&\n        tool.constructor.lc_name() === \"RunnableToolLike\");\n}\nexports.isRunnableToolLike = isRunnableToolLike;\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nfunction isStructuredToolParams(tool) {\n    return (!!tool &&\n        typeof tool === \"object\" &&\n        \"name\" in tool &&\n        \"schema\" in tool &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (0, is_zod_schema_js_1.isZodSchema)(tool.schema));\n}\nexports.isStructuredToolParams = isStructuredToolParams;\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nfunction isLangChainTool(tool) {\n    return (isStructuredToolParams(tool) ||\n        isRunnableToolLike(tool) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        isStructuredTool(tool));\n}\nexports.isLangChainTool = isLangChainTool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCO0FBQ2hMLDZCQUE2QixtQkFBTyxDQUFDLHFGQUFvQjtBQUN6RCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsMEdBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZELGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEIsSUFBSTtBQUNqRjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0U7QUFDN0UsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEUsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmcuY2pzP2NjNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTGFuZ0NoYWluVG9vbCA9IGV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyA9IGV4cG9ydHMuaXNSdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sID0gZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlUb29sID0gZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlGdW5jdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHpvZF90b19qc29uX3NjaGVtYV8xID0gcmVxdWlyZShcInpvZC10by1qc29uLXNjaGVtYVwiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG5jb25zdCBpc196b2Rfc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlcy9pc196b2Rfc2NoZW1hLmNqc1wiKTtcbi8qKlxuICogRm9ybWF0cyBhIGBTdHJ1Y3R1cmVkVG9vbGAgb3IgYFJ1bm5hYmxlVG9vbExpa2VgIGluc3RhbmNlIGludG8gYSBmb3JtYXRcbiAqIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIE9wZW5BSSBmdW5jdGlvbiBjYWxsaW5nLiBJdCB1c2VzIHRoZSBgem9kVG9Kc29uU2NoZW1hYFxuICogZnVuY3Rpb24gdG8gY29udmVydCB0aGUgc2NoZW1hIG9mIHRoZSBgU3RydWN0dXJlZFRvb2xgIG9yIGBSdW5uYWJsZVRvb2xMaWtlYFxuICogaW50byBhIEpTT04gc2NoZW1hLCB3aGljaCBpcyB0aGVuIHVzZWQgYXMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBPcGVuQUkgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSB8IFJ1bm5hYmxlVG9vbExpa2V9IHRvb2wgVGhlIHRvb2wgdG8gY29udmVydCB0byBhbiBPcGVuQUkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25EZWZpbml0aW9ufSBUaGUgaW5wdXR0ZWQgdG9vbCBpbiBPcGVuQUkgZnVuY3Rpb24gZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlGdW5jdGlvbih0b29sLCBmaWVsZHMpIHtcbiAgICAvLyBAVE9ETyAwLjMuMCBSZW1vdmUgdGhlIGBudW1iZXJgIHR5cGluZ1xuICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB0eXBlb2YgZmllbGRzID09PSBcIm51bWJlclwiID8gdW5kZWZpbmVkIDogZmllbGRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICAgIHBhcmFtZXRlcnM6ICgwLCB6b2RfdG9fanNvbl9zY2hlbWFfMS56b2RUb0pzb25TY2hlbWEpKHRvb2wuc2NoZW1hKSxcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgdGhlIGBzdHJpY3RgIGZpZWxkIGlmIGl0IGlzIGB1bmRlZmluZWRgLlxuICAgICAgICAuLi4oZmllbGRzQ29weT8uc3RyaWN0ICE9PSB1bmRlZmluZWQgPyB7IHN0cmljdDogZmllbGRzQ29weS5zdHJpY3QgfSA6IHt9KSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlGdW5jdGlvbiA9IGNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uO1xuLyoqXG4gKiBGb3JtYXRzIGEgYFN0cnVjdHVyZWRUb29sYCBvciBgUnVubmFibGVUb29sTGlrZWAgaW5zdGFuY2UgaW50byBhXG4gKiBmb3JtYXQgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggT3BlbkFJIHRvb2wgY2FsbGluZy4gSXQgdXNlcyB0aGVcbiAqIGB6b2RUb0pzb25TY2hlbWFgIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIHNjaGVtYSBvZiB0aGUgYFN0cnVjdHVyZWRUb29sYFxuICogb3IgYFJ1bm5hYmxlVG9vbExpa2VgIGludG8gYSBKU09OIHNjaGVtYSwgd2hpY2ggaXMgdGhlbiB1c2VkIGFzIHRoZVxuICogcGFyYW1ldGVycyBmb3IgdGhlIE9wZW5BSSB0b29sLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0dXJlZFRvb2xJbnRlcmZhY2UgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgUnVubmFibGVUb29sTGlrZX0gdG9vbCBUaGUgdG9vbCB0byBjb252ZXJ0IHRvIGFuIE9wZW5BSSB0b29sLlxuICogQHJldHVybnMge1Rvb2xEZWZpbml0aW9ufSBUaGUgaW5wdXR0ZWQgdG9vbCBpbiBPcGVuQUkgdG9vbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSVRvb2woXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudG9vbCwgZmllbGRzKSB7XG4gICAgLy8gQFRPRE8gMC4zLjAgUmVtb3ZlIHRoZSBgbnVtYmVyYCB0eXBpbmdcbiAgICBjb25zdCBmaWVsZHNDb3B5ID0gdHlwZW9mIGZpZWxkcyA9PT0gXCJudW1iZXJcIiA/IHVuZGVmaW5lZCA6IGZpZWxkcztcbiAgICBsZXQgdG9vbERlZjtcbiAgICBpZiAoaXNMYW5nQ2hhaW5Ub29sKHRvb2wpKSB7XG4gICAgICAgIHRvb2xEZWYgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBmdW5jdGlvbjogY29udmVydFRvT3BlbkFJRnVuY3Rpb24odG9vbCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b29sRGVmID0gdG9vbDtcbiAgICB9XG4gICAgaWYgKGZpZWxkc0NvcHk/LnN0cmljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRvb2xEZWYuZnVuY3Rpb24uc3RyaWN0ID0gZmllbGRzQ29weS5zdHJpY3Q7XG4gICAgfVxuICAgIHJldHVybiB0b29sRGVmO1xufVxuZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlUb29sID0gY29udmVydFRvT3BlbkFJVG9vbDtcbi8qKlxuICogQ29uZmlybSB3aGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSB8IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RydWN0dXJlZFRvb2woXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudG9vbCkge1xuICAgIHJldHVybiAodG9vbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodG9vbC5sY19uYW1lc3BhY2UpKTtcbn1cbmV4cG9ydHMuaXNTdHJ1Y3R1cmVkVG9vbCA9IGlzU3RydWN0dXJlZFRvb2w7XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAuXG4gKlxuICogQHBhcmFtIHt1bmtub3duIHwgdW5kZWZpbmVkfSB0b29sIFRoZSB0b29sIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFJ1bm5hYmxlVG9vbExpa2V9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgLlxuICovXG5mdW5jdGlvbiBpc1J1bm5hYmxlVG9vbExpa2UodG9vbCkge1xuICAgIHJldHVybiAodG9vbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhc2VfanNfMS5SdW5uYWJsZS5pc1J1bm5hYmxlKHRvb2wpICYmXG4gICAgICAgIFwibGNfbmFtZVwiIGluIHRvb2wuY29uc3RydWN0b3IgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSgpID09PSBcIlJ1bm5hYmxlVG9vbExpa2VcIik7XG59XG5leHBvcnRzLmlzUnVubmFibGVUb29sTGlrZSA9IGlzUnVubmFibGVUb29sTGlrZTtcbi8qKlxuICogQ29uZmlybSB3aGV0aGVyIG9yIG5vdCB0aGUgdG9vbCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXMgdG8gYmUgY29uc2lkZXJlZCBhIGBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2AuXG4gKlxuICogQHBhcmFtIHt1bmtub3duIHwgdW5kZWZpbmVkfSB0b29sIFRoZSBvYmplY3QgdG8gY2hlY2sgaWYgaXQgaXMgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xQYXJhbXN9IFdoZXRoZXIgdGhlIGlucHV0dGVkIG9iamVjdCBpcyBhIGBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2AuXG4gKi9cbmZ1bmN0aW9uIGlzU3RydWN0dXJlZFRvb2xQYXJhbXModG9vbCkge1xuICAgIHJldHVybiAoISF0b29sICYmXG4gICAgICAgIHR5cGVvZiB0b29sID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwibmFtZVwiIGluIHRvb2wgJiZcbiAgICAgICAgXCJzY2hlbWFcIiBpbiB0b29sICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICgwLCBpc196b2Rfc2NoZW1hX2pzXzEuaXNab2RTY2hlbWEpKHRvb2wuc2NoZW1hKSk7XG59XG5leHBvcnRzLmlzU3RydWN0dXJlZFRvb2xQYXJhbXMgPSBpc1N0cnVjdHVyZWRUb29sUGFyYW1zO1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgdG9vbCBpcyBvbmUgb2YgU3RydWN0dXJlZFRvb2wsIFJ1bm5hYmxlVG9vbCBvciBTdHJ1Y3R1cmVkVG9vbFBhcmFtcy5cbiAqIEl0IHJldHVybnMgYGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zYCBzaW5jZSB0aGF0IGlzIHRoZSBtb3N0IG1pbmltYWwgaW50ZXJmYWNlIG9mIHRoZSB0aHJlZSxcbiAqIHdoaWxlIHN0aWxsIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIGJlIHBhc3NlZCB0byBhIExMTSBmb3IgdG9vbCBjYWxsaW5nLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93biB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgdG9vbCB0byBjaGVjayBpZiBpdCBpcyBhIExhbmdDaGFpbiB0b29sLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xQYXJhbXN9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYSBMYW5nQ2hhaW4gdG9vbC5cbiAqL1xuZnVuY3Rpb24gaXNMYW5nQ2hhaW5Ub29sKHRvb2wpIHtcbiAgICByZXR1cm4gKGlzU3RydWN0dXJlZFRvb2xQYXJhbXModG9vbCkgfHxcbiAgICAgICAgaXNSdW5uYWJsZVRvb2xMaWtlKHRvb2wpIHx8XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlzU3RydWN0dXJlZFRvb2wodG9vbCkpO1xufVxuZXhwb3J0cy5pc0xhbmdDaGFpblRvb2wgPSBpc0xhbmdDaGFpblRvb2w7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/hash.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.insecureHash = void 0;\nvar hash_js_1 = __webpack_require__(/*! ./js-sha1/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\");\nObject.defineProperty(exports, \"insecureHash\", ({ enumerable: true, get: function () { return hash_js_1.insecureHash; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvaGFzaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLGdCQUFnQixtQkFBTyxDQUFDLDRGQUFvQjtBQUM1QyxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvaGFzaC5janM/NmQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5zZWN1cmVIYXNoID0gdm9pZCAwO1xudmFyIGhhc2hfanNfMSA9IHJlcXVpcmUoXCIuL2pzLXNoYTEvaGFzaC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnNlY3VyZUhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hfanNfMS5pbnNlY3VyZUhhc2g7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/*\n * [js-sha1]{@link https://github.com/emn178/js-sha1}\n *\n * @version 0.6.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.insecureHash = void 0;\nvar root = typeof window === \"object\" ? window : {};\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha1(sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.h0 = 0x67452301;\n    this.h1 = 0xefcdab89;\n    this.h2 = 0x98badcfe;\n    this.h3 = 0x10325476;\n    this.h4 = 0xc3d2e1f0;\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n}\nSha1.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString = typeof message !== \"string\";\n    if (notString && message.constructor === root.ArrayBuffer) {\n        message = new Uint8Array(message);\n    }\n    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha1.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha1.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n    var f, j, t, blocks = this.blocks;\n    for (j = 16; j < 80; ++j) {\n        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n        blocks[j] = (t << 1) | (t >>> 31);\n    }\n    for (j = 0; j < 20; j += 5) {\n        f = (b & c) | (~b & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1518500249 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (~a & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1518500249 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (~e & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1518500249 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (~d & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1518500249 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (~c & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1518500249 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 40; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1859775393 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1859775393 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1859775393 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1859775393 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1859775393 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 60; j += 5) {\n        f = (b & c) | (b & d) | (c & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 1894007588 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (a & c) | (b & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 1894007588 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (e & b) | (a & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 1894007588 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (d & a) | (e & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 1894007588 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (c & e) | (d & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 1894007588 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 80; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 899497514 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 899497514 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 899497514 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 899497514 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 899497514 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n};\nSha1.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return (HEX_CHARS[(h0 >> 28) & 0x0f] +\n        HEX_CHARS[(h0 >> 24) & 0x0f] +\n        HEX_CHARS[(h0 >> 20) & 0x0f] +\n        HEX_CHARS[(h0 >> 16) & 0x0f] +\n        HEX_CHARS[(h0 >> 12) & 0x0f] +\n        HEX_CHARS[(h0 >> 8) & 0x0f] +\n        HEX_CHARS[(h0 >> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >> 28) & 0x0f] +\n        HEX_CHARS[(h1 >> 24) & 0x0f] +\n        HEX_CHARS[(h1 >> 20) & 0x0f] +\n        HEX_CHARS[(h1 >> 16) & 0x0f] +\n        HEX_CHARS[(h1 >> 12) & 0x0f] +\n        HEX_CHARS[(h1 >> 8) & 0x0f] +\n        HEX_CHARS[(h1 >> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >> 28) & 0x0f] +\n        HEX_CHARS[(h2 >> 24) & 0x0f] +\n        HEX_CHARS[(h2 >> 20) & 0x0f] +\n        HEX_CHARS[(h2 >> 16) & 0x0f] +\n        HEX_CHARS[(h2 >> 12) & 0x0f] +\n        HEX_CHARS[(h2 >> 8) & 0x0f] +\n        HEX_CHARS[(h2 >> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >> 28) & 0x0f] +\n        HEX_CHARS[(h3 >> 24) & 0x0f] +\n        HEX_CHARS[(h3 >> 20) & 0x0f] +\n        HEX_CHARS[(h3 >> 16) & 0x0f] +\n        HEX_CHARS[(h3 >> 12) & 0x0f] +\n        HEX_CHARS[(h3 >> 8) & 0x0f] +\n        HEX_CHARS[(h3 >> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >> 28) & 0x0f] +\n        HEX_CHARS[(h4 >> 24) & 0x0f] +\n        HEX_CHARS[(h4 >> 20) & 0x0f] +\n        HEX_CHARS[(h4 >> 16) & 0x0f] +\n        HEX_CHARS[(h4 >> 12) & 0x0f] +\n        HEX_CHARS[(h4 >> 8) & 0x0f] +\n        HEX_CHARS[(h4 >> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f]);\n};\nSha1.prototype.toString = Sha1.prototype.hex;\nSha1.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return [\n        (h0 >> 24) & 0xff,\n        (h0 >> 16) & 0xff,\n        (h0 >> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >> 24) & 0xff,\n        (h1 >> 16) & 0xff,\n        (h1 >> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >> 24) & 0xff,\n        (h2 >> 16) & 0xff,\n        (h2 >> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >> 24) & 0xff,\n        (h3 >> 16) & 0xff,\n        (h3 >> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >> 24) & 0xff,\n        (h4 >> 16) & 0xff,\n        (h4 >> 8) & 0xff,\n        h4 & 0xff,\n    ];\n};\nSha1.prototype.array = Sha1.prototype.digest;\nSha1.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(20);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    return buffer;\n};\nconst insecureHash = (message) => {\n    return new Sha1(true).update(message)[\"hex\"]();\n};\nexports.insecureHash = insecureHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMS9oYXNoLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qcy1zaGExL2hhc2guY2pzP2NjYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgdG8gZGVhbCB3aXRoIHBvcnRhYmlsaXR5IGlzc3VlcyB3aXRoIGltcG9ydGluZyBjcnlwdG8gbW9kdWxlXG4vKlxuICogW2pzLXNoYTFde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhMX1cbiAqXG4gKiBAdmVyc2lvbiAwLjYuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluc2VjdXJlSGFzaCA9IHZvaWQgMDtcbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHt9O1xudmFyIEhFWF9DSEFSUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO1xudmFyIEVYVFJBID0gWy0yMTQ3NDgzNjQ4LCA4Mzg4NjA4LCAzMjc2OCwgMTI4XTtcbnZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xudmFyIE9VVFBVVF9UWVBFUyA9IFtcImhleFwiLCBcImFycmF5XCIsIFwiZGlnZXN0XCIsIFwiYXJyYXlCdWZmZXJcIl07XG52YXIgYmxvY2tzID0gW107XG5mdW5jdGlvbiBTaGExKHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgICAgYmxvY2tzWzBdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgfVxuICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5O1xuICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlO1xuICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwO1xuICAgIHRoaXMuYmxvY2sgPSB0aGlzLnN0YXJ0ID0gdGhpcy5ieXRlcyA9IHRoaXMuaEJ5dGVzID0gMDtcbiAgICB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdCA9IHRydWU7XG59XG5TaGExLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIjtcbiAgICBpZiAobm90U3RyaW5nICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IHJvb3QuQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCB8fCAwLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MTAwMDAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5ieXRlcyArPSBpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHRoaXMuaEJ5dGVzICs9ICh0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NikgPDwgMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5TaGExLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4O1xuICAgIGJsb2Nrc1sxNl0gPSB0aGlzLmJsb2NrO1xuICAgIGJsb2Nrc1tpID4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSAodGhpcy5oQnl0ZXMgPDwgMykgfCAodGhpcy5ieXRlcyA+Pj4gMjkpO1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG59O1xuU2hhMS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IHRoaXMuaDAsIGIgPSB0aGlzLmgxLCBjID0gdGhpcy5oMiwgZCA9IHRoaXMuaDMsIGUgPSB0aGlzLmg0O1xuICAgIHZhciBmLCBqLCB0LCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICBmb3IgKGogPSAxNjsgaiA8IDgwOyArK2opIHtcbiAgICAgICAgdCA9IGJsb2Nrc1tqIC0gM10gXiBibG9ja3NbaiAtIDhdIF4gYmxvY2tzW2ogLSAxNF0gXiBibG9ja3NbaiAtIDE2XTtcbiAgICAgICAgYmxvY2tzW2pdID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgIH1cbiAgICBmb3IgKGogPSAwOyBqIDwgMjA7IGogKz0gNSkge1xuICAgICAgICBmID0gKGIgJiBjKSB8ICh+YiAmIGQpO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSArIDE1MTg1MDAyNDkgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSAoYSAmIGIpIHwgKH5hICYgYyk7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZSAmIGEpIHwgKH5lICYgYik7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZCAmIGUpIHwgKH5kICYgYSk7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSAoYyAmIGQpIHwgKH5jICYgZSk7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgNDA7IGogKz0gNSkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSArIDE4NTk3NzUzOTMgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSBhIF4gYiBeIGM7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSBkIF4gZSBeIGE7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSBjIF4gZCBeIGU7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgNjA7IGogKz0gNSkge1xuICAgICAgICBmID0gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSAtIDE4OTQwMDc1ODggKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSAoYSAmIGIpIHwgKGEgJiBjKSB8IChiICYgYyk7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZSAmIGEpIHwgKGUgJiBiKSB8IChhICYgYik7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZCAmIGUpIHwgKGQgJiBhKSB8IChlICYgYSk7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSAoYyAmIGQpIHwgKGMgJiBlKSB8IChkICYgZSk7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgODA7IGogKz0gNSkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IGEgXiBiIF4gYztcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gZSBeIGEgXiBiO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSBkIF4gZSBeIGE7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IGMgXiBkIF4gZTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICB0aGlzLmgwID0gKHRoaXMuaDAgKyBhKSA8PCAwO1xuICAgIHRoaXMuaDEgPSAodGhpcy5oMSArIGIpIDw8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgPDwgMDtcbiAgICB0aGlzLmgzID0gKHRoaXMuaDMgKyBkKSA8PCAwO1xuICAgIHRoaXMuaDQgPSAodGhpcy5oNCArIGUpIDw8IDA7XG59O1xuU2hhMS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQ7XG4gICAgcmV0dXJuIChIRVhfQ0hBUlNbKGgwID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMCAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDEgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gyICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMyAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDQgJiAweDBmXSk7XG59O1xuU2hhMS5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGExLnByb3RvdHlwZS5oZXg7XG5TaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNDtcbiAgICByZXR1cm4gW1xuICAgICAgICAoaDAgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgwID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgwICYgMHhmZixcbiAgICAgICAgKGgxID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDEgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDIgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgyID4+IDgpICYgMHhmZixcbiAgICAgICAgaDIgJiAweGZmLFxuICAgICAgICAoaDMgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgzID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgzICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDQgPj4gOCkgJiAweGZmLFxuICAgICAgICBoNCAmIDB4ZmYsXG4gICAgXTtcbn07XG5TaGExLnByb3RvdHlwZS5hcnJheSA9IFNoYTEucHJvdG90eXBlLmRpZ2VzdDtcblNoYTEucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIwKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5jb25zdCBpbnNlY3VyZUhhc2ggPSAobWVzc2FnZSkgPT4ge1xuICAgIHJldHVybiBuZXcgU2hhMSh0cnVlKS51cGRhdGUobWVzc2FnZSlbXCJoZXhcIl0oKTtcbn07XG5leHBvcnRzLmluc2VjdXJlSGFzaCA9IGluc2VjdXJlSGFzaDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parsePartialJson = exports.parseJsonMarkdown = void 0;\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\nexports.parseJsonMarkdown = parseJsonMarkdown;\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\nexports.parsePartialJson = parsePartialJson;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzb24uY2pzPzUzN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlUGFydGlhbEpzb24gPSBleHBvcnRzLnBhcnNlSnNvbk1hcmtkb3duID0gdm9pZCAwO1xuZnVuY3Rpb24gcGFyc2VKc29uTWFya2Rvd24ocywgcGFyc2VyID0gcGFyc2VQYXJ0aWFsSnNvbikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHMgPSBzLnRyaW0oKTtcbiAgICBjb25zdCBtYXRjaCA9IC9gYGAoanNvbik/KC4qKWBgYC9zLmV4ZWMocyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gcGFyc2VyKHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcihtYXRjaFsyXSk7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZUpzb25NYXJrZG93biA9IHBhcnNlSnNvbk1hcmtkb3duO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LaWxsaWFuTHVjYXMvb3Blbi1pbnRlcnByZXRlci9ibG9iL21haW4vaW50ZXJwcmV0ZXIvY29yZS9sbG0vdXRpbHMvcGFyc2VfcGFydGlhbF9qc29uLnB5XG4vLyBNSVQgTGljZW5zZVxuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihzKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCwgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgZmFpbHVyZS5cbiAgICBpZiAodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIHN0cmluZyBhcy1pcy5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFBhc3NcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXG4gICAgbGV0IG5ld19zID0gXCJcIjtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIG9uZSBhdCBhIHRpbWUuXG4gICAgZm9yIChsZXQgY2hhciBvZiBzKSB7XG4gICAgICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJcXG5cIiAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBcIlxcXFxuXCI7IC8vIFJlcGxhY2UgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggdGhlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc21hdGNoZWQgY2xvc2luZyBjaGFyYWN0ZXI7IHRoZSBpbnB1dCBpcyBtYWxmb3JtZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdGhlIHByb2Nlc3NlZCBjaGFyYWN0ZXIgdG8gdGhlIG5ldyBzdHJpbmcuXG4gICAgICAgIG5ld19zICs9IGNoYXI7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHN0aWxsIGluc2lkZSBhIHN0cmluZyBhdCB0aGUgZW5kIG9mIHByb2Nlc3NpbmcsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9zZSB0aGUgc3RyaW5nLlxuICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICBuZXdfcyArPSAnXCInO1xuICAgIH1cbiAgICAvLyBDbG9zZSBhbnkgcmVtYWluaW5nIG9wZW4gc3RydWN0dXJlcyBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBvcGVuZWQuXG4gICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIG5ld19zICs9IHN0YWNrW2ldO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBtb2RpZmllZCBzdHJpbmcgYXMgSlNPTi5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShuZXdfcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBjYW4ndCBwYXJzZSB0aGUgc3RyaW5nIGFzIEpTT04sIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMucGFyc2VQYXJ0aWFsSnNvbiA9IHBhcnNlUGFydGlhbEpzb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_patch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.applyPatch = exports.compare = void 0;\nvar index_js_1 = __webpack_require__(/*! ./fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nObject.defineProperty(exports, \"compare\", ({ enumerable: true, get: function () { return index_js_1.compare; } }));\nObject.defineProperty(exports, \"applyPatch\", ({ enumerable: true, get: function () { return index_js_1.applyPatch; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9wYXRjaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZUFBZTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDdEQsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qc29uX3BhdGNoLmNqcz80MzFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseVBhdGNoID0gZXhwb3J0cy5jb21wYXJlID0gdm9pZCAwO1xudmFyIGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi9mYXN0LWpzb24tcGF0Y2gvaW5kZXguY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5jb21wYXJlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlQYXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5hcHBseVBhdGNoOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/signal.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raceWithSignal = void 0;\nasync function raceWithSignal(promise, signal) {\n    if (signal === undefined) {\n        return promise;\n    }\n    let listener;\n    return Promise.race([\n        promise.catch((err) => {\n            if (!signal?.aborted) {\n                throw err;\n            }\n            else {\n                return undefined;\n            }\n        }),\n        new Promise((_, reject) => {\n            listener = () => {\n                reject(new Error(\"Aborted\"));\n            };\n            signal.addEventListener(\"abort\", listener);\n            // Must be here inside the promise to avoid a race condition\n            if (signal.aborted) {\n                reject(new Error(\"Aborted\"));\n            }\n        }),\n    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n}\nexports.raceWithSignal = raceWithSignal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmNqcz84ZWE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYWNlV2l0aFNpZ25hbCA9IHZvaWQgMDtcbmFzeW5jIGZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVyO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBwcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgaGVyZSBpbnNpZGUgdGhlIHByb21pc2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICBdKS5maW5hbGx5KCgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpKTtcbn1cbmV4cG9ydHMucmFjZVdpdGhTaWduYWwgPSByYWNlV2l0aFNpZ25hbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pipeGeneratorWithSetup = exports.AsyncGeneratorWithSetup = exports.concat = exports.atee = exports.IterableReadableStream = void 0;\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ./signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nexports.IterableReadableStream = IterableReadableStream;\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nexports.atee = atee;\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nexports.concat = concat;\nclass AsyncGeneratorWithSetup {\n    constructor(params) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signal\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = params.generator;\n        this.config = params.config;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.signal = params.signal ?? this.config?.signal;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(params.config, async () => {\n                this.firstResult = params.generator.next();\n                if (params.startSetup) {\n                    this.firstResult.then(params.startSetup).then(resolve, reject);\n                }\n                else {\n                    this.firstResult.then((_result) => resolve(undefined), reject);\n                }\n            }, true);\n        });\n    }\n    async next(...args) {\n        this.signal?.throwIfAborted();\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(this.config, this.signal\n            ? async () => {\n                return (0, signal_js_1.raceWithSignal)(this.generator.next(...args), this.signal);\n            }\n            : async () => {\n                return this.generator.next(...args);\n            }, true);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n}\nexports.AsyncGeneratorWithSetup = AsyncGeneratorWithSetup;\nasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n    const gen = new AsyncGeneratorWithSetup({\n        generator,\n        startSetup,\n        signal,\n    });\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\nexports.pipeGeneratorWithSetup = pipeGeneratorWithSetup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRywrQkFBK0IsR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLDhCQUE4QjtBQUNqSSxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxNQUFNLGNBQWM7QUFDM0U7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9zdHJlYW0uY2pzPzdlMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpcGVHZW5lcmF0b3JXaXRoU2V0dXAgPSBleHBvcnRzLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmF0ZWUgPSBleHBvcnRzLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3Qgc2lnbmFsX2pzXzEgPSByZXF1aXJlKFwiLi9zaWduYWwuY2pzXCIpO1xuLypcbiAqIFN1cHBvcnQgYXN5bmMgaXRlcmF0b3Igc3ludGF4IGZvciBSZWFkYWJsZVN0cmVhbXMgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtID0gSXRlcmFibGVSZWFkYWJsZVN0cmVhbTtcbmZ1bmN0aW9uIGF0ZWUoaXRlciwgbGVuZ3RoID0gMikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IFtdKTtcbiAgICByZXR1cm4gYnVmZmVycy5tYXAoYXN5bmMgZnVuY3Rpb24qIG1ha2VJdGVyKGJ1ZmZlcikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyWzBdLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHlpZWxkIGJ1ZmZlci5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmF0ZWUgPSBhdGVlO1xuZnVuY3Rpb24gY29uY2F0KGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmQpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgKyBzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIFwiY29uY2F0XCIgaW4gZmlyc3QgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdHlwZW9mIGZpcnN0LmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQoc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7IC4uLmZpcnN0IH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gY2h1bmsgJiYgIUFycmF5LmlzQXJyYXkoY2h1bmtba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBjaHVua1trZXldID0gY29uY2F0KGNodW5rW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb25jYXQgJHt0eXBlb2YgZmlyc3R9IGFuZCAke3R5cGVvZiBzZWNvbmR9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5jbGFzcyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR1cFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnbmFsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0UmVzdWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0UmVzdWx0VXNlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gcGFyYW1zLmdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBwYXJhbXMuY29uZmlnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnNpZ25hbCA9IHBhcmFtcy5zaWduYWwgPz8gdGhpcy5jb25maWc/LnNpZ25hbDtcbiAgICAgICAgLy8gc2V0dXAgaXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25seSBhZnRlciB0aGUgZmlyc3QgaXRlcmF0b3IgdmFsdWVcbiAgICAgICAgLy8gaXMgYXZhaWxhYmxlLiB0aGlzIGlzIHVzZWZ1bCB3aGVuIHNldHVwIG9mIHNldmVyYWwgcGlwZWQgZ2VuZXJhdG9yc1xuICAgICAgICAvLyBuZWVkcyB0byBoYXBwZW4gaW4gbG9naWNhbCBvcmRlciwgaWUuIGluIHRoZSBvcmRlciBpbiB3aGljaCBpbnB1dCB0b1xuICAgICAgICAvLyB0byBlYWNoIGdlbmVyYXRvciBpcyBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2V0dXAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBhcmFtcy5jb25maWcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0ID0gcGFyYW1zLmdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdGFydFNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbihwYXJhbXMuc3RhcnRTZXR1cCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKChfcmVzdWx0KSA9PiByZXNvbHZlKHVuZGVmaW5lZCksIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBuZXh0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5maXJzdFJlc3VsdFVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyh0aGlzLmNvbmZpZywgdGhpcy5zaWduYWxcbiAgICAgICAgICAgID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHRoaXMuZ2VuZXJhdG9yLm5leHQoLi4uYXJncyksIHRoaXMuc2lnbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5uZXh0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJldHVybih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IucmV0dXJuKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgdGhyb3coZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IudGhyb3coZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZSBOb3QgcHJlc2VudCBpbiBOb2RlIDE4IHR5cGVzLCByZXF1aXJlZCBpbiBsYXRlc3QgTm9kZSAyMlxuICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXR1cm4oKTtcbiAgICB9XG59XG5leHBvcnRzLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwID0gQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXA7XG5hc3luYyBmdW5jdGlvbiBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRvLCBnZW5lcmF0b3IsIHN0YXJ0U2V0dXAsIHNpZ25hbCwgLi4uYXJncykge1xuICAgIGNvbnN0IGdlbiA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh7XG4gICAgICAgIGdlbmVyYXRvcixcbiAgICAgICAgc3RhcnRTZXR1cCxcbiAgICAgICAgc2lnbmFsLFxuICAgIH0pO1xuICAgIGNvbnN0IHNldHVwID0gYXdhaXQgZ2VuLnNldHVwO1xuICAgIHJldHVybiB7IG91dHB1dDogdG8oZ2VuLCBzZXR1cCwgLi4uYXJncyksIHNldHVwIH07XG59XG5leHBvcnRzLnBpcGVHZW5lcmF0b3JXaXRoU2V0dXAgPSBwaXBlR2VuZXJhdG9yV2l0aFNldHVwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/tiktoken.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodingForModel = exports.getEncoding = void 0;\nconst lite_1 = __webpack_require__(/*! js-tiktoken/lite */ \"(rsc)/./node_modules/js-tiktoken/dist/lite.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ./async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst cache = {};\nconst caller = /* #__PURE__ */ new async_caller_js_1.AsyncCaller({});\nasync function getEncoding(encoding) {\n    if (!(encoding in cache)) {\n        cache[encoding] = caller\n            .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n            .then((res) => res.json())\n            .then((data) => new lite_1.Tiktoken(data))\n            .catch((e) => {\n            delete cache[encoding];\n            throw e;\n        });\n    }\n    return await cache[encoding];\n}\nexports.getEncoding = getEncoding;\nasync function encodingForModel(model) {\n    return getEncoding((0, lite_1.getEncodingNameForModel)(model));\n}\nexports.encodingForModel = encodingForModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGlrdG9rZW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLG1CQUFtQjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFvQjtBQUN0RDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGlrdG9rZW4uY2pzPzM3NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kaW5nRm9yTW9kZWwgPSBleHBvcnRzLmdldEVuY29kaW5nID0gdm9pZCAwO1xuY29uc3QgbGl0ZV8xID0gcmVxdWlyZShcImpzLXRpa3Rva2VuL2xpdGVcIik7XG5jb25zdCBhc3luY19jYWxsZXJfanNfMSA9IHJlcXVpcmUoXCIuL2FzeW5jX2NhbGxlci5janNcIik7XG5jb25zdCBjYWNoZSA9IHt9O1xuY29uc3QgY2FsbGVyID0gLyogI19fUFVSRV9fICovIG5ldyBhc3luY19jYWxsZXJfanNfMS5Bc3luY0NhbGxlcih7fSk7XG5hc3luYyBmdW5jdGlvbiBnZXRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghKGVuY29kaW5nIGluIGNhY2hlKSkge1xuICAgICAgICBjYWNoZVtlbmNvZGluZ10gPSBjYWxsZXJcbiAgICAgICAgICAgIC5mZXRjaChgaHR0cHM6Ly90aWt0b2tlbi5wYWdlcy5kZXYvanMvJHtlbmNvZGluZ30uanNvbmApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IG5ldyBsaXRlXzEuVGlrdG9rZW4oZGF0YSkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtlbmNvZGluZ107XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlW2VuY29kaW5nXTtcbn1cbmV4cG9ydHMuZ2V0RW5jb2RpbmcgPSBnZXRFbmNvZGluZztcbmFzeW5jIGZ1bmN0aW9uIGVuY29kaW5nRm9yTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gZ2V0RW5jb2RpbmcoKDAsIGxpdGVfMS5nZXRFbmNvZGluZ05hbWVGb3JNb2RlbCkobW9kZWwpKTtcbn1cbmV4cG9ydHMuZW5jb2RpbmdGb3JNb2RlbCA9IGVuY29kaW5nRm9yTW9kZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isZodSchema = void 0;\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {z.ZodType<RunOutput> | Record<string, any>} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nfunction isZodSchema(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninput) {\n    // Check for a characteristic method of Zod schemas\n    return typeof input?.parse === \"function\";\n}\nexports.isZodSchema = isZodSchema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaXNfem9kX3NjaGVtYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDO0FBQ3ZELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy90eXBlcy9pc196b2Rfc2NoZW1hLmNqcz8zYzIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1pvZFNjaGVtYSA9IHZvaWQgMDtcbi8qKlxuICogR2l2ZW4gZWl0aGVyIGEgWm9kIHNjaGVtYSwgb3IgcGxhaW4gb2JqZWN0LCBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGlzIGEgWm9kIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge3ouWm9kVHlwZTxSdW5PdXRwdXQ+IHwgUmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaW5wdXQgaXMgYSBab2Qgc2NoZW1hLlxuICovXG5mdW5jdGlvbiBpc1pvZFNjaGVtYShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5pbnB1dCkge1xuICAgIC8vIENoZWNrIGZvciBhIGNoYXJhY3RlcmlzdGljIG1ldGhvZCBvZiBab2Qgc2NoZW1hc1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQ/LnBhcnNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnRzLmlzWm9kU2NoZW1hID0gaXNab2RTY2hlbWE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/is_zod_schema.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/embeddings.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/embeddings.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/embeddings.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3MuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDZIQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZW1iZWRkaW5ncy5janM/NGI1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9lbWJlZGRpbmdzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/base.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/base.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcz8yMmQzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sYW5ndWFnZV9tb2RlbHMvYmFzZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/chat_models.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/chat_models.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQUEsZ0tBQW1FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvY2hhdF9tb2RlbHMuY2pzP2FhNzMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/llms.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/llms.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/llms.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcz8wYzc3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sYW5ndWFnZV9tb2RlbHMvbGxtcy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/load/serializable.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/load/serializable.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlLmNqcz9lYTRjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9sb2FkL3NlcmlhbGl6YWJsZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/messages.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/messages.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxxSUFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzLmNqcz8zYzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L21lc3NhZ2VzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/messages.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/output_parsers/openai_tools.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/output_parsers/openai_tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEtBQXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9vdXRwdXRfcGFyc2Vycy9vcGVuYWlfdG9vbHMuY2pzP2Y4MzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/outputs.cjs":
/*!**************************************************!*\
  !*** ./node_modules/@langchain/core/outputs.cjs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dHMuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHVIQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvb3V0cHV0cy5janM/ZWNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9vdXRwdXRzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/runnables.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUlBQXNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXMuY2pzPzczNjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcnVubmFibGVzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables/remote.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/runnables/remote.cjs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/runnables/remote.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy9yZW1vdGUuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDBJQUF3RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzL3JlbW90ZS5janM/NmM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/stores.cjs":
/*!*************************************************!*\
  !*** ./node_modules/@langchain/core/stores.cjs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/stores.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/stores.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3N0b3Jlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEscUhBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9zdG9yZXMuY2pzPzgzZjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc3RvcmVzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/tools.cjs":
/*!************************************************!*\
  !*** ./node_modules/@langchain/core/tools.cjs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3Rvb2xzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSwrSEFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3Rvb2xzLmNqcz8xNGI2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3Rvb2xzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/async_caller.cjs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlci5janMiLCJtYXBwaW5ncyI6IkFBQUEsOElBQTBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9hc3luY19jYWxsZXIuY2pzPzQ4ZDciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/chunk_array.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/chunk_array.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2NodW5rX2FycmF5LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2NodW5rX2FycmF5LmNqcz9iMjFiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC91dGlscy9jaHVua19hcnJheS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/env.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/utils/env.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Vudi5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEhBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9lbnYuY2pzP2ZmM2UiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2Vudi5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/function_calling.cjs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/function_calling.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHNKQUE4RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janM/ZTc3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/stream.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/stream.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbS5janMiLCJtYXBwaW5ncyI6IkFBQUEsa0lBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9zdHJlYW0uY2pzPzYzYTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL3N0cmVhbS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/auth.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureAuthOptionScopes = exports.aiPlatformScope = exports.ApiKeyGoogleAuth = exports.GoogleAbstractedFetchClient = void 0;\nconst stream_js_1 = __webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\");\nclass GoogleAbstractedFetchClient {\n    async _buildData(res, opts) {\n        switch (opts.responseType) {\n            case \"json\":\n                return res.json();\n            case \"stream\":\n                return new stream_js_1.ReadableJsonStream(res.body);\n            default:\n                return res.blob();\n        }\n    }\n    async _request(url, opts, additionalHeaders) {\n        if (url == null)\n            throw new Error(\"Missing URL\");\n        const fetchOptions = {\n            method: opts.method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...(opts.headers ?? {}),\n                ...(additionalHeaders ?? {}),\n            },\n        };\n        if (opts.data !== undefined) {\n            if (typeof opts.data === \"string\") {\n                fetchOptions.body = opts.data;\n            }\n            else {\n                fetchOptions.body = JSON.stringify(opts.data);\n            }\n        }\n        const res = await fetch(url, fetchOptions);\n        if (!res.ok) {\n            const resText = await res.text();\n            const error = new Error(`Google request failed with status code ${res.status}: ${resText}`);\n            /* eslint-disable @typescript-eslint/no-explicit-any */\n            error.response = res;\n            error.details = {\n                url,\n                opts,\n                fetchOptions,\n                result: res,\n            };\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            throw error;\n        }\n        const data = await this._buildData(res, opts);\n        return {\n            data,\n            config: {},\n            status: res.status,\n            statusText: res.statusText,\n            headers: res.headers,\n            request: { responseURL: res.url },\n        };\n    }\n}\nexports.GoogleAbstractedFetchClient = GoogleAbstractedFetchClient;\nclass ApiKeyGoogleAuth extends GoogleAbstractedFetchClient {\n    constructor(apiKey) {\n        super();\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.apiKey = apiKey;\n    }\n    get clientType() {\n        return \"apiKey\";\n    }\n    getProjectId() {\n        throw new Error(\"APIs that require a project ID cannot use an API key\");\n        // Perhaps we could implement this if needed:\n        // https://cloud.google.com/docs/authentication/api-keys#get-info\n    }\n    request(opts) {\n        const authHeader = {\n            \"X-Goog-Api-Key\": this.apiKey,\n        };\n        return this._request(opts.url, opts, authHeader);\n    }\n}\nexports.ApiKeyGoogleAuth = ApiKeyGoogleAuth;\nfunction aiPlatformScope(platform) {\n    switch (platform) {\n        case \"gai\":\n            return [\"https://www.googleapis.com/auth/generative-language\"];\n        default:\n            return [\"https://www.googleapis.com/auth/cloud-platform\"];\n    }\n}\nexports.aiPlatformScope = aiPlatformScope;\nfunction ensureAuthOptionScopes(authOption, scopeProperty, scopesOrPlatform) {\n    // If the property is already set, return it\n    if (authOption && Object.hasOwn(authOption, scopeProperty)) {\n        return authOption;\n    }\n    // Otherwise add it\n    const scopes = Array.isArray(scopesOrPlatform)\n        ? scopesOrPlatform\n        : aiPlatformScope(scopesOrPlatform ?? \"gcp\");\n    return {\n        [scopeProperty]: scopes,\n        ...(authOption ?? {}),\n    };\n}\nexports.ensureAuthOptionScopes = ensureAuthOptionScopes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvYXV0aC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsbUNBQW1DO0FBQ3pILG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVyxJQUFJLFFBQVE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvYXV0aC5janM/MmE1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlQXV0aE9wdGlvblNjb3BlcyA9IGV4cG9ydHMuYWlQbGF0Zm9ybVNjb3BlID0gZXhwb3J0cy5BcGlLZXlHb29nbGVBdXRoID0gZXhwb3J0cy5Hb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmVhbS5janNcIik7XG5jbGFzcyBHb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQge1xuICAgIGFzeW5jIF9idWlsZERhdGEocmVzLCBvcHRzKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICBjYXNlIFwic3RyZWFtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJlYW1fanNfMS5SZWFkYWJsZUpzb25TdHJlYW0ocmVzLmJvZHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJsb2IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVxdWVzdCh1cmwsIG9wdHMsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIGlmICh1cmwgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgVVJMXCIpO1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLihvcHRzLmhlYWRlcnMgPz8ge30pLFxuICAgICAgICAgICAgICAgIC4uLihhZGRpdGlvbmFsSGVhZGVycyA/PyB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBvcHRzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdHMuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzVGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR29vZ2xlIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzfTogJHtyZXNUZXh0fWApO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXM7XG4gICAgICAgICAgICBlcnJvci5kZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9idWlsZERhdGEocmVzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHsgcmVzcG9uc2VVUkw6IHJlcy51cmwgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudCA9IEdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudDtcbmNsYXNzIEFwaUtleUdvb2dsZUF1dGggZXh0ZW5kcyBHb29nbGVBYnN0cmFjdGVkRmV0Y2hDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgfVxuICAgIGdldCBjbGllbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhcGlLZXlcIjtcbiAgICB9XG4gICAgZ2V0UHJvamVjdElkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUElzIHRoYXQgcmVxdWlyZSBhIHByb2plY3QgSUQgY2Fubm90IHVzZSBhbiBBUEkga2V5XCIpO1xuICAgICAgICAvLyBQZXJoYXBzIHdlIGNvdWxkIGltcGxlbWVudCB0aGlzIGlmIG5lZWRlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vYXBpLWtleXMjZ2V0LWluZm9cbiAgICB9XG4gICAgcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXIgPSB7XG4gICAgICAgICAgICBcIlgtR29vZy1BcGktS2V5XCI6IHRoaXMuYXBpS2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChvcHRzLnVybCwgb3B0cywgYXV0aEhlYWRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5BcGlLZXlHb29nbGVBdXRoID0gQXBpS2V5R29vZ2xlQXV0aDtcbmZ1bmN0aW9uIGFpUGxhdGZvcm1TY29wZShwbGF0Zm9ybSkge1xuICAgIHN3aXRjaCAocGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSBcImdhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZ2VuZXJhdGl2ZS1sYW5ndWFnZVwiXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtXCJdO1xuICAgIH1cbn1cbmV4cG9ydHMuYWlQbGF0Zm9ybVNjb3BlID0gYWlQbGF0Zm9ybVNjb3BlO1xuZnVuY3Rpb24gZW5zdXJlQXV0aE9wdGlvblNjb3BlcyhhdXRoT3B0aW9uLCBzY29wZVByb3BlcnR5LCBzY29wZXNPclBsYXRmb3JtKSB7XG4gICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIGFscmVhZHkgc2V0LCByZXR1cm4gaXRcbiAgICBpZiAoYXV0aE9wdGlvbiAmJiBPYmplY3QuaGFzT3duKGF1dGhPcHRpb24sIHNjb3BlUHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9uO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgYWRkIGl0XG4gICAgY29uc3Qgc2NvcGVzID0gQXJyYXkuaXNBcnJheShzY29wZXNPclBsYXRmb3JtKVxuICAgICAgICA/IHNjb3Blc09yUGxhdGZvcm1cbiAgICAgICAgOiBhaVBsYXRmb3JtU2NvcGUoc2NvcGVzT3JQbGF0Zm9ybSA/PyBcImdjcFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbc2NvcGVQcm9wZXJ0eV06IHNjb3BlcyxcbiAgICAgICAgLi4uKGF1dGhPcHRpb24gPz8ge30pLFxuICAgIH07XG59XG5leHBvcnRzLmVuc3VyZUF1dGhPcHRpb25TY29wZXMgPSBlbnN1cmVBdXRoT3B0aW9uU2NvcGVzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/chat_models.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogleBase = exports.ChatConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst chat_models_1 = __webpack_require__(/*! @langchain/core/language_models/chat_models */ \"(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst runnables_1 = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.cjs\");\nconst openai_tools_1 = __webpack_require__(/*! @langchain/core/output_parsers/openai_tools */ \"(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\");\nconst stream_1 = __webpack_require__(/*! @langchain/core/utils/stream */ \"(rsc)/./node_modules/@langchain/core/utils/stream.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nclass ChatConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.convertSystemMessageToHumanContent =\n            fields?.convertSystemMessageToHumanContent;\n    }\n    get useSystemInstruction() {\n        return typeof this.convertSystemMessageToHumanContent === \"boolean\"\n            ? !this.convertSystemMessageToHumanContent\n            : this.computeUseSystemInstruction;\n    }\n    get computeUseSystemInstruction() {\n        // This works on models from April 2024 and later\n        //   Vertex AI: gemini-1.5-pro and gemini-1.0-002 and later\n        //   AI Studio: gemini-1.5-pro-latest\n        if (this.modelFamily === \"palm\") {\n            return false;\n        }\n        else if (this.modelName === \"gemini-1.0-pro-001\") {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-1.0-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName === \"gemini-pro\" && this.platform === \"gai\") {\n            // on AI Studio gemini-pro is still pointing at gemini-1.0-pro-001\n            return false;\n        }\n        return true;\n    }\n    async formatContents(input, _parameters) {\n        const inputPromises = input.map((msg, i) => this.api.baseMessageToContent(msg, input[i - 1], this.useSystemInstruction));\n        const inputs = await Promise.all(inputPromises);\n        return inputs.reduce((acc, cur) => {\n            // Filter out the system content\n            if (cur.every((content) => content.role === \"system\")) {\n                return acc;\n            }\n            // Combine adjacent function messages\n            if (cur[0]?.role === \"function\" &&\n                acc.length > 0 &&\n                acc[acc.length - 1].role === \"function\") {\n                acc[acc.length - 1].parts = [\n                    ...acc[acc.length - 1].parts,\n                    ...cur[0].parts,\n                ];\n            }\n            else {\n                acc.push(...cur);\n            }\n            return acc;\n        }, []);\n    }\n    async formatSystemInstruction(input, _parameters) {\n        if (!this.useSystemInstruction) {\n            return {};\n        }\n        let ret = {};\n        for (let index = 0; index < input.length; index += 1) {\n            const message = input[index];\n            if (message._getType() === \"system\") {\n                // For system types, we only want it if it is the first message,\n                // if it appears anywhere else, it should be an error.\n                if (index === 0) {\n                    // eslint-disable-next-line prefer-destructuring\n                    ret = (await this.api.baseMessageToContent(message, undefined, true))[0];\n                }\n                else {\n                    throw new Error(\"System messages are only permitted as the first passed message.\");\n                }\n            }\n        }\n        return ret;\n    }\n}\nexports.ChatConnection = ChatConnection;\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogleBase extends chat_models_1.BaseChatModel {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set based on modelName\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // May intentionally be undefined, meaning to compute this.\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamUsage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        this.streamUsage = fields?.streamUsage ?? this.streamUsage;\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    getLsParams(options) {\n        const params = this.invocationParams(options);\n        return {\n            ls_provider: \"google_vertexai\",\n            ls_model_name: this.model,\n            ls_model_type: \"chat\",\n            ls_temperature: params.temperature ?? undefined,\n            ls_max_tokens: params.maxOutputTokens ?? undefined,\n            ls_stop: options.stop,\n        };\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new ChatConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new ChatConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    bindTools(tools, kwargs) {\n        return this.bind({ tools: (0, common_js_1.convertToGeminiTools)(tools), ...kwargs });\n    }\n    // Replace\n    _llmType() {\n        return \"chat_integration\";\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    invocationParams(options) {\n        return (0, common_js_1.copyAIModelParams)(this, options);\n    }\n    async _generate(messages, options, runManager) {\n        const parameters = this.invocationParams(options);\n        if (this.streaming) {\n            const stream = this._streamResponseChunks(messages, options, runManager);\n            let finalChunk = null;\n            for await (const chunk of stream) {\n                finalChunk = !finalChunk ? chunk : (0, stream_1.concat)(finalChunk, chunk);\n            }\n            if (!finalChunk) {\n                throw new Error(\"No chunks were returned from the stream.\");\n            }\n            return {\n                generations: [finalChunk],\n            };\n        }\n        const response = await this.connection.request(messages, parameters, options);\n        const ret = this.connection.api.safeResponseToChatResult(response, this.safetyHandler);\n        await runManager?.handleLLMNewToken(ret.generations[0].text);\n        return ret;\n    }\n    async *_streamResponseChunks(_messages, options, runManager) {\n        // Make the call as a streaming request\n        const parameters = this.invocationParams(options);\n        const response = await this.streamedConnection.request(_messages, parameters, options);\n        // Get the streaming parser of the response\n        const stream = response.data;\n        let usageMetadata;\n        // Loop until the end of the stream\n        // During the loop, yield each time we get a chunk from the streaming parser\n        // that is either available or added to the queue\n        while (!stream.streamDone) {\n            const output = await stream.nextChunk();\n            if (output &&\n                output.usageMetadata &&\n                this.streamUsage !== false &&\n                options.streamUsage !== false) {\n                usageMetadata = {\n                    input_tokens: output.usageMetadata.promptTokenCount,\n                    output_tokens: output.usageMetadata.candidatesTokenCount,\n                    total_tokens: output.usageMetadata.totalTokenCount,\n                };\n            }\n            const chunk = output !== null\n                ? this.connection.api.safeResponseToChatGeneration({ data: output }, this.safetyHandler)\n                : new outputs_1.ChatGenerationChunk({\n                    text: \"\",\n                    generationInfo: { finishReason: \"stop\" },\n                    message: new messages_1.AIMessageChunk({\n                        content: \"\",\n                        usage_metadata: usageMetadata,\n                    }),\n                });\n            yield chunk;\n            await runManager?.handleLLMNewToken(chunk.text);\n        }\n    }\n    /** @ignore */\n    _combineLLMOutput() {\n        return [];\n    }\n    withStructuredOutput(outputSchema, config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Google only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let outputParser;\n        let tools;\n        if (isZodSchema(schema)) {\n            const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(schema);\n            tools = [\n                {\n                    functionDeclarations: [\n                        {\n                            name: functionName,\n                            description: jsonSchema.description ?? \"A function available to call.\",\n                            parameters: jsonSchema,\n                        },\n                    ],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n                zodSchema: schema,\n            });\n        }\n        else {\n            let geminiFunctionDefinition;\n            if (typeof schema.name === \"string\" &&\n                typeof schema.parameters === \"object\" &&\n                schema.parameters != null) {\n                geminiFunctionDefinition = schema;\n                functionName = schema.name;\n            }\n            else {\n                geminiFunctionDefinition = {\n                    name: functionName,\n                    description: schema.description ?? \"\",\n                    parameters: schema,\n                };\n            }\n            tools = [\n                {\n                    functionDeclarations: [geminiFunctionDefinition],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n            });\n        }\n        const llm = this.bind({\n            tools,\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"ChatGoogleStructuredOutput\",\n            });\n        }\n        const parserAssign = runnables_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = runnables_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return runnables_1.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.ChatGoogleBase = ChatGoogleBase;\nfunction isZodSchema(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninput) {\n    // Check for a characteristic method of Zod schemas\n    return typeof input?.parse === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHlIQUE2QztBQUMzRSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLHFGQUEyQjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyx5SEFBNkM7QUFDNUUsaUJBQWlCLG1CQUFPLENBQUMsMkZBQThCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSxzQ0FBc0MsbUJBQU8sQ0FBQyxtSUFBc0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkUsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsY0FBYztBQUNuRjtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2NoYXRfbW9kZWxzLmNqcz80OTRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0R29vZ2xlQmFzZSA9IGV4cG9ydHMuQ2hhdENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBlbnZfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52XCIpO1xuY29uc3QgY2hhdF9tb2RlbHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIik7XG5jb25zdCBydW5uYWJsZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCIpO1xuY29uc3Qgb3BlbmFpX3Rvb2xzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29sc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9zdHJlYW1cIik7XG5jb25zdCBjb21tb25fanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbW1vbi5janNcIik7XG5jb25zdCBjb25uZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY29uc3QgZmFpbGVkX2hhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZhaWxlZF9oYW5kbGVyLmNqc1wiKTtcbmNvbnN0IHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqc1wiKTtcbmNsYXNzIENoYXRDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50ID1cbiAgICAgICAgICAgIGZpZWxkcz8uY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudDtcbiAgICB9XG4gICAgZ2V0IHVzZVN5c3RlbUluc3RydWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudCA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgID8gIXRoaXMuY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudFxuICAgICAgICAgICAgOiB0aGlzLmNvbXB1dGVVc2VTeXN0ZW1JbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVVc2VTeXN0ZW1JbnN0cnVjdGlvbigpIHtcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBvbiBtb2RlbHMgZnJvbSBBcHJpbCAyMDI0IGFuZCBsYXRlclxuICAgICAgICAvLyAgIFZlcnRleCBBSTogZ2VtaW5pLTEuNS1wcm8gYW5kIGdlbWluaS0xLjAtMDAyIGFuZCBsYXRlclxuICAgICAgICAvLyAgIEFJIFN0dWRpbzogZ2VtaW5pLTEuNS1wcm8tbGF0ZXN0XG4gICAgICAgIGlmICh0aGlzLm1vZGVsRmFtaWx5ID09PSBcInBhbG1cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWxOYW1lID09PSBcImdlbWluaS0xLjAtcHJvLTAwMVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS1wcm8tdmlzaW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS0xLjAtcHJvLXZpc2lvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZWxOYW1lID09PSBcImdlbWluaS1wcm9cIiAmJiB0aGlzLnBsYXRmb3JtID09PSBcImdhaVwiKSB7XG4gICAgICAgICAgICAvLyBvbiBBSSBTdHVkaW8gZ2VtaW5pLXBybyBpcyBzdGlsbCBwb2ludGluZyBhdCBnZW1pbmktMS4wLXByby0wMDFcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0Q29udGVudHMoaW5wdXQsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGlucHV0UHJvbWlzZXMgPSBpbnB1dC5tYXAoKG1zZywgaSkgPT4gdGhpcy5hcGkuYmFzZU1lc3NhZ2VUb0NvbnRlbnQobXNnLCBpbnB1dFtpIC0gMV0sIHRoaXMudXNlU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRQcm9taXNlcyk7XG4gICAgICAgIHJldHVybiBpbnB1dHMucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgc3lzdGVtIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChjdXIuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSA9PT0gXCJzeXN0ZW1cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tYmluZSBhZGphY2VudCBmdW5jdGlvbiBtZXNzYWdlc1xuICAgICAgICAgICAgaWYgKGN1clswXT8ucm9sZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgYWNjLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBhY2NbYWNjLmxlbmd0aCAtIDFdLnJvbGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0ucGFydHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjY1thY2MubGVuZ3RoIC0gMV0ucGFydHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmN1clswXS5wYXJ0cyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goLi4uY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0U3lzdGVtSW5zdHJ1Y3Rpb24oaW5wdXQsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy51c2VTeXN0ZW1JbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGlucHV0Lmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlucHV0W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igc3lzdGVtIHR5cGVzLCB3ZSBvbmx5IHdhbnQgaXQgaWYgaXQgaXMgdGhlIGZpcnN0IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgYXBwZWFycyBhbnl3aGVyZSBlbHNlLCBpdCBzaG91bGQgYmUgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgICByZXQgPSAoYXdhaXQgdGhpcy5hcGkuYmFzZU1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSwgdW5kZWZpbmVkLCB0cnVlKSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gbWVzc2FnZXMgYXJlIG9ubHkgcGVybWl0dGVkIGFzIHRoZSBmaXJzdCBwYXNzZWQgbWVzc2FnZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0Q29ubmVjdGlvbiA9IENoYXRDb25uZWN0aW9uO1xuLyoqXG4gKiBJbnRlZ3JhdGlvbiB3aXRoIGEgR29vZ2xlIGNoYXQgbW9kZWwuXG4gKi9cbmNsYXNzIENoYXRHb29nbGVCYXNlIGV4dGVuZHMgY2hhdF9tb2RlbHNfMS5CYXNlQ2hhdE1vZGVsIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRHb29nbGVcIjtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoT3B0aW9uczogXCJHT09HTEVfQVVUSF9PUFRJT05TXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigoMCwgZmFpbGVkX2hhbmRsZXJfanNfMS5lbnN1cmVQYXJhbXMpKGZpZWxkcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBiYXNlZCBvbiBtb2RlbE5hbWVcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImdlbWluaS1wcm9cIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGVyYXR1cmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDAuN1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4T3V0cHV0VG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDI0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BQXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcEtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wU2VxdWVuY2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FmZXR5U2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYXkgaW50ZW50aW9uYWxseSBiZSB1bmRlZmluZWQsIG1lYW5pbmcgdG8gY29tcHV0ZSB0aGlzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNhZmV0eUhhbmRsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtVXNhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtZWRDb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBjb21tb25fanNfMS5jb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8pKGZpZWxkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZXR5SGFuZGxlciA9XG4gICAgICAgICAgICBmaWVsZHM/LnNhZmV0eUhhbmRsZXIgPz8gbmV3IGdlbWluaV9qc18xLkRlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtVXNhZ2UgPSBmaWVsZHM/LnN0cmVhbVVzYWdlID8/IHRoaXMuc3RyZWFtVXNhZ2U7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuYnVpbGRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgdGhpcy5idWlsZENvbm5lY3Rpb24oZmllbGRzID8/IHt9LCBjbGllbnQpO1xuICAgIH1cbiAgICBnZXRMc1BhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBcImdvb2dsZV92ZXJ0ZXhhaVwiLFxuICAgICAgICAgICAgbHNfbW9kZWxfbmFtZTogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGxzX21vZGVsX3R5cGU6IFwiY2hhdFwiLFxuICAgICAgICAgICAgbHNfdGVtcGVyYXR1cmU6IHBhcmFtcy50ZW1wZXJhdHVyZSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBsc19tYXhfdG9rZW5zOiBwYXJhbXMubWF4T3V0cHV0VG9rZW5zID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkFwaUtleUdvb2dsZUF1dGgoYXBpS2V5KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXkoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM/LmFwaUtleSA/PyAoMCwgZW52XzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJHT09HTEVfQVBJX0tFWVwiKTtcbiAgICB9XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYnVpbGRBcGlLZXkoZmllbGRzKTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ29ubmVjdGlvbihmaWVsZHMsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ2hhdENvbm5lY3Rpb24oeyAuLi5maWVsZHMsIC4uLnRoaXMgfSwgdGhpcy5jYWxsZXIsIGNsaWVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnN0cmVhbWVkQ29ubmVjdGlvbiA9IG5ldyBDaGF0Q29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgY2xpZW50LCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0IHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnBsYXRmb3JtO1xuICAgIH1cbiAgICBiaW5kVG9vbHModG9vbHMsIGt3YXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKHsgdG9vbHM6ICgwLCBjb21tb25fanNfMS5jb252ZXJ0VG9HZW1pbmlUb29scykodG9vbHMpLCAuLi5rd2FyZ3MgfSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VcbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiY2hhdF9pbnRlZ3JhdGlvblwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbnZva2UgdGhlIG1vZGVsXG4gICAgICovXG4gICAgaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgY29tbW9uX2pzXzEuY29weUFJTW9kZWxQYXJhbXMpKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGUobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgICAgICBsZXQgZmluYWxDaHVuayA9IG51bGw7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSAhZmluYWxDaHVuayA/IGNodW5rIDogKDAsIHN0cmVhbV8xLmNvbmNhdCkoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaW5hbENodW5rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2h1bmtzIHdlcmUgcmV0dXJuZWQgZnJvbSB0aGUgc3RyZWFtLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtmaW5hbENodW5rXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucmVxdWVzdChtZXNzYWdlcywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuY29ubmVjdGlvbi5hcGkuc2FmZVJlc3BvbnNlVG9DaGF0UmVzdWx0KHJlc3BvbnNlLCB0aGlzLnNhZmV0eUhhbmRsZXIpO1xuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXQuZ2VuZXJhdGlvbnNbMF0udGV4dCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoX21lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIGNhbGwgYXMgYSBzdHJlYW1pbmcgcmVxdWVzdFxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtZWRDb25uZWN0aW9uLnJlcXVlc3QoX21lc3NhZ2VzLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbiAgICAgICAgLy8gR2V0IHRoZSBzdHJlYW1pbmcgcGFyc2VyIG9mIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCBzdHJlYW0gPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBsZXQgdXNhZ2VNZXRhZGF0YTtcbiAgICAgICAgLy8gTG9vcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICAgICAgLy8gRHVyaW5nIHRoZSBsb29wLCB5aWVsZCBlYWNoIHRpbWUgd2UgZ2V0IGEgY2h1bmsgZnJvbSB0aGUgc3RyZWFtaW5nIHBhcnNlclxuICAgICAgICAvLyB0aGF0IGlzIGVpdGhlciBhdmFpbGFibGUgb3IgYWRkZWQgdG8gdGhlIHF1ZXVlXG4gICAgICAgIHdoaWxlICghc3RyZWFtLnN0cmVhbURvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHN0cmVhbS5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICBvdXRwdXQudXNhZ2VNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVXNhZ2UgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJlYW1Vc2FnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB1c2FnZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLnByb21wdFRva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBvdXRwdXQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29ubmVjdGlvbi5hcGkuc2FmZVJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbih7IGRhdGE6IG91dHB1dCB9LCB0aGlzLnNhZmV0eUhhbmRsZXIpXG4gICAgICAgICAgICAgICAgOiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogeyBmaW5pc2hSZWFzb246IFwic3RvcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKGNodW5rLnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgX2NvbWJpbmVMTE1PdXRwdXQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnPy5uYW1lO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBjb25maWc/Lm1ldGhvZDtcbiAgICAgICAgY29uc3QgaW5jbHVkZVJhdyA9IGNvbmZpZz8uaW5jbHVkZVJhdztcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJqc29uTW9kZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvb2dsZSBvbmx5IHN1cHBvcnRzIFwiZnVuY3Rpb25DYWxsaW5nXCIgYXMgYSBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG5hbWUgPz8gXCJleHRyYWN0XCI7XG4gICAgICAgIGxldCBvdXRwdXRQYXJzZXI7XG4gICAgICAgIGxldCB0b29scztcbiAgICAgICAgaWYgKGlzWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TY2hlbWEgPSAoMCwgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEuem9kVG9HZW1pbmlQYXJhbWV0ZXJzKShzY2hlbWEpO1xuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjoganNvblNjaGVtYS5kZXNjcmlwdGlvbiA/PyBcIkEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoganNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvdXRwdXRQYXJzZXIgPSBuZXcgb3BlbmFpX3Rvb2xzXzEuSnNvbk91dHB1dEtleVRvb2xzUGFyc2VyKHtcbiAgICAgICAgICAgICAgICByZXR1cm5TaW5nbGU6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5TmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZ2VtaW5pRnVuY3Rpb25EZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzY2hlbWEucGFyYW1ldGVycyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHNjaGVtYS5wYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZW1pbmlGdW5jdGlvbkRlZmluaXRpb24gPSBzY2hlbWE7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lID0gc2NoZW1hLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW1pbmlGdW5jdGlvbkRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYS5kZXNjcmlwdGlvbiA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtnZW1pbmlGdW5jdGlvbkRlZmluaXRpb25dLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3V0cHV0UGFyc2VyID0gbmV3IG9wZW5haV90b29sc18xLkpzb25PdXRwdXRLZXlUb29sc1BhcnNlcih7XG4gICAgICAgICAgICAgICAgcmV0dXJuU2luZ2xlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleU5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxsbSA9IHRoaXMuYmluZCh7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jbHVkZVJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGxsbS5waXBlKG91dHB1dFBhcnNlcikud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogXCJDaGF0R29vZ2xlU3RydWN0dXJlZE91dHB1dFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyQXNzaWduID0gcnVubmFibGVzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHBhcnNlZDogKGlucHV0LCBjb25maWcpID0+IG91dHB1dFBhcnNlci5pbnZva2UoaW5wdXQucmF3LCBjb25maWcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VyTm9uZSA9IHJ1bm5hYmxlc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIHBhcnNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFdpdGhGYWxsYmFjayA9IHBhcnNlckFzc2lnbi53aXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIGZhbGxiYWNrczogW3BhcnNlck5vbmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlc18xLlJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmF3OiBsbG0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VkV2l0aEZhbGxiYWNrLFxuICAgICAgICBdKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFJ1bm5hYmxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdEdvb2dsZUJhc2UgPSBDaGF0R29vZ2xlQmFzZTtcbmZ1bmN0aW9uIGlzWm9kU2NoZW1hKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmlucHV0KSB7XG4gICAgLy8gQ2hlY2sgZm9yIGEgY2hhcmFjdGVyaXN0aWMgbWV0aG9kIG9mIFpvZCBzY2hlbWFzXG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dD8ucGFyc2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/connection.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractGoogleLLMConnection = exports.GoogleAIConnection = exports.GoogleRawConnection = exports.GoogleHostConnection = exports.GoogleConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nconst index_js_1 = __webpack_require__(/*! ./utils/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\");\nclass GoogleConnection {\n    constructor(caller, client, streaming) {\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = caller;\n        this.client = client;\n        this.streaming = streaming ?? false;\n    }\n    async _clientInfoHeaders() {\n        const { userAgent, clientLibraryVersion } = await this._getClientInfo();\n        return {\n            \"User-Agent\": userAgent,\n            \"Client-Info\": clientLibraryVersion,\n        };\n    }\n    async _getClientInfo() {\n        const env = await (0, env_1.getRuntimeEnvironment)();\n        const langchain = env?.library ?? \"langchain-js\";\n        // TODO: Add an API for getting the current LangChain version\n        const langchainVersion = \"0\";\n        const moduleName = await this._moduleName();\n        let clientLibraryVersion = `${langchain}/${langchainVersion}`;\n        if (moduleName && moduleName.length) {\n            clientLibraryVersion = `${clientLibraryVersion}-${moduleName}`;\n        }\n        return {\n            userAgent: clientLibraryVersion,\n            clientLibraryVersion: `${langchainVersion}-${moduleName}`,\n        };\n    }\n    async _moduleName() {\n        return this.constructor.name;\n    }\n    async additionalHeaders() {\n        return {};\n    }\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const url = await this.buildUrl();\n        const method = this.buildMethod();\n        const infoHeaders = (await this._clientInfoHeaders()) ?? {};\n        const additionalHeaders = (await this.additionalHeaders()) ?? {};\n        const headers = {\n            ...infoHeaders,\n            ...additionalHeaders,\n            ...requestHeaders,\n        };\n        const opts = {\n            url,\n            method,\n            headers,\n        };\n        if (data && method === \"POST\") {\n            opts.data = data;\n        }\n        if (this.streaming) {\n            opts.responseType = \"stream\";\n        }\n        else {\n            opts.responseType = \"json\";\n        }\n        return opts;\n    }\n    async _request(data, options, requestHeaders = {}) {\n        const opts = await this._buildOpts(data, options, requestHeaders);\n        const callResponse = await this.caller.callWithOptions({ signal: options?.signal }, async () => this.client.request(opts));\n        const response = callResponse; // Done for typecast safety, I guess\n        return response;\n    }\n}\nexports.GoogleConnection = GoogleConnection;\nclass GoogleHostConnection extends GoogleConnection {\n    constructor(fields, caller, client, streaming) {\n        super(caller, client, streaming);\n        // This does not default to a value intentionally.\n        // Use the \"platform\" getter if you need this.\n        Object.defineProperty(this, \"platformType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"endpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"us-central1-aiplatform.googleapis.com\"\n        });\n        Object.defineProperty(this, \"location\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"us-central1\"\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1\"\n        });\n        this.caller = caller;\n        this.platformType = fields?.platformType;\n        this.endpoint = fields?.endpoint ?? this.endpoint;\n        this.location = fields?.location ?? this.location;\n        this.apiVersion = fields?.apiVersion ?? this.apiVersion;\n        this.client = client;\n    }\n    get platform() {\n        return this.platformType ?? this.computedPlatformType;\n    }\n    get computedPlatformType() {\n        return \"gcp\";\n    }\n    buildMethod() {\n        return \"POST\";\n    }\n}\nexports.GoogleHostConnection = GoogleHostConnection;\nclass GoogleRawConnection extends GoogleHostConnection {\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const opts = await super._buildOpts(data, _options, requestHeaders);\n        opts.responseType = \"blob\";\n        return opts;\n    }\n}\nexports.GoogleRawConnection = GoogleRawConnection;\nclass GoogleAIConnection extends GoogleHostConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        }); // FIXME: Make this a real type\n        this.client = client;\n        this.modelName = fields?.model ?? fields?.modelName ?? this.model;\n        this.model = this.modelName;\n        this.api = (0, index_js_1.getGeminiAPI)(fields);\n    }\n    get modelFamily() {\n        if (this.model.startsWith(\"gemini\")) {\n            return \"gemini\";\n        }\n        else {\n            return null;\n        }\n    }\n    get computedPlatformType() {\n        if (this.client.clientType === \"apiKey\") {\n            return \"gai\";\n        }\n        else {\n            return \"gcp\";\n        }\n    }\n    async buildUrlGenerativeLanguage() {\n        const method = await this.buildUrlMethod();\n        const url = `https://generativelanguage.googleapis.com/${this.apiVersion}/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrlVertex() {\n        const projectId = await this.client.getProjectId();\n        const method = await this.buildUrlMethod();\n        const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/publishers/google/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrl() {\n        switch (this.platform) {\n            case \"gai\":\n                return this.buildUrlGenerativeLanguage();\n            default:\n                return this.buildUrlVertex();\n        }\n    }\n    async request(input, parameters, options) {\n        const data = await this.formatData(input, parameters);\n        const response = await this._request(data, options);\n        return response;\n    }\n}\nexports.GoogleAIConnection = GoogleAIConnection;\nclass AbstractGoogleLLMConnection extends GoogleAIConnection {\n    async buildUrlMethodGemini() {\n        return this.streaming ? \"streamGenerateContent\" : \"generateContent\";\n    }\n    async buildUrlMethod() {\n        switch (this.modelFamily) {\n            case \"gemini\":\n                return this.buildUrlMethodGemini();\n            default:\n                throw new Error(`Unknown model family: ${this.modelFamily}`);\n        }\n    }\n    formatGenerationConfig(_input, parameters) {\n        return {\n            temperature: parameters.temperature,\n            topK: parameters.topK,\n            topP: parameters.topP,\n            maxOutputTokens: parameters.maxOutputTokens,\n            stopSequences: parameters.stopSequences,\n            responseMimeType: parameters.responseMimeType,\n        };\n    }\n    formatSafetySettings(_input, parameters) {\n        return parameters.safetySettings ?? [];\n    }\n    async formatSystemInstruction(_input, _parameters) {\n        return {};\n    }\n    structuredToolToFunctionDeclaration(tool) {\n        const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n        return {\n            name: tool.name,\n            description: tool.description ?? `A function available to call.`,\n            parameters: jsonSchema,\n        };\n    }\n    structuredToolsToGeminiTools(tools) {\n        return [\n            {\n                functionDeclarations: tools.map(this.structuredToolToFunctionDeclaration),\n            },\n        ];\n    }\n    formatTools(_input, parameters) {\n        const tools = parameters?.tools;\n        if (!tools || tools.length === 0) {\n            return [];\n        }\n        if (tools.every(function_calling_1.isLangChainTool)) {\n            return this.structuredToolsToGeminiTools(tools);\n        }\n        else {\n            if (tools.length === 1 &&\n                (!(\"functionDeclarations\" in tools[0]) ||\n                    !tools[0].functionDeclarations?.length)) {\n                return [];\n            }\n            return tools;\n        }\n    }\n    formatToolConfig(parameters) {\n        if (!parameters.tool_choice || typeof parameters.tool_choice !== \"string\") {\n            return undefined;\n        }\n        return {\n            functionCallingConfig: {\n                mode: parameters.tool_choice,\n                allowedFunctionNames: parameters.allowed_function_names,\n            },\n        };\n    }\n    async formatData(input, parameters) {\n        const contents = await this.formatContents(input, parameters);\n        const generationConfig = this.formatGenerationConfig(input, parameters);\n        const tools = this.formatTools(input, parameters);\n        const toolConfig = this.formatToolConfig(parameters);\n        const safetySettings = this.formatSafetySettings(input, parameters);\n        const systemInstruction = await this.formatSystemInstruction(input, parameters);\n        const ret = {\n            contents,\n            generationConfig,\n        };\n        if (tools && tools.length) {\n            ret.tools = tools;\n        }\n        if (toolConfig) {\n            ret.toolConfig = toolConfig;\n        }\n        if (safetySettings && safetySettings.length) {\n            ret.safetySettings = safetySettings;\n        }\n        if (systemInstruction?.role &&\n            systemInstruction?.parts &&\n            systemInstruction?.parts?.length) {\n            ret.systemInstruction = systemInstruction;\n        }\n        return ret;\n    }\n}\nexports.AbstractGoogleLLMConnection = AbstractGoogleLLMConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY29ubmVjdGlvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsd0JBQXdCO0FBQ3hKLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsK0dBQXdDO0FBQzNFLHNDQUFzQyxtQkFBTyxDQUFDLG1JQUFzQztBQUNwRixtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGlCQUFpQjtBQUNwRTtBQUNBLHNDQUFzQyxxQkFBcUIsR0FBRyxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUIsR0FBRyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxpRUFBaUUseUJBQXlCO0FBQzFGLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCLFVBQVUsV0FBVyxHQUFHLE9BQU87QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjLEdBQUcsZ0JBQWdCLFlBQVksVUFBVSxhQUFhLGNBQWMsNEJBQTRCLFdBQVcsR0FBRyxPQUFPO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY29ubmVjdGlvbi5janM/YTcwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVBSUNvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZVJhd0Nvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUhvc3RDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IGZ1bmN0aW9uX2NhbGxpbmdfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZnVuY3Rpb25fY2FsbGluZ1wiKTtcbmNvbnN0IHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9pbmRleC5janNcIik7XG5jbGFzcyBHb29nbGVDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gY2FsbGVyO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5zdHJlYW1pbmcgPSBzdHJlYW1pbmcgPz8gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIF9jbGllbnRJbmZvSGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgeyB1c2VyQWdlbnQsIGNsaWVudExpYnJhcnlWZXJzaW9uIH0gPSBhd2FpdCB0aGlzLl9nZXRDbGllbnRJbmZvKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogdXNlckFnZW50LFxuICAgICAgICAgICAgXCJDbGllbnQtSW5mb1wiOiBjbGllbnRMaWJyYXJ5VmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2dldENsaWVudEluZm8oKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGF3YWl0ICgwLCBlbnZfMS5nZXRSdW50aW1lRW52aXJvbm1lbnQpKCk7XG4gICAgICAgIGNvbnN0IGxhbmdjaGFpbiA9IGVudj8ubGlicmFyeSA/PyBcImxhbmdjaGFpbi1qc1wiO1xuICAgICAgICAvLyBUT0RPOiBBZGQgYW4gQVBJIGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IExhbmdDaGFpbiB2ZXJzaW9uXG4gICAgICAgIGNvbnN0IGxhbmdjaGFpblZlcnNpb24gPSBcIjBcIjtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGF3YWl0IHRoaXMuX21vZHVsZU5hbWUoKTtcbiAgICAgICAgbGV0IGNsaWVudExpYnJhcnlWZXJzaW9uID0gYCR7bGFuZ2NoYWlufS8ke2xhbmdjaGFpblZlcnNpb259YDtcbiAgICAgICAgaWYgKG1vZHVsZU5hbWUgJiYgbW9kdWxlTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNsaWVudExpYnJhcnlWZXJzaW9uID0gYCR7Y2xpZW50TGlicmFyeVZlcnNpb259LSR7bW9kdWxlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IGNsaWVudExpYnJhcnlWZXJzaW9uLFxuICAgICAgICAgICAgY2xpZW50TGlicmFyeVZlcnNpb246IGAke2xhbmdjaGFpblZlcnNpb259LSR7bW9kdWxlTmFtZX1gLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfbW9kdWxlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgYXN5bmMgYWRkaXRpb25hbEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmJ1aWxkVXJsKCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuYnVpbGRNZXRob2QoKTtcbiAgICAgICAgY29uc3QgaW5mb0hlYWRlcnMgPSAoYXdhaXQgdGhpcy5fY2xpZW50SW5mb0hlYWRlcnMoKSkgPz8ge307XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxIZWFkZXJzID0gKGF3YWl0IHRoaXMuYWRkaXRpb25hbEhlYWRlcnMoKSkgPz8ge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi5pbmZvSGVhZGVycyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxIZWFkZXJzLFxuICAgICAgICAgICAgLi4ucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YSAmJiBtZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICBvcHRzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgICAgICAgb3B0cy5yZXNwb25zZVR5cGUgPSBcInN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5yZXNwb25zZVR5cGUgPSBcImpzb25cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gICAgYXN5bmMgX3JlcXVlc3QoZGF0YSwgb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5fYnVpbGRPcHRzKGRhdGEsIG9wdGlvbnMsIHJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgY29uc3QgY2FsbFJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbFdpdGhPcHRpb25zKHsgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgfSwgYXN5bmMgKCkgPT4gdGhpcy5jbGllbnQucmVxdWVzdChvcHRzKSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY2FsbFJlc3BvbnNlOyAvLyBEb25lIGZvciB0eXBlY2FzdCBzYWZldHksIEkgZ3Vlc3NcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ29ubmVjdGlvbiA9IEdvb2dsZUNvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVIb3N0Q29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZUNvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBzdXBlcihjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKTtcbiAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBkZWZhdWx0IHRvIGEgdmFsdWUgaW50ZW50aW9uYWxseS5cbiAgICAgICAgLy8gVXNlIHRoZSBcInBsYXRmb3JtXCIgZ2V0dGVyIGlmIHlvdSBuZWVkIHRoaXMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsYXRmb3JtVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRwb2ludFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ1cy1jZW50cmFsMS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInVzLWNlbnRyYWwxXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwidjFcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBjYWxsZXI7XG4gICAgICAgIHRoaXMucGxhdGZvcm1UeXBlID0gZmllbGRzPy5wbGF0Zm9ybVR5cGU7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBmaWVsZHM/LmVuZHBvaW50ID8/IHRoaXMuZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBmaWVsZHM/LmxvY2F0aW9uID8/IHRoaXMubG9jYXRpb247XG4gICAgICAgIHRoaXMuYXBpVmVyc2lvbiA9IGZpZWxkcz8uYXBpVmVyc2lvbiA/PyB0aGlzLmFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXRmb3JtVHlwZSA/PyB0aGlzLmNvbXB1dGVkUGxhdGZvcm1UeXBlO1xuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRQbGF0Zm9ybVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdjcFwiO1xuICAgIH1cbiAgICBidWlsZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlSG9zdENvbm5lY3Rpb24gPSBHb29nbGVIb3N0Q29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZVJhd0Nvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVIb3N0Q29ubmVjdGlvbiB7XG4gICAgYXN5bmMgX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgc3VwZXIuX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICBvcHRzLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZVJhd0Nvbm5lY3Rpb24gPSBHb29nbGVSYXdDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlQUlDb25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pOyAvLyBGSVhNRTogTWFrZSB0aGlzIGEgcmVhbCB0eXBlXG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsTmFtZSA9IGZpZWxkcz8ubW9kZWwgPz8gZmllbGRzPy5tb2RlbE5hbWUgPz8gdGhpcy5tb2RlbDtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMubW9kZWxOYW1lO1xuICAgICAgICB0aGlzLmFwaSA9ICgwLCBpbmRleF9qc18xLmdldEdlbWluaUFQSSkoZmllbGRzKTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsRmFtaWx5KCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5zdGFydHNXaXRoKFwiZ2VtaW5pXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJnZW1pbmlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb21wdXRlZFBsYXRmb3JtVHlwZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50LmNsaWVudFR5cGUgPT09IFwiYXBpS2V5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcImdhaVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZ2NwXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmxHZW5lcmF0aXZlTGFuZ3VhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuYnVpbGRVcmxNZXRob2QoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tLyR7dGhpcy5hcGlWZXJzaW9ufS9tb2RlbHMvJHt0aGlzLm1vZGVsfToke21ldGhvZH1gO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybFZlcnRleCgpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0UHJvamVjdElkKCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IHRoaXMuYnVpbGRVcmxNZXRob2QoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHt0aGlzLmVuZHBvaW50fS8ke3RoaXMuYXBpVmVyc2lvbn0vcHJvamVjdHMvJHtwcm9qZWN0SWR9L2xvY2F0aW9ucy8ke3RoaXMubG9jYXRpb259L3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke3RoaXMubW9kZWx9OiR7bWV0aG9kfWA7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGxhdGZvcm0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJnYWlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybEdlbmVyYXRpdmVMYW5ndWFnZSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybFZlcnRleCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QoaW5wdXQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZm9ybWF0RGF0YShpbnB1dCwgcGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVxdWVzdChkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQUlDb25uZWN0aW9uID0gR29vZ2xlQUlDb25uZWN0aW9uO1xuY2xhc3MgQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlQUlDb25uZWN0aW9uIHtcbiAgICBhc3luYyBidWlsZFVybE1ldGhvZEdlbWluaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtaW5nID8gXCJzdHJlYW1HZW5lcmF0ZUNvbnRlbnRcIiA6IFwiZ2VuZXJhdGVDb250ZW50XCI7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsTWV0aG9kKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWxGYW1pbHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZW1pbmlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybE1ldGhvZEdlbWluaSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbW9kZWwgZmFtaWx5OiAke3RoaXMubW9kZWxGYW1pbHl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9ybWF0R2VuZXJhdGlvbkNvbmZpZyhfaW5wdXQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBwYXJhbWV0ZXJzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgdG9wSzogcGFyYW1ldGVycy50b3BLLFxuICAgICAgICAgICAgdG9wUDogcGFyYW1ldGVycy50b3BQLFxuICAgICAgICAgICAgbWF4T3V0cHV0VG9rZW5zOiBwYXJhbWV0ZXJzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgIHN0b3BTZXF1ZW5jZXM6IHBhcmFtZXRlcnMuc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgIHJlc3BvbnNlTWltZVR5cGU6IHBhcmFtZXRlcnMucmVzcG9uc2VNaW1lVHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9ybWF0U2FmZXR5U2V0dGluZ3MoX2lucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnNhZmV0eVNldHRpbmdzID8/IFtdO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXRTeXN0ZW1JbnN0cnVjdGlvbihfaW5wdXQsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgc3RydWN0dXJlZFRvb2xUb0Z1bmN0aW9uRGVjbGFyYXRpb24odG9vbCkge1xuICAgICAgICBjb25zdCBqc29uU2NoZW1hID0gKDAsIHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xLnpvZFRvR2VtaW5pUGFyYW1ldGVycykodG9vbC5zY2hlbWEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24gPz8gYEEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuYCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0cnVjdHVyZWRUb29sc1RvR2VtaW5pVG9vbHModG9vbHMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogdG9vbHMubWFwKHRoaXMuc3RydWN0dXJlZFRvb2xUb0Z1bmN0aW9uRGVjbGFyYXRpb24pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZm9ybWF0VG9vbHMoX2lucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gcGFyYW1ldGVycz8udG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMgfHwgdG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xzLmV2ZXJ5KGZ1bmN0aW9uX2NhbGxpbmdfMS5pc0xhbmdDaGFpblRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkVG9vbHNUb0dlbWluaVRvb2xzKHRvb2xzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b29scy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAoIShcImZ1bmN0aW9uRGVjbGFyYXRpb25zXCIgaW4gdG9vbHNbMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICF0b29sc1swXS5mdW5jdGlvbkRlY2xhcmF0aW9ucz8ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29scztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JtYXRUb29sQ29uZmlnKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlIHx8IHR5cGVvZiBwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICBtb2RlOiBwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBwYXJhbWV0ZXJzLmFsbG93ZWRfZnVuY3Rpb25fbmFtZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXREYXRhKGlucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5mb3JtYXRDb250ZW50cyhpbnB1dCwgcGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWcgPSB0aGlzLmZvcm1hdEdlbmVyYXRpb25Db25maWcoaW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCB0b29scyA9IHRoaXMuZm9ybWF0VG9vbHMoaW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCB0b29sQ29uZmlnID0gdGhpcy5mb3JtYXRUb29sQ29uZmlnKHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBzYWZldHlTZXR0aW5ncyA9IHRoaXMuZm9ybWF0U2FmZXR5U2V0dGluZ3MoaW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBzeXN0ZW1JbnN0cnVjdGlvbiA9IGF3YWl0IHRoaXMuZm9ybWF0U3lzdGVtSW5zdHJ1Y3Rpb24oaW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgIGdlbmVyYXRpb25Db25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0b29scyAmJiB0b29scy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldC50b29scyA9IHRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sQ29uZmlnKSB7XG4gICAgICAgICAgICByZXQudG9vbENvbmZpZyA9IHRvb2xDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhZmV0eVNldHRpbmdzICYmIHNhZmV0eVNldHRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LnNhZmV0eVNldHRpbmdzID0gc2FmZXR5U2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5c3RlbUluc3RydWN0aW9uPy5yb2xlICYmXG4gICAgICAgICAgICBzeXN0ZW1JbnN0cnVjdGlvbj8ucGFydHMgJiZcbiAgICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uPy5wYXJ0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQuc3lzdGVtSW5zdHJ1Y3Rpb24gPSBzeXN0ZW1JbnN0cnVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uID0gQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/embeddings.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGoogleEmbeddings = void 0;\nconst embeddings_1 = __webpack_require__(/*! @langchain/core/embeddings */ \"(rsc)/./node_modules/@langchain/core/embeddings.cjs\");\nconst chunk_array_1 = __webpack_require__(/*! @langchain/core/utils/chunk_array */ \"(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass EmbeddingsConnection extends connection_js_1.GoogleAIConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async buildUrlMethod() {\n        return \"predict\";\n    }\n    async formatData(input, parameters) {\n        return {\n            instances: input,\n            parameters,\n        };\n    }\n}\n/**\n * Enables calls to Google APIs for generating\n * text embeddings.\n */\nclass BaseGoogleEmbeddings extends embeddings_1.Embeddings {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.model = fields.model;\n        this.connection = new EmbeddingsConnection({ ...fields, ...this }, this.caller, this.buildClient(fields), false);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    /**\n     * Takes an array of documents as input and returns a promise that\n     * resolves to a 2D array of embeddings for each document. It splits the\n     * documents into chunks and makes requests to the Google Vertex AI API to\n     * generate embeddings.\n     * @param documents An array of documents to be embedded.\n     * @returns A promise that resolves to a 2D array of embeddings for each document.\n     */\n    async embedDocuments(documents) {\n        const instanceChunks = (0, chunk_array_1.chunkArray)(documents.map((document) => ({\n            content: document,\n        })), 5); // Vertex AI accepts max 5 instances per prediction\n        const parameters = {};\n        const options = {};\n        const responses = await Promise.all(instanceChunks.map((instances) => this.connection.request(instances, parameters, options)));\n        const result = responses\n            ?.map((response) => response?.data?.predictions?.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (result) => result.embeddings?.values) ?? [])\n            .flat() ?? [];\n        return result;\n    }\n    /**\n     * Takes a document as input and returns a promise that resolves to an\n     * embedding for the document. It calls the embedDocuments method with the\n     * document as the input.\n     * @param document A document to be embedded.\n     * @returns A promise that resolves to an embedding for the document.\n     */\n    async embedQuery(document) {\n        const data = await this.embedDocuments([document]);\n        return data[0];\n    }\n}\nexports.BaseGoogleEmbeddings = BaseGoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxxR0FBbUM7QUFDakUsY0FBYyxtQkFBTyxDQUFDLHFGQUEyQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxREFBcUQsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9lbWJlZGRpbmdzLmNqcz82YTJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlR29vZ2xlRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGVtYmVkZGluZ3NfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvZW1iZWRkaW5nc1wiKTtcbmNvbnN0IGNodW5rX2FycmF5XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2NodW5rX2FycmF5XCIpO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IGNvbm5lY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24uY2pzXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4vYXV0aC5janNcIik7XG5jbGFzcyBFbWJlZGRpbmdzQ29ubmVjdGlvbiBleHRlbmRzIGNvbm5lY3Rpb25fanNfMS5Hb29nbGVBSUNvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gXCJwcmVkaWN0XCI7XG4gICAgfVxuICAgIGFzeW5jIGZvcm1hdERhdGEoaW5wdXQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbmNlczogaW5wdXQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogRW5hYmxlcyBjYWxscyB0byBHb29nbGUgQVBJcyBmb3IgZ2VuZXJhdGluZ1xuICogdGV4dCBlbWJlZGRpbmdzLlxuICovXG5jbGFzcyBCYXNlR29vZ2xlRW1iZWRkaW5ncyBleHRlbmRzIGVtYmVkZGluZ3NfMS5FbWJlZGRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29ubmVjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsID0gZmllbGRzLm1vZGVsO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgRW1iZWRkaW5nc0Nvbm5lY3Rpb24oeyAuLi5maWVsZHMsIC4uLnRoaXMgfSwgdGhpcy5jYWxsZXIsIHRoaXMuYnVpbGRDbGllbnQoZmllbGRzKSwgZmFsc2UpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleUNsaWVudChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuQXBpS2V5R29vZ2xlQXV0aChhcGlLZXkpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleShmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcz8uYXBpS2V5ID8/ICgwLCBlbnZfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkdPT0dMRV9BUElfS0VZXCIpO1xuICAgIH1cbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5idWlsZEFwaUtleShmaWVsZHMpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFwaUtleUNsaWVudChhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIGFzIGlucHV0IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgdG8gYSAyRCBhcnJheSBvZiBlbWJlZGRpbmdzIGZvciBlYWNoIGRvY3VtZW50LiBJdCBzcGxpdHMgdGhlXG4gICAgICogZG9jdW1lbnRzIGludG8gY2h1bmtzIGFuZCBtYWtlcyByZXF1ZXN0cyB0byB0aGUgR29vZ2xlIFZlcnRleCBBSSBBUEkgdG9cbiAgICAgKiBnZW5lcmF0ZSBlbWJlZGRpbmdzLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgQW4gYXJyYXkgb2YgZG9jdW1lbnRzIHRvIGJlIGVtYmVkZGVkLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgMkQgYXJyYXkgb2YgZW1iZWRkaW5ncyBmb3IgZWFjaCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZERvY3VtZW50cyhkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VDaHVua3MgPSAoMCwgY2h1bmtfYXJyYXlfMS5jaHVua0FycmF5KShkb2N1bWVudHMubWFwKChkb2N1bWVudCkgPT4gKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGRvY3VtZW50LFxuICAgICAgICB9KSksIDUpOyAvLyBWZXJ0ZXggQUkgYWNjZXB0cyBtYXggNSBpbnN0YW5jZXMgcGVyIHByZWRpY3Rpb25cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlQ2h1bmtzLm1hcCgoaW5zdGFuY2VzKSA9PiB0aGlzLmNvbm5lY3Rpb24ucmVxdWVzdChpbnN0YW5jZXMsIHBhcmFtZXRlcnMsIG9wdGlvbnMpKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlc1xuICAgICAgICAgICAgPy5tYXAoKHJlc3BvbnNlKSA9PiByZXNwb25zZT8uZGF0YT8ucHJlZGljdGlvbnM/Lm1hcChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKHJlc3VsdCkgPT4gcmVzdWx0LmVtYmVkZGluZ3M/LnZhbHVlcykgPz8gW10pXG4gICAgICAgICAgICAuZmxhdCgpID8/IFtdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGRvY3VtZW50IGFzIGlucHV0IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuXG4gICAgICogZW1iZWRkaW5nIGZvciB0aGUgZG9jdW1lbnQuIEl0IGNhbGxzIHRoZSBlbWJlZERvY3VtZW50cyBtZXRob2Qgd2l0aCB0aGVcbiAgICAgKiBkb2N1bWVudCBhcyB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIGRvY3VtZW50IEEgZG9jdW1lbnQgdG8gYmUgZW1iZWRkZWQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gZW1iZWRkaW5nIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRRdWVyeShkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5lbWJlZERvY3VtZW50cyhbZG9jdW1lbnRdKTtcbiAgICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlR29vZ2xlRW1iZWRkaW5ncyA9IEJhc2VHb29nbGVFbWJlZGRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/media.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFileBase = exports.AIStudioFileDownloadConnection = exports.AIStudioFileUploadConnection = exports.AIStudioMediaBlob = exports.BlobStoreGoogleCloudStorageBase = exports.GoogleCloudStorageRawConnection = exports.GoogleCloudStorageDownloadConnection = exports.GoogleCloudStorageUploadConnection = exports.GoogleCloudStorageUri = exports.BlobStoreGoogle = exports.GoogleDownloadRawConnection = exports.GoogleDownloadConnection = exports.GoogleMultipartUploadConnection = void 0;\nconst async_caller_1 = __webpack_require__(/*! @langchain/core/utils/async_caller */ \"(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst media_core_js_1 = __webpack_require__(/*! ./utils/media_core.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ../connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ../auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass GoogleMultipartUploadConnection extends connection_js_1.GoogleHostConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n    }\n    async _body(separator, data, metadata) {\n        const contentType = data.mimetype;\n        const { encoded, encoding } = await data.encode();\n        const body = [\n            `--${separator}`,\n            \"Content-Type: application/json; charset=UTF-8\",\n            \"\",\n            JSON.stringify(metadata),\n            \"\",\n            `--${separator}`,\n            `Content-Type: ${contentType}`,\n            `Content-Transfer-Encoding: ${encoding}`,\n            \"\",\n            encoded,\n            `--${separator}--`,\n        ];\n        return body.join(\"\\n\");\n    }\n    async request(data, metadata, options) {\n        const separator = `separator-${Date.now()}`;\n        const body = await this._body(separator, data, metadata);\n        const requestHeaders = {\n            \"Content-Type\": `multipart/related; boundary=${separator}`,\n            \"X-Goog-Upload-Protocol\": \"multipart\",\n        };\n        const response = this._request(body, options, requestHeaders);\n        return response;\n    }\n}\nexports.GoogleMultipartUploadConnection = GoogleMultipartUploadConnection;\nclass GoogleDownloadConnection extends connection_js_1.GoogleHostConnection {\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadConnection = GoogleDownloadConnection;\nclass GoogleDownloadRawConnection extends connection_js_1.GoogleRawConnection {\n    buildMethod() {\n        return \"GET\";\n    }\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadRawConnection = GoogleDownloadRawConnection;\nclass BlobStoreGoogle extends media_core_js_1.BlobStore {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_1.AsyncCaller(fields ?? {});\n        this.client = this.buildClient(fields);\n    }\n    async _set(keyValuePair) {\n        const [, blob] = keyValuePair;\n        const setMetadata = this.buildSetMetadata(keyValuePair);\n        const metadata = setMetadata;\n        const options = {};\n        const connection = this.buildSetConnection(keyValuePair);\n        const response = await connection.request(blob, metadata, options);\n        return response;\n    }\n    async mset(keyValuePairs) {\n        const ret = keyValuePairs.map((keyValue) => this._set(keyValue));\n        await Promise.all(ret);\n    }\n    async _getMetadata(key) {\n        const connection = this.buildGetMetadataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    async _getData(key) {\n        const connection = this.buildGetDataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    _getMimetypeFromMetadata(metadata) {\n        return metadata.contentType;\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        const data = await this._getData(key);\n        if (data && metadata) {\n            const ret = await media_core_js_1.MediaBlob.fromBlob(data, { metadata, path: key });\n            return ret;\n        }\n        else {\n            return undefined;\n        }\n    }\n    async mget(keys) {\n        const ret = keys.map((key) => this._get(key));\n        return await Promise.all(ret);\n    }\n    async _del(key) {\n        const connection = this.buildDeleteConnection(key);\n        const options = {};\n        await connection.request(options);\n    }\n    async mdelete(keys) {\n        const ret = keys.map((key) => this._del(key));\n        await Promise.all(ret);\n    }\n    // eslint-disable-next-line require-yield\n    async *yieldKeys(_prefix) {\n        // TODO: Implement. Most have an implementation that uses nextToken.\n        throw new Error(\"yieldKeys is not implemented\");\n    }\n}\nexports.BlobStoreGoogle = BlobStoreGoogle;\nclass GoogleCloudStorageUri {\n    constructor(uri) {\n        Object.defineProperty(this, \"bucket\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const bucketAndPath = GoogleCloudStorageUri.uriToBucketAndPath(uri);\n        this.bucket = bucketAndPath.bucket;\n        this.path = bucketAndPath.path;\n    }\n    get uri() {\n        return `gs://${this.bucket}/${this.path}`;\n    }\n    get isValid() {\n        return (typeof this.bucket !== \"undefined\" && typeof this.path !== \"undefined\");\n    }\n    static uriToBucketAndPath(uri) {\n        const match = this.uriRegexp.exec(uri);\n        if (!match) {\n            throw new Error(`Invalid gs:// URI: ${uri}`);\n        }\n        return {\n            bucket: match[1],\n            path: match[2],\n        };\n    }\n    static isValidUri(uri) {\n        return this.uriRegexp.test(uri);\n    }\n}\nexports.GoogleCloudStorageUri = GoogleCloudStorageUri;\nObject.defineProperty(GoogleCloudStorageUri, \"uriRegexp\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /gs:\\/\\/([a-z0-9][a-z0-9._-]+[a-z0-9])\\/(.*)/\n});\nclass GoogleCloudStorageUploadConnection extends GoogleMultipartUploadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        return `https://storage.googleapis.com/upload/storage/${this.apiVersion}/b/${this.uri.bucket}/o?uploadType=multipart`;\n    }\n}\nexports.GoogleCloudStorageUploadConnection = GoogleCloudStorageUploadConnection;\nclass GoogleCloudStorageDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"alt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n        this.method = fields.method;\n        this.alt = fields.alt;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}`;\n        return this.alt ? `${ret}?alt=${this.alt}` : ret;\n    }\n}\nexports.GoogleCloudStorageDownloadConnection = GoogleCloudStorageDownloadConnection;\nclass GoogleCloudStorageRawConnection extends GoogleDownloadRawConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}?alt=media`;\n        return ret;\n    }\n}\nexports.GoogleCloudStorageRawConnection = GoogleCloudStorageRawConnection;\nclass BlobStoreGoogleCloudStorageBase extends BlobStoreGoogle {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.params = fields;\n        this.defaultStoreOptions = {\n            ...this.defaultStoreOptions,\n            pathPrefix: fields.uriPrefix.uri,\n        };\n    }\n    buildSetConnection([key, _blob]) {\n        const params = {\n            ...this.params,\n            uri: key,\n        };\n        return new GoogleCloudStorageUploadConnection(params, this.caller, this.client);\n    }\n    buildSetMetadata([key, blob]) {\n        const uri = new GoogleCloudStorageUri(key);\n        const ret = {\n            name: uri.path,\n            metadata: blob.metadata,\n            contentType: blob.mimetype,\n        };\n        return ret;\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            uri: key,\n            method: \"GET\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(key) {\n        const params = {\n            uri: key,\n        };\n        return new GoogleCloudStorageRawConnection(params, this.caller, this.client);\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            uri: key,\n            method: \"DELETE\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreGoogleCloudStorageBase = BlobStoreGoogleCloudStorageBase;\nclass AIStudioMediaBlob extends media_core_js_1.MediaBlob {\n    _valueAsDate(value) {\n        if (!value) {\n            return new Date(0);\n        }\n        return new Date(value);\n    }\n    _metadataFieldAsDate(field) {\n        return this._valueAsDate(this.metadata?.[field]);\n    }\n    get createDate() {\n        return this._metadataFieldAsDate(\"createTime\");\n    }\n    get updateDate() {\n        return this._metadataFieldAsDate(\"updateTime\");\n    }\n    get expirationDate() {\n        return this._metadataFieldAsDate(\"expirationTime\");\n    }\n    get isExpired() {\n        const now = new Date().toISOString();\n        const exp = this.metadata?.expirationTime ?? now;\n        return exp <= now;\n    }\n}\nexports.AIStudioMediaBlob = AIStudioMediaBlob;\nclass AIStudioFileUploadConnection extends GoogleMultipartUploadConnection {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/upload/${this.apiVersion}/files`;\n    }\n}\nexports.AIStudioFileUploadConnection = AIStudioFileUploadConnection;\nclass AIStudioFileDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n        this.method = fields.method;\n        this.name = fields.name;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/${this.apiVersion}/files/${this.name}`;\n    }\n}\nexports.AIStudioFileDownloadConnection = AIStudioFileDownloadConnection;\nclass BlobStoreAIStudioFileBase extends BlobStoreGoogle {\n    constructor(fields) {\n        const params = {\n            defaultStoreOptions: {\n                pathPrefix: \"https://generativelanguage.googleapis.com/v1beta/files/\",\n                actionIfInvalid: \"removePath\",\n            },\n            ...fields,\n        };\n        super(params);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryTime\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        this.params = params;\n        this.retryTime = params?.retryTime ?? this.retryTime ?? 1000;\n    }\n    _pathToName(path) {\n        return path.split(\"/\").pop() ?? path;\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            // TODO: Test that you can use OAuth to access\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    async _regetMetadata(key) {\n        // Sleep for some time period\n        // eslint-disable-next-line no-promise-executor-return\n        await new Promise((resolve) => setTimeout(resolve, this.retryTime));\n        // Fetch the latest metadata\n        return this._getMetadata(key);\n    }\n    async _set([key, blob]) {\n        const response = (await super._set([\n            key,\n            blob,\n        ]));\n        let file = response.data?.file ?? { state: \"FAILED\" };\n        while (file.state === \"PROCESSING\" && file.uri && this.retryTime > 0) {\n            file = await this._regetMetadata(file.uri);\n        }\n        // The response should contain the name (and valid URI), so we need to\n        // update the blob with this. We can't return a new blob, since mset()\n        // doesn't return anything.\n        /* eslint-disable no-param-reassign */\n        blob.path = file.uri;\n        blob.metadata = {\n            ...blob.metadata,\n            ...file,\n        };\n        /* eslint-enable no-param-reassign */\n        return response;\n    }\n    buildSetConnection([_key, _blob]) {\n        return new AIStudioFileUploadConnection(this.params, this.caller, this.client);\n    }\n    buildSetMetadata([_key, _blob]) {\n        return {};\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"GET\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(_key) {\n        throw new Error(\"AI Studio File API does not provide data\");\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        if (metadata) {\n            const contentType = metadata?.mimeType ?? \"application/octet-stream\";\n            // TODO - Get the actual data (and other metadata) from an optional backing store\n            const data = {\n                value: \"\",\n                type: contentType,\n            };\n            return new media_core_js_1.MediaBlob({\n                path: key,\n                data,\n                metadata,\n            });\n        }\n        else {\n            return undefined;\n        }\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"DELETE\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreAIStudioFileBase = BlobStoreAIStudioFileBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyxvQ0FBb0MsR0FBRyx5QkFBeUIsR0FBRyx1Q0FBdUMsR0FBRyx1Q0FBdUMsR0FBRyw0Q0FBNEMsR0FBRywwQ0FBMEMsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyxtQ0FBbUMsR0FBRyxnQ0FBZ0MsR0FBRyx1Q0FBdUM7QUFDMWUsdUJBQXVCLG1CQUFPLENBQUMsdUdBQW9DO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0hBQXdCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLDRGQUFtQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLDZCQUE2QixZQUFZO0FBQ3pDLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxxQkFBcUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksR0FBRyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0IsS0FBSyxnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCLEtBQUssZ0JBQWdCLEtBQUssS0FBSztBQUM3Ryw2QkFBNkIsSUFBSSxPQUFPLFNBQVM7QUFDakQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQixLQUFLLGdCQUFnQixLQUFLLEtBQUs7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0IsU0FBUyxVQUFVO0FBQy9GO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9leHBlcmltZW50YWwvbWVkaWEuY2pzPzU2NjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2UgPSBleHBvcnRzLkFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuQUlTdHVkaW9GaWxlVXBsb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuQUlTdHVkaW9NZWRpYUJsb2IgPSBleHBvcnRzLkJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZUJhc2UgPSBleHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXJpID0gZXhwb3J0cy5CbG9iU3RvcmVHb29nbGUgPSBleHBvcnRzLkdvb2dsZURvd25sb2FkUmF3Q29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfY2FsbGVyXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlclwiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBtZWRpYV9jb3JlX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9tZWRpYV9jb3JlLmNqc1wiKTtcbmNvbnN0IGNvbm5lY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuLi9hdXRoLmNqc1wiKTtcbmNsYXNzIEdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgfVxuICAgIGFzeW5jIF9ib2R5KHNlcGFyYXRvciwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBkYXRhLm1pbWV0eXBlO1xuICAgICAgICBjb25zdCB7IGVuY29kZWQsIGVuY29kaW5nIH0gPSBhd2FpdCBkYXRhLmVuY29kZSgpO1xuICAgICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICAgICAgYC0tJHtzZXBhcmF0b3J9YCxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04XCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGAtLSR7c2VwYXJhdG9yfWAsXG4gICAgICAgICAgICBgQ29udGVudC1UeXBlOiAke2NvbnRlbnRUeXBlfWAsXG4gICAgICAgICAgICBgQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogJHtlbmNvZGluZ31gLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGVuY29kZWQsXG4gICAgICAgICAgICBgLS0ke3NlcGFyYXRvcn0tLWAsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBib2R5LmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QoZGF0YSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gYHNlcGFyYXRvci0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHRoaXMuX2JvZHkoc2VwYXJhdG9yLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke3NlcGFyYXRvcn1gLFxuICAgICAgICAgICAgXCJYLUdvb2ctVXBsb2FkLVByb3RvY29sXCI6IFwibXVsdGlwYXJ0XCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5fcmVxdWVzdChib2R5LCBvcHRpb25zLCByZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24gPSBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkdvb2dsZUhvc3RDb25uZWN0aW9uIHtcbiAgICBhc3luYyByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZURvd25sb2FkQ29ubmVjdGlvbiA9IEdvb2dsZURvd25sb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZURvd25sb2FkUmF3Q29ubmVjdGlvbiBleHRlbmRzIGNvbm5lY3Rpb25fanNfMS5Hb29nbGVSYXdDb25uZWN0aW9uIHtcbiAgICBidWlsZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIFwiR0VUXCI7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uID0gR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uO1xuY2xhc3MgQmxvYlN0b3JlR29vZ2xlIGV4dGVuZHMgbWVkaWFfY29yZV9qc18xLkJsb2JTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyXzEuQXN5bmNDYWxsZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSB0aGlzLmJ1aWxkQ2xpZW50KGZpZWxkcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXQoa2V5VmFsdWVQYWlyKSB7XG4gICAgICAgIGNvbnN0IFssIGJsb2JdID0ga2V5VmFsdWVQYWlyO1xuICAgICAgICBjb25zdCBzZXRNZXRhZGF0YSA9IHRoaXMuYnVpbGRTZXRNZXRhZGF0YShrZXlWYWx1ZVBhaXIpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHNldE1ldGFkYXRhO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmJ1aWxkU2V0Q29ubmVjdGlvbihrZXlWYWx1ZVBhaXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChibG9iLCBtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgbXNldChrZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGtleVZhbHVlUGFpcnMubWFwKChrZXlWYWx1ZSkgPT4gdGhpcy5fc2V0KGtleVZhbHVlKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJldCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuYnVpbGRHZXRNZXRhZGF0YUNvbm5lY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIGFzeW5jIF9nZXREYXRhKGtleSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5idWlsZEdldERhdGFDb25uZWN0aW9uKGtleSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICBfZ2V0TWltZXR5cGVGcm9tTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuX2dldE1ldGFkYXRhKGtleSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9nZXREYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBtZWRpYV9jb3JlX2pzXzEuTWVkaWFCbG9iLmZyb21CbG9iKGRhdGEsIHsgbWV0YWRhdGEsIHBhdGg6IGtleSB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1nZXQoa2V5cykge1xuICAgICAgICBjb25zdCByZXQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLl9nZXQoa2V5KSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZXQpO1xuICAgIH1cbiAgICBhc3luYyBfZGVsKGtleSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5idWlsZERlbGV0ZUNvbm5lY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1kZWxldGUoa2V5cykge1xuICAgICAgICBjb25zdCByZXQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLl9kZWwoa2V5KSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJldCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKnlpZWxkS2V5cyhfcHJlZml4KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudC4gTW9zdCBoYXZlIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyBuZXh0VG9rZW4uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInlpZWxkS2V5cyBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGUgPSBCbG9iU3RvcmVHb29nbGU7XG5jbGFzcyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkge1xuICAgIGNvbnN0cnVjdG9yKHVyaSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJidWNrZXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWNrZXRBbmRQYXRoID0gR29vZ2xlQ2xvdWRTdG9yYWdlVXJpLnVyaVRvQnVja2V0QW5kUGF0aCh1cmkpO1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldEFuZFBhdGguYnVja2V0O1xuICAgICAgICB0aGlzLnBhdGggPSBidWNrZXRBbmRQYXRoLnBhdGg7XG4gICAgfVxuICAgIGdldCB1cmkoKSB7XG4gICAgICAgIHJldHVybiBgZ3M6Ly8ke3RoaXMuYnVja2V0fS8ke3RoaXMucGF0aH1gO1xuICAgIH1cbiAgICBnZXQgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5idWNrZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMucGF0aCAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyB1cmlUb0J1Y2tldEFuZFBhdGgodXJpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy51cmlSZWdleHAuZXhlYyh1cmkpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3M6Ly8gVVJJOiAke3VyaX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVja2V0OiBtYXRjaFsxXSxcbiAgICAgICAgICAgIHBhdGg6IG1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFVyaSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJpUmVnZXhwLnRlc3QodXJpKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZVVyaSA9IEdvb2dsZUNsb3VkU3RvcmFnZVVyaTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHb29nbGVDbG91ZFN0b3JhZ2VVcmksIFwidXJpUmVnZXhwXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogL2dzOlxcL1xcLyhbYS16MC05XVthLXowLTkuXy1dK1thLXowLTldKVxcLyguKikvXG59KTtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmkgPSBuZXcgR29vZ2xlQ2xvdWRTdG9yYWdlVXJpKGZpZWxkcy51cmkpO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28/dXBsb2FkVHlwZT1tdWx0aXBhcnRgO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVDbG91ZFN0b3JhZ2VEb3dubG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVEb3dubG9hZENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVyaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRob2RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJpID0gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVyaShmaWVsZHMudXJpKTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBmaWVsZHMubWV0aG9kO1xuICAgICAgICB0aGlzLmFsdCA9IGZpZWxkcy5hbHQ7XG4gICAgfVxuICAgIGJ1aWxkTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2Q7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXJpLnBhdGgpO1xuICAgICAgICBjb25zdCByZXQgPSBgaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28vJHtwYXRofWA7XG4gICAgICAgIHJldHVybiB0aGlzLmFsdCA/IGAke3JldH0/YWx0PSR7dGhpcy5hbHR9YCA6IHJldDtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVEb3dubG9hZFJhd0Nvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVyaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVyaSA9IG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkoZmllbGRzLnVyaSk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXJpLnBhdGgpO1xuICAgICAgICBjb25zdCByZXQgPSBgaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3N0b3JhZ2UvJHt0aGlzLmFwaVZlcnNpb259L2IvJHt0aGlzLnVyaS5idWNrZXR9L28vJHtwYXRofT9hbHQ9bWVkaWFgO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlUmF3Q29ubmVjdGlvbiA9IEdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb247XG5jbGFzcyBCbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlIGV4dGVuZHMgQmxvYlN0b3JlR29vZ2xlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gZmllbGRzO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMsXG4gICAgICAgICAgICBwYXRoUHJlZml4OiBmaWVsZHMudXJpUHJlZml4LnVyaSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRTZXRDb25uZWN0aW9uKFtrZXksIF9ibG9iXSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIHVyaToga2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVwbG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZFNldE1ldGFkYXRhKFtrZXksIGJsb2JdKSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkoa2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgbmFtZTogdXJpLnBhdGgsXG4gICAgICAgICAgICBtZXRhZGF0YTogYmxvYi5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBibG9iLm1pbWV0eXBlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBidWlsZEdldE1ldGFkYXRhQ29ubmVjdGlvbihrZXkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdXJpOiBrZXksXG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBhbHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VEb3dubG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZEdldERhdGFDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmk6IGtleSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VSYXdDb25uZWN0aW9uKHBhcmFtcywgdGhpcy5jYWxsZXIsIHRoaXMuY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGREZWxldGVDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmk6IGtleSxcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGFsdDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbihwYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlID0gQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlQmFzZTtcbmNsYXNzIEFJU3R1ZGlvTWVkaWFCbG9iIGV4dGVuZHMgbWVkaWFfY29yZV9qc18xLk1lZGlhQmxvYiB7XG4gICAgX3ZhbHVlQXNEYXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBfbWV0YWRhdGFGaWVsZEFzRGF0ZShmaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVBc0RhdGUodGhpcy5tZXRhZGF0YT8uW2ZpZWxkXSk7XG4gICAgfVxuICAgIGdldCBjcmVhdGVEYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFGaWVsZEFzRGF0ZShcImNyZWF0ZVRpbWVcIik7XG4gICAgfVxuICAgIGdldCB1cGRhdGVEYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFGaWVsZEFzRGF0ZShcInVwZGF0ZVRpbWVcIik7XG4gICAgfVxuICAgIGdldCBleHBpcmF0aW9uRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhRmllbGRBc0RhdGUoXCJleHBpcmF0aW9uVGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBleHAgPSB0aGlzLm1ldGFkYXRhPy5leHBpcmF0aW9uVGltZSA/PyBub3c7XG4gICAgICAgIHJldHVybiBleHAgPD0gbm93O1xuICAgIH1cbn1cbmV4cG9ydHMuQUlTdHVkaW9NZWRpYUJsb2IgPSBBSVN0dWRpb01lZGlhQmxvYjtcbmNsYXNzIEFJU3R1ZGlvRmlsZVVwbG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVNdWx0aXBhcnRVcGxvYWRDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ2MWJldGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdXBsb2FkLyR7dGhpcy5hcGlWZXJzaW9ufS9maWxlc2A7XG4gICAgfVxufVxuZXhwb3J0cy5BSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uID0gQUlTdHVkaW9GaWxlVXBsb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZURvd25sb2FkQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCkge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0aG9kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ2MWJldGFcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBmaWVsZHMubWV0aG9kO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICB9XG4gICAgYnVpbGRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vJHt0aGlzLmFwaVZlcnNpb259L2ZpbGVzLyR7dGhpcy5uYW1lfWA7XG4gICAgfVxufVxuZXhwb3J0cy5BSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb24gPSBBSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb247XG5jbGFzcyBCbG9iU3RvcmVBSVN0dWRpb0ZpbGVCYXNlIGV4dGVuZHMgQmxvYlN0b3JlR29vZ2xlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgZGVmYXVsdFN0b3JlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHBhdGhQcmVmaXg6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL2ZpbGVzL1wiLFxuICAgICAgICAgICAgICAgIGFjdGlvbklmSW52YWxpZDogXCJyZW1vdmVQYXRoXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJhbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0cnlUaW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5yZXRyeVRpbWUgPSBwYXJhbXM/LnJldHJ5VGltZSA/PyB0aGlzLnJldHJ5VGltZSA/PyAxMDAwO1xuICAgIH1cbiAgICBfcGF0aFRvTmFtZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5wb3AoKSA/PyBwYXRoO1xuICAgIH1cbiAgICBidWlsZEFwaUtleUNsaWVudChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuQXBpS2V5R29vZ2xlQXV0aChhcGlLZXkpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleShmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcz8uYXBpS2V5ID8/ICgwLCBlbnZfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkdPT0dMRV9BUElfS0VZXCIpO1xuICAgIH1cbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5idWlsZEFwaUtleShmaWVsZHMpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFwaUtleUNsaWVudChhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogVGVzdCB0aGF0IHlvdSBjYW4gdXNlIE9BdXRoIHRvIGFjY2Vzc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3JlZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgIC8vIFNsZWVwIGZvciBzb21lIHRpbWUgcGVyaW9kXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVyblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLnJldHJ5VGltZSkpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgbGF0ZXN0IG1ldGFkYXRhXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBfc2V0KFtrZXksIGJsb2JdKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHN1cGVyLl9zZXQoW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgYmxvYixcbiAgICAgICAgXSkpO1xuICAgICAgICBsZXQgZmlsZSA9IHJlc3BvbnNlLmRhdGE/LmZpbGUgPz8geyBzdGF0ZTogXCJGQUlMRURcIiB9O1xuICAgICAgICB3aGlsZSAoZmlsZS5zdGF0ZSA9PT0gXCJQUk9DRVNTSU5HXCIgJiYgZmlsZS51cmkgJiYgdGhpcy5yZXRyeVRpbWUgPiAwKSB7XG4gICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5fcmVnZXRNZXRhZGF0YShmaWxlLnVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJlc3BvbnNlIHNob3VsZCBjb250YWluIHRoZSBuYW1lIChhbmQgdmFsaWQgVVJJKSwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJsb2Igd2l0aCB0aGlzLiBXZSBjYW4ndCByZXR1cm4gYSBuZXcgYmxvYiwgc2luY2UgbXNldCgpXG4gICAgICAgIC8vIGRvZXNuJ3QgcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICBibG9iLnBhdGggPSBmaWxlLnVyaTtcbiAgICAgICAgYmxvYi5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmJsb2IubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYnVpbGRTZXRDb25uZWN0aW9uKFtfa2V5LCBfYmxvYl0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uKHRoaXMucGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZFNldE1ldGFkYXRhKFtfa2V5LCBfYmxvYl0pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBidWlsZEdldE1ldGFkYXRhQ29ubmVjdGlvbihrZXkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLl9wYXRoVG9OYW1lKGtleSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQUlTdHVkaW9GaWxlRG93bmxvYWRDb25uZWN0aW9uKHBhcmFtcywgdGhpcy5jYWxsZXIsIHRoaXMuY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGRHZXREYXRhQ29ubmVjdGlvbihfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFJIFN0dWRpbyBGaWxlIEFQSSBkb2VzIG5vdCBwcm92aWRlIGRhdGFcIik7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5fZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG1ldGFkYXRhPy5taW1lVHlwZSA/PyBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICAgICAgLy8gVE9ETyAtIEdldCB0aGUgYWN0dWFsIGRhdGEgKGFuZCBvdGhlciBtZXRhZGF0YSkgZnJvbSBhbiBvcHRpb25hbCBiYWNraW5nIHN0b3JlXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFfY29yZV9qc18xLk1lZGlhQmxvYih7XG4gICAgICAgICAgICAgICAgcGF0aDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWxldGVDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX3BhdGhUb05hbWUoa2V5KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlQmFzZSA9IEJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MediaManager = exports.DataBlobStore = exports.SimpleWebBlobStore = exports.ReadThroughBlobStore = exports.BackedBlobStore = exports.BlobStore = exports.MediaBlob = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\"); // FIXME - it is importing the wrong uuid, so v6 and v7 aren't implemented\nconst stores_1 = __webpack_require__(/*! @langchain/core/stores */ \"(rsc)/./node_modules/@langchain/core/stores.cjs\");\nconst serializable_1 = __webpack_require__(/*! @langchain/core/load/serializable */ \"(rsc)/./node_modules/@langchain/core/load/serializable.cjs\");\nfunction bytesToString(dataArray) {\n    // Need to handle the array in smaller chunks to deal with stack size limits\n    let ret = \"\";\n    const chunkSize = 102400;\n    for (let i = 0; i < dataArray.length; i += chunkSize) {\n        const chunk = dataArray.subarray(i, i + chunkSize);\n        ret += String.fromCharCode(...chunk);\n    }\n    return ret;\n}\n/**\n * Represents a chunk of data that can be identified by the path where the\n * data is (or will be) located, along with optional metadata about the data.\n */\nclass MediaBlob extends serializable_1.Serializable {\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                \"langchain\",\n                \"google_common\",\n                \"experimental\",\n                \"utils\",\n                \"media_core\",\n            ]\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                value: \"\",\n                type: \"text/plain\",\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = params.data ?? this.data;\n        this.metadata = params.metadata;\n        this.path = params.path;\n    }\n    get size() {\n        return this.asBytes.length;\n    }\n    get dataType() {\n        return this.data?.type ?? \"\";\n    }\n    get encoding() {\n        const charsetEquals = this.dataType.indexOf(\"charset=\");\n        return charsetEquals === -1\n            ? \"utf-8\"\n            : this.dataType.substring(charsetEquals + 8);\n    }\n    get mimetype() {\n        const semicolon = this.dataType.indexOf(\";\");\n        return semicolon === -1\n            ? this.dataType\n            : this.dataType.substring(0, semicolon);\n    }\n    get asBytes() {\n        if (!this.data) {\n            return Uint8Array.from([]);\n        }\n        const binString = atob(this.data?.value);\n        const ret = new Uint8Array(binString.length);\n        for (let co = 0; co < binString.length; co += 1) {\n            ret[co] = binString.charCodeAt(co);\n        }\n        return ret;\n    }\n    async asString() {\n        return bytesToString(this.asBytes);\n    }\n    async asBase64() {\n        return this.data?.value ?? \"\";\n    }\n    async asDataUrl() {\n        return `data:${this.mimetype};base64,${await this.asBase64()}`;\n    }\n    async asUri() {\n        return this.path ?? (await this.asDataUrl());\n    }\n    async encode() {\n        const dataUrl = await this.asDataUrl();\n        const comma = dataUrl.indexOf(\",\");\n        const encoded = dataUrl.substring(comma + 1);\n        const encoding = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n        return {\n            encoded,\n            encoding,\n        };\n    }\n    static fromDataUrl(url) {\n        if (!url.startsWith(\"data:\")) {\n            throw new Error(\"Not a data: URL\");\n        }\n        const colon = url.indexOf(\":\");\n        const semicolon = url.indexOf(\";\");\n        const mimeType = url.substring(colon + 1, semicolon);\n        const comma = url.indexOf(\",\");\n        const base64Data = url.substring(comma + 1);\n        const data = {\n            type: mimeType,\n            value: base64Data,\n        };\n        return new MediaBlob({\n            data,\n            path: url,\n        });\n    }\n    static async fromBlob(blob, other) {\n        const valueBuffer = await blob.arrayBuffer();\n        const valueArray = new Uint8Array(valueBuffer);\n        const valueStr = bytesToString(valueArray);\n        const value = btoa(valueStr);\n        return new MediaBlob({\n            ...other,\n            data: {\n                value,\n                type: blob.type,\n            },\n        });\n    }\n}\nexports.MediaBlob = MediaBlob;\n/**\n * A specialized Store that is designed to handle MediaBlobs and use the\n * key that is included in the blob to determine exactly how it is stored.\n *\n * The full details of a MediaBlob may be changed when it is stored.\n * For example, it may get additional or different Metadata. This should be\n * what is returned when the store() method is called.\n *\n * Although BlobStore extends BaseStore, not all of the methods from\n * BaseStore may be implemented (or even possible). Those that are not\n * implemented should be documented and throw an Error if called.\n */\nclass BlobStore extends stores_1.BaseStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"google-common\"]\n        }); // FIXME - What should this be? And why?\n        Object.defineProperty(this, \"defaultStoreOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultFetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n        this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n    }\n    async _realKey(key) {\n        return typeof key === \"string\" ? key : await key.asUri();\n    }\n    /**\n     * Is the path supported by this BlobStore?\n     *\n     * Although this is async, this is expected to be a relatively fast operation\n     * (ie - you shouldn't make network calls).\n     *\n     * @param path The path to check\n     * @param opts Any options (if needed) that may be used to determine if it is valid\n     * @return If the path is supported\n     */\n    hasValidPath(path, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const isPrefixed = typeof path !== \"undefined\" && path.startsWith(prefix);\n        return Promise.resolve(isPrefixed);\n    }\n    _blobPathSuffix(blob) {\n        // Get the path currently set and make sure we treat it as a string\n        const blobPath = `${blob.path}`;\n        // Advance past the first set of /\n        let pathStart = blobPath.indexOf(\"/\") + 1;\n        while (blobPath.charAt(pathStart) === \"/\") {\n            pathStart += 1;\n        }\n        // We will use the rest as the path for a replacement\n        return blobPath.substring(pathStart);\n    }\n    async _newBlob(oldBlob, newPath) {\n        const oldPath = oldBlob.path;\n        const metadata = oldBlob?.metadata ?? {};\n        metadata.langchainOldPath = oldPath;\n        const newBlob = new MediaBlob({\n            ...oldBlob,\n            metadata,\n        });\n        if (newPath) {\n            newBlob.path = newPath;\n        }\n        else if (newBlob.path) {\n            delete newBlob.path;\n        }\n        return newBlob;\n    }\n    async _validBlobPrefixPath(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._blobPathSuffix(blob);\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    _validBlobPrefixUuidFunction(name) {\n        switch (name) {\n            case \"prefixUuid1\":\n                return (0, uuid_1.v1)();\n            case \"prefixUuid4\":\n                return (0, uuid_1.v4)();\n            // case \"prefixUuid6\": return v6();\n            // case \"prefixUuid7\": return v7();\n            default:\n                throw new Error(`Unknown uuid function: ${name}`);\n        }\n    }\n    async _validBlobPrefixUuid(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._validBlobPrefixUuidFunction(opts?.actionIfInvalid ?? \"prefixUuid4\");\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    async _validBlobRemovePath(blob, _opts) {\n        return this._newBlob(blob, undefined);\n    }\n    /**\n     * Based on the blob and options, return a blob that has a valid path\n     * that can be saved.\n     * @param blob\n     * @param opts\n     */\n    async _validStoreBlob(blob, opts) {\n        if (await this.hasValidPath(blob.path, opts)) {\n            return blob;\n        }\n        switch (opts?.actionIfInvalid) {\n            case \"ignore\":\n                return blob;\n            case \"prefixPath\":\n                return this._validBlobPrefixPath(blob, opts);\n            case \"prefixUuid1\":\n            case \"prefixUuid4\":\n            case \"prefixUuid6\":\n            case \"prefixUuid7\":\n                return this._validBlobPrefixUuid(blob, opts);\n            case \"removePath\":\n                return this._validBlobRemovePath(blob, opts);\n            default:\n                return undefined;\n        }\n    }\n    async store(blob, opts = {}) {\n        const allOpts = {\n            ...this.defaultStoreOptions,\n            ...opts,\n        };\n        const validBlob = await this._validStoreBlob(blob, allOpts);\n        if (typeof validBlob !== \"undefined\") {\n            const validKey = await validBlob.asUri();\n            await this.mset([[validKey, validBlob]]);\n            const savedKey = await validBlob.asUri();\n            return await this.fetch(savedKey);\n        }\n        return undefined;\n    }\n    async _missingFetchBlobEmpty(path, _opts) {\n        return new MediaBlob({ path });\n    }\n    async _missingFetchBlob(path, opts) {\n        switch (opts?.actionIfBlobMissing) {\n            case \"emptyBlob\":\n                return this._missingFetchBlobEmpty(path, opts);\n            default:\n                return undefined;\n        }\n    }\n    async fetch(key, opts = {}) {\n        const allOpts = {\n            ...this.defaultFetchOptions,\n            ...opts,\n        };\n        const realKey = await this._realKey(key);\n        const ret = await this.mget([realKey]);\n        return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n    }\n}\nexports.BlobStore = BlobStore;\nclass BackedBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.backingStore = opts.backingStore;\n    }\n    mdelete(keys) {\n        return this.backingStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.backingStore.mget(keys);\n    }\n    mset(keyValuePairs) {\n        return this.backingStore.mset(keyValuePairs);\n    }\n    yieldKeys(prefix) {\n        return this.backingStore.yieldKeys(prefix);\n    }\n}\nexports.BackedBlobStore = BackedBlobStore;\nclass ReadThroughBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"baseStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStore = opts.baseStore;\n        this.backingStore = opts.backingStore;\n    }\n    async store(blob, opts = {}) {\n        const originalUri = await blob.asUri();\n        const newBlob = await this.backingStore.store(blob, opts);\n        if (newBlob) {\n            await this.baseStore.mset([[originalUri, newBlob]]);\n        }\n        return newBlob;\n    }\n    mdelete(keys) {\n        return this.baseStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.baseStore.mget(keys);\n    }\n    mset(_keyValuePairs) {\n        throw new Error(\"Do not call ReadThroughBlobStore.mset directly\");\n    }\n    yieldKeys(prefix) {\n        return this.baseStore.yieldKeys(prefix);\n    }\n}\nexports.ReadThroughBlobStore = ReadThroughBlobStore;\nclass SimpleWebBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for SimpleWebBlobStore\");\n    }\n    async hasValidPath(path, _opts) {\n        return ((await super.hasValidPath(path, { pathPrefix: \"https://\" })) ||\n            (await super.hasValidPath(path, { pathPrefix: \"http://\" })));\n    }\n    async _fetch(url) {\n        const ret = new MediaBlob({\n            path: url,\n        });\n        const metadata = {};\n        const fetchOptions = {\n            method: \"GET\",\n        };\n        const res = await fetch(url, fetchOptions);\n        metadata.status = res.status;\n        const headers = {};\n        for (const [key, value] of res.headers.entries()) {\n            headers[key] = value;\n        }\n        metadata.headers = headers;\n        metadata.ok = res.ok;\n        if (res.ok) {\n            const resMediaBlob = await MediaBlob.fromBlob(await res.blob());\n            ret.data = resMediaBlob.data;\n        }\n        ret.metadata = metadata;\n        return ret;\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return await Promise.all(blobMap);\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.SimpleWebBlobStore = SimpleWebBlobStore;\n/**\n * A blob \"store\" that works with data: URLs that will turn the URL into\n * a blob.\n */\nclass DataBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for DataBlobStore\");\n    }\n    hasValidPath(path, _opts) {\n        return super.hasValidPath(path, { pathPrefix: \"data:\" });\n    }\n    _fetch(url) {\n        return MediaBlob.fromDataUrl(url);\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return blobMap;\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.DataBlobStore = DataBlobStore;\n/**\n * Responsible for converting a URI (typically a web URL) into a MediaBlob.\n * Allows for aliasing / caching of the requested URI and what it resolves to.\n * This MediaBlob is expected to be usable to provide to an LLM, either\n * through the Base64 of the media or through a canonical URI that the LLM\n * supports.\n */\nclass MediaManager {\n    constructor(config) {\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resolvers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.store = config.store;\n        this.resolvers = config.resolvers;\n    }\n    defaultResolvers() {\n        return [new DataBlobStore({}), new SimpleWebBlobStore({})];\n    }\n    async _isInvalid(blob) {\n        return typeof blob === \"undefined\";\n    }\n    /**\n     * Given the public URI, load what is at this URI and save it\n     * in the store.\n     * @param uri The URI to resolve using the resolver\n     * @return A canonical MediaBlob for this URI\n     */\n    async _resolveAndSave(uri) {\n        let resolvedBlob;\n        const resolvers = this.resolvers || this.defaultResolvers();\n        for (let co = 0; co < resolvers.length; co += 1) {\n            const resolver = resolvers[co];\n            if (await resolver.hasValidPath(uri)) {\n                resolvedBlob = await resolver.fetch(uri);\n            }\n        }\n        if (resolvedBlob) {\n            return await this.store.store(resolvedBlob);\n        }\n        else {\n            return new MediaBlob({});\n        }\n    }\n    async getMediaBlob(uri) {\n        const aliasBlob = await this.store.fetch(uri);\n        const ret = (await this._isInvalid(aliasBlob))\n            ? await this._resolveAndSave(uri)\n            : aliasBlob;\n        return ret;\n    }\n}\nexports.MediaManager = MediaManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL3V0aWxzL21lZGlhX2NvcmUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMxSyxlQUFlLG1CQUFPLENBQUMsOERBQU0sR0FBRztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBd0I7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMscUdBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWUsU0FBUyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9leHBlcmltZW50YWwvdXRpbHMvbWVkaWFfY29yZS5janM/MTFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVkaWFNYW5hZ2VyID0gZXhwb3J0cy5EYXRhQmxvYlN0b3JlID0gZXhwb3J0cy5TaW1wbGVXZWJCbG9iU3RvcmUgPSBleHBvcnRzLlJlYWRUaHJvdWdoQmxvYlN0b3JlID0gZXhwb3J0cy5CYWNrZWRCbG9iU3RvcmUgPSBleHBvcnRzLkJsb2JTdG9yZSA9IGV4cG9ydHMuTWVkaWFCbG9iID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7IC8vIEZJWE1FIC0gaXQgaXMgaW1wb3J0aW5nIHRoZSB3cm9uZyB1dWlkLCBzbyB2NiBhbmQgdjcgYXJlbid0IGltcGxlbWVudGVkXG5jb25zdCBzdG9yZXNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvc3RvcmVzXCIpO1xuY29uc3Qgc2VyaWFsaXphYmxlXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlXCIpO1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhkYXRhQXJyYXkpIHtcbiAgICAvLyBOZWVkIHRvIGhhbmRsZSB0aGUgYXJyYXkgaW4gc21hbGxlciBjaHVua3MgdG8gZGVhbCB3aXRoIHN0YWNrIHNpemUgbGltaXRzXG4gICAgbGV0IHJldCA9IFwiXCI7XG4gICAgY29uc3QgY2h1bmtTaXplID0gMTAyNDAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBkYXRhQXJyYXkuc3ViYXJyYXkoaSwgaSArIGNodW5rU2l6ZSk7XG4gICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNodW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGRhdGEgdGhhdCBjYW4gYmUgaWRlbnRpZmllZCBieSB0aGUgcGF0aCB3aGVyZSB0aGVcbiAqIGRhdGEgaXMgKG9yIHdpbGwgYmUpIGxvY2F0ZWQsIGFsb25nIHdpdGggb3B0aW9uYWwgbWV0YWRhdGEgYWJvdXQgdGhlIGRhdGEuXG4gKi9cbmNsYXNzIE1lZGlhQmxvYiBleHRlbmRzIHNlcmlhbGl6YWJsZV8xLlNlcmlhbGl6YWJsZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgXCJsYW5nY2hhaW5cIixcbiAgICAgICAgICAgICAgICBcImdvb2dsZV9jb21tb25cIixcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbFwiLFxuICAgICAgICAgICAgICAgIFwidXRpbHNcIixcbiAgICAgICAgICAgICAgICBcIm1lZGlhX2NvcmVcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhID0gcGFyYW1zLmRhdGEgPz8gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzQnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgZGF0YVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE/LnR5cGUgPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICBjb25zdCBjaGFyc2V0RXF1YWxzID0gdGhpcy5kYXRhVHlwZS5pbmRleE9mKFwiY2hhcnNldD1cIik7XG4gICAgICAgIHJldHVybiBjaGFyc2V0RXF1YWxzID09PSAtMVxuICAgICAgICAgICAgPyBcInV0Zi04XCJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhVHlwZS5zdWJzdHJpbmcoY2hhcnNldEVxdWFscyArIDgpO1xuICAgIH1cbiAgICBnZXQgbWltZXR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHRoaXMuZGF0YVR5cGUuaW5kZXhPZihcIjtcIik7XG4gICAgICAgIHJldHVybiBzZW1pY29sb24gPT09IC0xXG4gICAgICAgICAgICA/IHRoaXMuZGF0YVR5cGVcbiAgICAgICAgICAgIDogdGhpcy5kYXRhVHlwZS5zdWJzdHJpbmcoMCwgc2VtaWNvbG9uKTtcbiAgICB9XG4gICAgZ2V0IGFzQnl0ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5TdHJpbmcgPSBhdG9iKHRoaXMuZGF0YT8udmFsdWUpO1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShiaW5TdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgY28gPSAwOyBjbyA8IGJpblN0cmluZy5sZW5ndGg7IGNvICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtjb10gPSBiaW5TdHJpbmcuY2hhckNvZGVBdChjbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgYXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvU3RyaW5nKHRoaXMuYXNCeXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGFzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhPy52YWx1ZSA/PyBcIlwiO1xuICAgIH1cbiAgICBhc3luYyBhc0RhdGFVcmwoKSB7XG4gICAgICAgIHJldHVybiBgZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke2F3YWl0IHRoaXMuYXNCYXNlNjQoKX1gO1xuICAgIH1cbiAgICBhc3luYyBhc1VyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aCA/PyAoYXdhaXQgdGhpcy5hc0RhdGFVcmwoKSk7XG4gICAgfVxuICAgIGFzeW5jIGVuY29kZSgpIHtcbiAgICAgICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IHRoaXMuYXNEYXRhVXJsKCk7XG4gICAgICAgIGNvbnN0IGNvbW1hID0gZGF0YVVybC5pbmRleE9mKFwiLFwiKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IGRhdGFVcmwuc3Vic3RyaW5nKGNvbW1hICsgMSk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gZGF0YVVybC5pbmRleE9mKFwiYmFzZTY0XCIpID4gLTEgPyBcImJhc2U2NFwiIDogXCI4Yml0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkLFxuICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGF0YVVybCh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBkYXRhOiBVUkxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb24gPSB1cmwuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHVybC5pbmRleE9mKFwiO1wiKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSB1cmwuc3Vic3RyaW5nKGNvbG9uICsgMSwgc2VtaWNvbG9uKTtcbiAgICAgICAgY29uc3QgY29tbWEgPSB1cmwuaW5kZXhPZihcIixcIik7XG4gICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSB1cmwuc3Vic3RyaW5nKGNvbW1hICsgMSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBiYXNlNjREYXRhLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE1lZGlhQmxvYih7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogdXJsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21CbG9iKGJsb2IsIG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCB2YWx1ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVCdWZmZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZVN0ciA9IGJ5dGVzVG9TdHJpbmcodmFsdWVBcnJheSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnRvYSh2YWx1ZVN0cik7XG4gICAgICAgIHJldHVybiBuZXcgTWVkaWFCbG9iKHtcbiAgICAgICAgICAgIC4uLm90aGVyLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGJsb2IudHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFCbG9iID0gTWVkaWFCbG9iO1xuLyoqXG4gKiBBIHNwZWNpYWxpemVkIFN0b3JlIHRoYXQgaXMgZGVzaWduZWQgdG8gaGFuZGxlIE1lZGlhQmxvYnMgYW5kIHVzZSB0aGVcbiAqIGtleSB0aGF0IGlzIGluY2x1ZGVkIGluIHRoZSBibG9iIHRvIGRldGVybWluZSBleGFjdGx5IGhvdyBpdCBpcyBzdG9yZWQuXG4gKlxuICogVGhlIGZ1bGwgZGV0YWlscyBvZiBhIE1lZGlhQmxvYiBtYXkgYmUgY2hhbmdlZCB3aGVuIGl0IGlzIHN0b3JlZC5cbiAqIEZvciBleGFtcGxlLCBpdCBtYXkgZ2V0IGFkZGl0aW9uYWwgb3IgZGlmZmVyZW50IE1ldGFkYXRhLiBUaGlzIHNob3VsZCBiZVxuICogd2hhdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBzdG9yZSgpIG1ldGhvZCBpcyBjYWxsZWQuXG4gKlxuICogQWx0aG91Z2ggQmxvYlN0b3JlIGV4dGVuZHMgQmFzZVN0b3JlLCBub3QgYWxsIG9mIHRoZSBtZXRob2RzIGZyb21cbiAqIEJhc2VTdG9yZSBtYXkgYmUgaW1wbGVtZW50ZWQgKG9yIGV2ZW4gcG9zc2libGUpLiBUaG9zZSB0aGF0IGFyZSBub3RcbiAqIGltcGxlbWVudGVkIHNob3VsZCBiZSBkb2N1bWVudGVkIGFuZCB0aHJvdyBhbiBFcnJvciBpZiBjYWxsZWQuXG4gKi9cbmNsYXNzIEJsb2JTdG9yZSBleHRlbmRzIHN0b3Jlc18xLkJhc2VTdG9yZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJnb29nbGUtY29tbW9uXCJdXG4gICAgICAgIH0pOyAvLyBGSVhNRSAtIFdoYXQgc2hvdWxkIHRoaXMgYmU/IEFuZCB3aHk/XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRTdG9yZU9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdEZldGNoT3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdG9yZU9wdGlvbnMgPSBvcHRzPy5kZWZhdWx0U3RvcmVPcHRpb25zID8/IHt9O1xuICAgICAgICB0aGlzLmRlZmF1bHRGZXRjaE9wdGlvbnMgPSBvcHRzPy5kZWZhdWx0RmV0Y2hPcHRpb25zID8/IHt9O1xuICAgIH1cbiAgICBhc3luYyBfcmVhbEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgPyBrZXkgOiBhd2FpdCBrZXkuYXNVcmkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggc3VwcG9ydGVkIGJ5IHRoaXMgQmxvYlN0b3JlP1xuICAgICAqXG4gICAgICogQWx0aG91Z2ggdGhpcyBpcyBhc3luYywgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIHJlbGF0aXZlbHkgZmFzdCBvcGVyYXRpb25cbiAgICAgKiAoaWUgLSB5b3Ugc2hvdWxkbid0IG1ha2UgbmV0d29yayBjYWxscykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVja1xuICAgICAqIEBwYXJhbSBvcHRzIEFueSBvcHRpb25zIChpZiBuZWVkZWQpIHRoYXQgbWF5IGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHZhbGlkXG4gICAgICogQHJldHVybiBJZiB0aGUgcGF0aCBpcyBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBoYXNWYWxpZFBhdGgocGF0aCwgb3B0cykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRzPy5wYXRoUHJlZml4ID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IGlzUHJlZml4ZWQgPSB0eXBlb2YgcGF0aCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXRoLnN0YXJ0c1dpdGgocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpc1ByZWZpeGVkKTtcbiAgICB9XG4gICAgX2Jsb2JQYXRoU3VmZml4KGJsb2IpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwYXRoIGN1cnJlbnRseSBzZXQgYW5kIG1ha2Ugc3VyZSB3ZSB0cmVhdCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICBjb25zdCBibG9iUGF0aCA9IGAke2Jsb2IucGF0aH1gO1xuICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIGZpcnN0IHNldCBvZiAvXG4gICAgICAgIGxldCBwYXRoU3RhcnQgPSBibG9iUGF0aC5pbmRleE9mKFwiL1wiKSArIDE7XG4gICAgICAgIHdoaWxlIChibG9iUGF0aC5jaGFyQXQocGF0aFN0YXJ0KSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHBhdGhTdGFydCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdpbGwgdXNlIHRoZSByZXN0IGFzIHRoZSBwYXRoIGZvciBhIHJlcGxhY2VtZW50XG4gICAgICAgIHJldHVybiBibG9iUGF0aC5zdWJzdHJpbmcocGF0aFN0YXJ0KTtcbiAgICB9XG4gICAgYXN5bmMgX25ld0Jsb2Iob2xkQmxvYiwgbmV3UGF0aCkge1xuICAgICAgICBjb25zdCBvbGRQYXRoID0gb2xkQmxvYi5wYXRoO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG9sZEJsb2I/Lm1ldGFkYXRhID8/IHt9O1xuICAgICAgICBtZXRhZGF0YS5sYW5nY2hhaW5PbGRQYXRoID0gb2xkUGF0aDtcbiAgICAgICAgY29uc3QgbmV3QmxvYiA9IG5ldyBNZWRpYUJsb2Ioe1xuICAgICAgICAgICAgLi4ub2xkQmxvYixcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld1BhdGgpIHtcbiAgICAgICAgICAgIG5ld0Jsb2IucGF0aCA9IG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3QmxvYi5wYXRoKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3QmxvYi5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdCbG9iO1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRCbG9iUHJlZml4UGF0aChibG9iLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdHM/LnBhdGhQcmVmaXggPz8gXCJcIjtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdGhpcy5fYmxvYlBhdGhTdWZmaXgoYmxvYik7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBgJHtwcmVmaXh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0Jsb2IoYmxvYiwgbmV3UGF0aCk7XG4gICAgfVxuICAgIF92YWxpZEJsb2JQcmVmaXhVdWlkRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkMVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXVpZF8xLnYxKSgpO1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICAvLyBjYXNlIFwicHJlZml4VXVpZDZcIjogcmV0dXJuIHY2KCk7XG4gICAgICAgICAgICAvLyBjYXNlIFwicHJlZml4VXVpZDdcIjogcmV0dXJuIHY3KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1dWlkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkQmxvYlByZWZpeFV1aWQoYmxvYiwgb3B0cykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRzPy5wYXRoUHJlZml4ID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMuX3ZhbGlkQmxvYlByZWZpeFV1aWRGdW5jdGlvbihvcHRzPy5hY3Rpb25JZkludmFsaWQgPz8gXCJwcmVmaXhVdWlkNFwiKTtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke3ByZWZpeH0ke3N1ZmZpeH1gO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3QmxvYihibG9iLCBuZXdQYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgX3ZhbGlkQmxvYlJlbW92ZVBhdGgoYmxvYiwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0Jsb2IoYmxvYiwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIGJsb2IgYW5kIG9wdGlvbnMsIHJldHVybiBhIGJsb2IgdGhhdCBoYXMgYSB2YWxpZCBwYXRoXG4gICAgICogdGhhdCBjYW4gYmUgc2F2ZWQuXG4gICAgICogQHBhcmFtIGJsb2JcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqL1xuICAgIGFzeW5jIF92YWxpZFN0b3JlQmxvYihibG9iLCBvcHRzKSB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmhhc1ZhbGlkUGF0aChibG9iLnBhdGgsIG9wdHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wdHM/LmFjdGlvbklmSW52YWxpZCkge1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9iO1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFBhdGhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRCbG9iUHJlZml4UGF0aChibG9iLCBvcHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkMVwiOlxuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQ0XCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlZml4VXVpZDZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkN1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZEJsb2JQcmVmaXhVdWlkKGJsb2IsIG9wdHMpO1xuICAgICAgICAgICAgY2FzZSBcInJlbW92ZVBhdGhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRCbG9iUmVtb3ZlUGF0aChibG9iLCBvcHRzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdG9yZShibG9iLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdFN0b3JlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbGlkQmxvYiA9IGF3YWl0IHRoaXMuX3ZhbGlkU3RvcmVCbG9iKGJsb2IsIGFsbE9wdHMpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkQmxvYiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRLZXkgPSBhd2FpdCB2YWxpZEJsb2IuYXNVcmkoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubXNldChbW3ZhbGlkS2V5LCB2YWxpZEJsb2JdXSk7XG4gICAgICAgICAgICBjb25zdCBzYXZlZEtleSA9IGF3YWl0IHZhbGlkQmxvYi5hc1VyaSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2goc2F2ZWRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIF9taXNzaW5nRmV0Y2hCbG9iRW1wdHkocGF0aCwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUJsb2IoeyBwYXRoIH0pO1xuICAgIH1cbiAgICBhc3luYyBfbWlzc2luZ0ZldGNoQmxvYihwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cz8uYWN0aW9uSWZCbG9iTWlzc2luZykge1xuICAgICAgICAgICAgY2FzZSBcImVtcHR5QmxvYlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXNzaW5nRmV0Y2hCbG9iRW1wdHkocGF0aCwgb3B0cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2goa2V5LCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdEZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlYWxLZXkgPSBhd2FpdCB0aGlzLl9yZWFsS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMubWdldChbcmVhbEtleV0pO1xuICAgICAgICByZXR1cm4gcmV0Py5bMF0gPz8gKGF3YWl0IHRoaXMuX21pc3NpbmdGZXRjaEJsb2IocmVhbEtleSwgYWxsT3B0cykpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYlN0b3JlID0gQmxvYlN0b3JlO1xuY2xhc3MgQmFja2VkQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYWNraW5nU3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUgPSBvcHRzLmJhY2tpbmdTdG9yZTtcbiAgICB9XG4gICAgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5tZGVsZXRlKGtleXMpO1xuICAgIH1cbiAgICBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLm1nZXQoa2V5cyk7XG4gICAgfVxuICAgIG1zZXQoa2V5VmFsdWVQYWlycykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUubXNldChrZXlWYWx1ZVBhaXJzKTtcbiAgICB9XG4gICAgeWllbGRLZXlzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUueWllbGRLZXlzKHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrZWRCbG9iU3RvcmUgPSBCYWNrZWRCbG9iU3RvcmU7XG5jbGFzcyBSZWFkVGhyb3VnaEJsb2JTdG9yZSBleHRlbmRzIEJsb2JTdG9yZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhY2tpbmdTdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhc2VTdG9yZSA9IG9wdHMuYmFzZVN0b3JlO1xuICAgICAgICB0aGlzLmJhY2tpbmdTdG9yZSA9IG9wdHMuYmFja2luZ1N0b3JlO1xuICAgIH1cbiAgICBhc3luYyBzdG9yZShibG9iLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxVcmkgPSBhd2FpdCBibG9iLmFzVXJpKCk7XG4gICAgICAgIGNvbnN0IG5ld0Jsb2IgPSBhd2FpdCB0aGlzLmJhY2tpbmdTdG9yZS5zdG9yZShibG9iLCBvcHRzKTtcbiAgICAgICAgaWYgKG5ld0Jsb2IpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmFzZVN0b3JlLm1zZXQoW1tvcmlnaW5hbFVyaSwgbmV3QmxvYl1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QmxvYjtcbiAgICB9XG4gICAgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdG9yZS5tZGVsZXRlKGtleXMpO1xuICAgIH1cbiAgICBtZ2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0b3JlLm1nZXQoa2V5cyk7XG4gICAgfVxuICAgIG1zZXQoX2tleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGNhbGwgUmVhZFRocm91Z2hCbG9iU3RvcmUubXNldCBkaXJlY3RseVwiKTtcbiAgICB9XG4gICAgeWllbGRLZXlzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RvcmUueWllbGRLZXlzKHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkVGhyb3VnaEJsb2JTdG9yZSA9IFJlYWRUaHJvdWdoQmxvYlN0b3JlO1xuY2xhc3MgU2ltcGxlV2ViQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBfbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBmb3IgU2ltcGxlV2ViQmxvYlN0b3JlXCIpO1xuICAgIH1cbiAgICBhc3luYyBoYXNWYWxpZFBhdGgocGF0aCwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuICgoYXdhaXQgc3VwZXIuaGFzVmFsaWRQYXRoKHBhdGgsIHsgcGF0aFByZWZpeDogXCJodHRwczovL1wiIH0pKSB8fFxuICAgICAgICAgICAgKGF3YWl0IHN1cGVyLmhhc1ZhbGlkUGF0aChwYXRoLCB7IHBhdGhQcmVmaXg6IFwiaHR0cDovL1wiIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE1lZGlhQmxvYih7XG4gICAgICAgICAgICBwYXRoOiB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgbWV0YWRhdGEuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXMuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBtZXRhZGF0YS5vayA9IHJlcy5vaztcbiAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzTWVkaWFCbG9iID0gYXdhaXQgTWVkaWFCbG9iLmZyb21CbG9iKGF3YWl0IHJlcy5ibG9iKCkpO1xuICAgICAgICAgICAgcmV0LmRhdGEgPSByZXNNZWRpYUJsb2IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXQubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgbWdldChrZXlzKSB7XG4gICAgICAgIGNvbnN0IGJsb2JNYXAgPSBrZXlzLm1hcCh0aGlzLl9mZXRjaCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChibG9iTWFwKTtcbiAgICB9XG4gICAgYXN5bmMgbWRlbGV0ZShfa2V5cykge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBtc2V0KF9rZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIHRoaXMuX25vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jICp5aWVsZEtleXMoX3ByZWZpeCkge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgICAgICB5aWVsZCBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlV2ViQmxvYlN0b3JlID0gU2ltcGxlV2ViQmxvYlN0b3JlO1xuLyoqXG4gKiBBIGJsb2IgXCJzdG9yZVwiIHRoYXQgd29ya3Mgd2l0aCBkYXRhOiBVUkxzIHRoYXQgd2lsbCB0dXJuIHRoZSBVUkwgaW50b1xuICogYSBibG9iLlxuICovXG5jbGFzcyBEYXRhQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBfbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBmb3IgRGF0YUJsb2JTdG9yZVwiKTtcbiAgICB9XG4gICAgaGFzVmFsaWRQYXRoKHBhdGgsIF9vcHRzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5oYXNWYWxpZFBhdGgocGF0aCwgeyBwYXRoUHJlZml4OiBcImRhdGE6XCIgfSk7XG4gICAgfVxuICAgIF9mZXRjaCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhQmxvYi5mcm9tRGF0YVVybCh1cmwpO1xuICAgIH1cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgY29uc3QgYmxvYk1hcCA9IGtleXMubWFwKHRoaXMuX2ZldGNoKTtcbiAgICAgICAgcmV0dXJuIGJsb2JNYXA7XG4gICAgfVxuICAgIGFzeW5jIG1kZWxldGUoX2tleXMpIHtcbiAgICAgICAgdGhpcy5fbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgbXNldChfa2V5VmFsdWVQYWlycykge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyAqeWllbGRLZXlzKF9wcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKTtcbiAgICAgICAgeWllbGQgXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFCbG9iU3RvcmUgPSBEYXRhQmxvYlN0b3JlO1xuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgY29udmVydGluZyBhIFVSSSAodHlwaWNhbGx5IGEgd2ViIFVSTCkgaW50byBhIE1lZGlhQmxvYi5cbiAqIEFsbG93cyBmb3IgYWxpYXNpbmcgLyBjYWNoaW5nIG9mIHRoZSByZXF1ZXN0ZWQgVVJJIGFuZCB3aGF0IGl0IHJlc29sdmVzIHRvLlxuICogVGhpcyBNZWRpYUJsb2IgaXMgZXhwZWN0ZWQgdG8gYmUgdXNhYmxlIHRvIHByb3ZpZGUgdG8gYW4gTExNLCBlaXRoZXJcbiAqIHRocm91Z2ggdGhlIEJhc2U2NCBvZiB0aGUgbWVkaWEgb3IgdGhyb3VnaCBhIGNhbm9uaWNhbCBVUkkgdGhhdCB0aGUgTExNXG4gKiBzdXBwb3J0cy5cbiAqL1xuY2xhc3MgTWVkaWFNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzb2x2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBjb25maWcuc3RvcmU7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzID0gY29uZmlnLnJlc29sdmVycztcbiAgICB9XG4gICAgZGVmYXVsdFJlc29sdmVycygpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgRGF0YUJsb2JTdG9yZSh7fSksIG5ldyBTaW1wbGVXZWJCbG9iU3RvcmUoe30pXTtcbiAgICB9XG4gICAgYXN5bmMgX2lzSW52YWxpZChibG9iKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYmxvYiA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHB1YmxpYyBVUkksIGxvYWQgd2hhdCBpcyBhdCB0aGlzIFVSSSBhbmQgc2F2ZSBpdFxuICAgICAqIGluIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBVUkkgdG8gcmVzb2x2ZSB1c2luZyB0aGUgcmVzb2x2ZXJcbiAgICAgKiBAcmV0dXJuIEEgY2Fub25pY2FsIE1lZGlhQmxvYiBmb3IgdGhpcyBVUklcbiAgICAgKi9cbiAgICBhc3luYyBfcmVzb2x2ZUFuZFNhdmUodXJpKSB7XG4gICAgICAgIGxldCByZXNvbHZlZEJsb2I7XG4gICAgICAgIGNvbnN0IHJlc29sdmVycyA9IHRoaXMucmVzb2x2ZXJzIHx8IHRoaXMuZGVmYXVsdFJlc29sdmVycygpO1xuICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgcmVzb2x2ZXJzLmxlbmd0aDsgY28gKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlcnNbY29dO1xuICAgICAgICAgICAgaWYgKGF3YWl0IHJlc29sdmVyLmhhc1ZhbGlkUGF0aCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRCbG9iID0gYXdhaXQgcmVzb2x2ZXIuZmV0Y2godXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWRCbG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdG9yZS5zdG9yZShyZXNvbHZlZEJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUJsb2Ioe30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE1lZGlhQmxvYih1cmkpIHtcbiAgICAgICAgY29uc3QgYWxpYXNCbG9iID0gYXdhaXQgdGhpcy5zdG9yZS5mZXRjaCh1cmkpO1xuICAgICAgICBjb25zdCByZXQgPSAoYXdhaXQgdGhpcy5faXNJbnZhbGlkKGFsaWFzQmxvYikpXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX3Jlc29sdmVBbmRTYXZlKHVyaSlcbiAgICAgICAgICAgIDogYWxpYXNCbG9iO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWVkaWFNYW5hZ2VyID0gTWVkaWFNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLGlGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywrRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLCtGQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUlBQXNDO0FBQzNELGFBQWEsbUJBQU8sQ0FBQywrRkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvaW5kZXguY2pzPzc5NjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGF0X21vZGVscy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xsbXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbWJlZGRpbmdzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXV0aC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3N0cmVhbS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL2NvbW1vbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3NhZmV0eS5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/llms.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleBaseLLM = void 0;\nconst manager_1 = __webpack_require__(/*! @langchain/core/callbacks/manager */ \"(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\");\nconst llms_1 = __webpack_require__(/*! @langchain/core/language_models/llms */ \"(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst chat_models_js_1 = __webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\");\nclass GoogleLLMConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    async formatContents(input, _parameters) {\n        const parts = await this.api.messageContentToParts(input);\n        const contents = [\n            {\n                role: \"user\",\n                parts,\n            },\n        ];\n        return contents;\n    }\n}\nclass ProxyChatGoogle extends chat_models_js_1.ChatGoogleBase {\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return fields.connection.client;\n    }\n}\n/**\n * Integration with an LLM.\n */\nclass GoogleBaseLLM extends llms_1.LLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"originalFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"responseMimeType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text/plain\"\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.originalFields = fields;\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    // Replace\n    _llmType() {\n        return \"googlellm\";\n    }\n    formatPrompt(prompt) {\n        return prompt;\n    }\n    /**\n     * For some given input string and options, return a string output.\n     *\n     * Despite the fact that `invoke` is overridden below, we still need this\n     * in order to handle public APi calls to `generate()`.\n     */\n    async _call(prompt, options) {\n        const parameters = (0, common_js_1.copyAIModelParams)(this, options);\n        const result = await this.connection.request(prompt, parameters, options);\n        const ret = this.connection.api.safeResponseToString(result, this.safetyHandler);\n        return ret;\n    }\n    // Normally, you should not override this method and instead should override\n    // _streamResponseChunks. We are doing so here to allow for multimodal inputs into\n    // the LLM.\n    async *_streamIterator(input, options) {\n        // TODO: Refactor callback setup and teardown code into core\n        const prompt = llms_1.BaseLLM._convertInputToPromptValue(input);\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await manager_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: callOptions,\n            invocation_params: this?.invocationParams(callOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n        let generation = new outputs_1.GenerationChunk({\n            text: \"\",\n        });\n        const proxyChat = this.createProxyChat();\n        try {\n            for await (const chunk of proxyChat._streamIterator(input, options)) {\n                const stringValue = this.connection.api.chunkToString(chunk);\n                const generationChunk = new outputs_1.GenerationChunk({\n                    text: stringValue,\n                });\n                generation = generation.concat(generationChunk);\n                yield stringValue;\n            }\n        }\n        catch (err) {\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n            throw err;\n        }\n        await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n            generations: [[generation]],\n        })));\n    }\n    async predictMessages(messages, options, _callbacks) {\n        const { content } = messages[0];\n        const result = await this.connection.request(content, {}, options);\n        const ret = this.connection.api.safeResponseToBaseMessage(result, this.safetyHandler);\n        return ret;\n    }\n    /**\n     * Internal implementation detail to allow Google LLMs to support\n     * multimodal input by delegating to the chat model implementation.\n     *\n     * TODO: Replace with something less hacky.\n     */\n    createProxyChat() {\n        return new ProxyChatGoogle({\n            ...this.originalFields,\n            connection: this.connection,\n        });\n    }\n    // TODO: Remove the need to override this - we are doing it to\n    // allow the LLM to handle multimodal types of input.\n    async invoke(input, options) {\n        const stream = await this._streamIterator(input, options);\n        let generatedOutput = \"\";\n        for await (const chunk of stream) {\n            generatedOutput += chunk;\n        }\n        return generatedOutput;\n    }\n}\nexports.GoogleBaseLLM = GoogleBaseLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvbGxtcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFtQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsMkdBQXNDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNsRCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSx5QkFBeUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEUsNERBQTRELG9CQUFvQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTEFBK0wsdUJBQXVCO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2xsbXMuY2pzPzdiOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUJhc2VMTE0gPSB2b2lkIDA7XG5jb25zdCBtYW5hZ2VyXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyXCIpO1xuY29uc3QgbGxtc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvbGxtc1wiKTtcbmNvbnN0IG91dHB1dHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0c1wiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBjb25uZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvY29tbW9uLmNqc1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY29uc3QgZmFpbGVkX2hhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZhaWxlZF9oYW5kbGVyLmNqc1wiKTtcbmNvbnN0IGNoYXRfbW9kZWxzX2pzXzEgPSByZXF1aXJlKFwiLi9jaGF0X21vZGVscy5janNcIik7XG5jbGFzcyBHb29nbGVMTE1Db25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbiB7XG4gICAgYXN5bmMgZm9ybWF0Q29udGVudHMoaW5wdXQsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgdGhpcy5hcGkubWVzc2FnZUNvbnRlbnRUb1BhcnRzKGlucHV0KTtcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfVxufVxuY2xhc3MgUHJveHlDaGF0R29vZ2xlIGV4dGVuZHMgY2hhdF9tb2RlbHNfanNfMS5DaGF0R29vZ2xlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5jb25uZWN0aW9uLmNsaWVudDtcbiAgICB9XG59XG4vKipcbiAqIEludGVncmF0aW9uIHdpdGggYW4gTExNLlxuICovXG5jbGFzcyBHb29nbGVCYXNlTExNIGV4dGVuZHMgbGxtc18xLkxMTSB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHb29nbGVMTE1cIjtcbiAgICB9XG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoT3B0aW9uczogXCJHT09HTEVfQVVUSF9PUFRJT05TXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigoMCwgZmFpbGVkX2hhbmRsZXJfanNfMS5lbnN1cmVQYXJhbXMpKGZpZWxkcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbEZpZWxkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJnZW1pbmktcHJvXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImdlbWluaS1wcm9cIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcGVyYXR1cmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDAuN1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4T3V0cHV0VG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMDI0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BQXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcEtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wU2VxdWVuY2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FmZXR5U2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYWZldHlIYW5kbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlTWltZVR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWVkQ29ubmVjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRmllbGRzID0gZmllbGRzO1xuICAgICAgICAoMCwgY29tbW9uX2pzXzEuY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvKShmaWVsZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmV0eUhhbmRsZXIgPVxuICAgICAgICAgICAgZmllbGRzPy5zYWZldHlIYW5kbGVyID8/IG5ldyBnZW1pbmlfanNfMS5EZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlcigpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmJ1aWxkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIHRoaXMuYnVpbGRDb25uZWN0aW9uKGZpZWxkcyA/PyB7fSwgY2xpZW50KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkFwaUtleUdvb2dsZUF1dGgoYXBpS2V5KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXkoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM/LmFwaUtleSA/PyAoMCwgZW52XzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJHT09HTEVfQVBJX0tFWVwiKTtcbiAgICB9XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYnVpbGRBcGlLZXkoZmllbGRzKTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ29ubmVjdGlvbihmaWVsZHMsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgR29vZ2xlTExNQ29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgY2xpZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RyZWFtZWRDb25uZWN0aW9uID0gbmV3IEdvb2dsZUxMTUNvbm5lY3Rpb24oeyAuLi5maWVsZHMsIC4uLnRoaXMgfSwgdGhpcy5jYWxsZXIsIGNsaWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldCBwbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5wbGF0Zm9ybTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZVxuICAgIF9sbG1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnb29nbGVsbG1cIjtcbiAgICB9XG4gICAgZm9ybWF0UHJvbXB0KHByb21wdCkge1xuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3Igc29tZSBnaXZlbiBpbnB1dCBzdHJpbmcgYW5kIG9wdGlvbnMsIHJldHVybiBhIHN0cmluZyBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBEZXNwaXRlIHRoZSBmYWN0IHRoYXQgYGludm9rZWAgaXMgb3ZlcnJpZGRlbiBiZWxvdywgd2Ugc3RpbGwgbmVlZCB0aGlzXG4gICAgICogaW4gb3JkZXIgdG8gaGFuZGxlIHB1YmxpYyBBUGkgY2FsbHMgdG8gYGdlbmVyYXRlKClgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHByb21wdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gKDAsIGNvbW1vbl9qc18xLmNvcHlBSU1vZGVsUGFyYW1zKSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QocHJvbXB0LCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5jb25uZWN0aW9uLmFwaS5zYWZlUmVzcG9uc2VUb1N0cmluZyhyZXN1bHQsIHRoaXMuc2FmZXR5SGFuZGxlcik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8vIE5vcm1hbGx5LCB5b3Ugc2hvdWxkIG5vdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmQgaW5zdGVhZCBzaG91bGQgb3ZlcnJpZGVcbiAgICAvLyBfc3RyZWFtUmVzcG9uc2VDaHVua3MuIFdlIGFyZSBkb2luZyBzbyBoZXJlIHRvIGFsbG93IGZvciBtdWx0aW1vZGFsIGlucHV0cyBpbnRvXG4gICAgLy8gdGhlIExMTS5cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIGNhbGxiYWNrIHNldHVwIGFuZCB0ZWFyZG93biBjb2RlIGludG8gY29yZVxuICAgICAgICBjb25zdCBwcm9tcHQgPSBsbG1zXzEuQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIHJ1bm5hYmxlQ29uZmlnLnRhZ3MsIHRoaXMudGFncywgcnVubmFibGVDb25maWcubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMoY2FsbE9wdGlvbnMpLFxuICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBbcHJvbXB0LnRvU3RyaW5nKCldLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGdlbmVyYXRpb24gPSBuZXcgb3V0cHV0c18xLkdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJveHlDaGF0ID0gdGhpcy5jcmVhdGVQcm94eUNoYXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcHJveHlDaGF0Ll9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHRoaXMuY29ubmVjdGlvbi5hcGkuY2h1bmtUb1N0cmluZyhjaHVuayk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGlvbkNodW5rID0gbmV3IG91dHB1dHNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdHJpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gZ2VuZXJhdGlvbi5jb25jYXQoZ2VuZXJhdGlvbkNodW5rKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtbZ2VuZXJhdGlvbl1dLFxuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBwcmVkaWN0TWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMsIF9jYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50IH0gPSBtZXNzYWdlc1swXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QoY29udGVudCwge30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLmNvbm5lY3Rpb24uYXBpLnNhZmVSZXNwb25zZVRvQmFzZU1lc3NhZ2UocmVzdWx0LCB0aGlzLnNhZmV0eUhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdG8gYWxsb3cgR29vZ2xlIExMTXMgdG8gc3VwcG9ydFxuICAgICAqIG11bHRpbW9kYWwgaW5wdXQgYnkgZGVsZWdhdGluZyB0byB0aGUgY2hhdCBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgbGVzcyBoYWNreS5cbiAgICAgKi9cbiAgICBjcmVhdGVQcm94eUNoYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHlDaGF0R29vZ2xlKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3JpZ2luYWxGaWVsZHMsXG4gICAgICAgICAgICBjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyAtIHdlIGFyZSBkb2luZyBpdCB0b1xuICAgIC8vIGFsbG93IHRoZSBMTE0gdG8gaGFuZGxlIG11bHRpbW9kYWwgdHlwZXMgb2YgaW5wdXQuXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGdlbmVyYXRlZE91dHB1dCA9IFwiXCI7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWRPdXRwdXQgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZE91dHB1dDtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUJhc2VMTE0gPSBHb29nbGVCYXNlTExNO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/types.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/types.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3R5cGVzLmNqcz8xMjVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/common.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyAndValidateModelParamsInto = exports.validateModelParams = exports.modelToFamily = exports.copyAIModelParamsInto = exports.convertToGeminiTools = exports.copyAIModelParams = void 0;\nconst base_1 = __webpack_require__(/*! @langchain/core/language_models/base */ \"(rsc)/./node_modules/@langchain/core/language_models/base.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nfunction copyAIModelParams(params, options) {\n    return copyAIModelParamsInto(params, options, {});\n}\nexports.copyAIModelParams = copyAIModelParams;\nfunction processToolChoice(toolChoice, allowedFunctionNames) {\n    if (!toolChoice) {\n        if (allowedFunctionNames) {\n            // Allowed func names is passed, return 'any' so it forces the model to use a tool.\n            return {\n                tool_choice: \"any\",\n                allowed_function_names: allowedFunctionNames,\n            };\n        }\n        return undefined;\n    }\n    if (toolChoice === \"any\" || toolChoice === \"auto\" || toolChoice === \"none\") {\n        return {\n            tool_choice: toolChoice,\n            allowed_function_names: allowedFunctionNames,\n        };\n    }\n    if (typeof toolChoice === \"string\") {\n        // String representing the function name.\n        // Return any to force the model to predict the specified function call.\n        return {\n            tool_choice: \"any\",\n            allowed_function_names: [...(allowedFunctionNames ?? []), toolChoice],\n        };\n    }\n    throw new Error(\"Object inputs for tool_choice not supported.\");\n}\nfunction convertToGeminiTools(tools) {\n    const geminiTools = [\n        {\n            functionDeclarations: [],\n        },\n    ];\n    tools.forEach((tool) => {\n        if (\"functionDeclarations\" in tool &&\n            Array.isArray(tool.functionDeclarations)) {\n            const funcs = tool.functionDeclarations;\n            geminiTools[0].functionDeclarations?.push(...funcs);\n        }\n        else if ((0, function_calling_1.isLangChainTool)(tool)) {\n            const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n            geminiTools[0].functionDeclarations?.push({\n                name: tool.name,\n                description: tool.description ?? `A function available to call.`,\n                parameters: jsonSchema,\n            });\n        }\n        else if ((0, base_1.isOpenAITool)(tool)) {\n            geminiTools[0].functionDeclarations?.push({\n                name: tool.function.name,\n                description: tool.function.description ?? `A function available to call.`,\n                parameters: (0, zod_to_gemini_parameters_js_1.jsonSchemaToGeminiParameters)(tool.function.parameters),\n            });\n        }\n    });\n    return geminiTools;\n}\nexports.convertToGeminiTools = convertToGeminiTools;\nfunction copyAIModelParamsInto(params, options, target) {\n    const ret = target || {};\n    const model = options?.model ?? params?.model ?? target.model;\n    ret.modelName =\n        model ?? options?.modelName ?? params?.modelName ?? target.modelName;\n    ret.model = model;\n    ret.temperature =\n        options?.temperature ?? params?.temperature ?? target.temperature;\n    ret.maxOutputTokens =\n        options?.maxOutputTokens ??\n            params?.maxOutputTokens ??\n            target.maxOutputTokens;\n    ret.topP = options?.topP ?? params?.topP ?? target.topP;\n    ret.topK = options?.topK ?? params?.topK ?? target.topK;\n    ret.stopSequences =\n        options?.stopSequences ?? params?.stopSequences ?? target.stopSequences;\n    ret.safetySettings =\n        options?.safetySettings ?? params?.safetySettings ?? target.safetySettings;\n    ret.convertSystemMessageToHumanContent =\n        options?.convertSystemMessageToHumanContent ??\n            params?.convertSystemMessageToHumanContent ??\n            target?.convertSystemMessageToHumanContent;\n    ret.responseMimeType =\n        options?.responseMimeType ??\n            params?.responseMimeType ??\n            target?.responseMimeType;\n    ret.streaming = options?.streaming ?? params?.streaming ?? target?.streaming;\n    const toolChoice = processToolChoice(options?.tool_choice, options?.allowed_function_names);\n    if (toolChoice) {\n        ret.tool_choice = toolChoice.tool_choice;\n        ret.allowed_function_names = toolChoice.allowed_function_names;\n    }\n    const tools = options?.tools;\n    if (tools) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ret.tools = convertToGeminiTools(tools);\n    }\n    return ret;\n}\nexports.copyAIModelParamsInto = copyAIModelParamsInto;\nfunction modelToFamily(modelName) {\n    if (!modelName) {\n        return null;\n    }\n    else if ((0, gemini_js_1.isModelGemini)(modelName)) {\n        return \"gemini\";\n    }\n    else {\n        return null;\n    }\n}\nexports.modelToFamily = modelToFamily;\nfunction validateModelParams(params) {\n    const testParams = params ?? {};\n    const model = testParams.model ?? testParams.modelName;\n    switch (modelToFamily(model)) {\n        case \"gemini\":\n            return (0, gemini_js_1.validateGeminiParams)(testParams);\n        default:\n            throw new Error(`Unable to verify model params: ${JSON.stringify(params)}`);\n    }\n}\nexports.validateModelParams = validateModelParams;\nfunction copyAndValidateModelParamsInto(params, target) {\n    copyAIModelParamsInto(params, undefined, target);\n    validateModelParams(target);\n    return target;\n}\nexports.copyAndValidateModelParamsInto = copyAndValidateModelParamsInto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvY29tbW9uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDdkwsZUFBZSxtQkFBTyxDQUFDLDJHQUFzQztBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQywrR0FBd0M7QUFDM0Usb0JBQW9CLG1CQUFPLENBQUMseUZBQWM7QUFDMUMsc0NBQXNDLG1CQUFPLENBQUMsNkhBQWdDO0FBQzlFO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVCQUF1QjtBQUNyRjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvY29tbW9uLmNqcz85OGM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8gPSBleHBvcnRzLnZhbGlkYXRlTW9kZWxQYXJhbXMgPSBleHBvcnRzLm1vZGVsVG9GYW1pbHkgPSBleHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zSW50byA9IGV4cG9ydHMuY29udmVydFRvR2VtaW5pVG9vbHMgPSBleHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvYmFzZVwiKTtcbmNvbnN0IGZ1bmN0aW9uX2NhbGxpbmdfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZnVuY3Rpb25fY2FsbGluZ1wiKTtcbmNvbnN0IGdlbWluaV9qc18xID0gcmVxdWlyZShcIi4vZ2VtaW5pLmNqc1wiKTtcbmNvbnN0IHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xID0gcmVxdWlyZShcIi4vem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqc1wiKTtcbmZ1bmN0aW9uIGNvcHlBSU1vZGVsUGFyYW1zKHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBjb3B5QUlNb2RlbFBhcmFtc0ludG8ocGFyYW1zLCBvcHRpb25zLCB7fSk7XG59XG5leHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zID0gY29weUFJTW9kZWxQYXJhbXM7XG5mdW5jdGlvbiBwcm9jZXNzVG9vbENob2ljZSh0b29sQ2hvaWNlLCBhbGxvd2VkRnVuY3Rpb25OYW1lcykge1xuICAgIGlmICghdG9vbENob2ljZSkge1xuICAgICAgICBpZiAoYWxsb3dlZEZ1bmN0aW9uTmFtZXMpIHtcbiAgICAgICAgICAgIC8vIEFsbG93ZWQgZnVuYyBuYW1lcyBpcyBwYXNzZWQsIHJldHVybiAnYW55JyBzbyBpdCBmb3JjZXMgdGhlIG1vZGVsIHRvIHVzZSBhIHRvb2wuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvb2xfY2hvaWNlOiBcImFueVwiLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRfZnVuY3Rpb25fbmFtZXM6IGFsbG93ZWRGdW5jdGlvbk5hbWVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodG9vbENob2ljZSA9PT0gXCJhbnlcIiB8fCB0b29sQ2hvaWNlID09PSBcImF1dG9cIiB8fCB0b29sQ2hvaWNlID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9vbF9jaG9pY2U6IHRvb2xDaG9pY2UsXG4gICAgICAgICAgICBhbGxvd2VkX2Z1bmN0aW9uX25hbWVzOiBhbGxvd2VkRnVuY3Rpb25OYW1lcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICAgIC8vIFJldHVybiBhbnkgdG8gZm9yY2UgdGhlIG1vZGVsIHRvIHByZWRpY3QgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjYWxsLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9vbF9jaG9pY2U6IFwiYW55XCIsXG4gICAgICAgICAgICBhbGxvd2VkX2Z1bmN0aW9uX25hbWVzOiBbLi4uKGFsbG93ZWRGdW5jdGlvbk5hbWVzID8/IFtdKSwgdG9vbENob2ljZV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBpbnB1dHMgZm9yIHRvb2xfY2hvaWNlIG5vdCBzdXBwb3J0ZWQuXCIpO1xufVxuZnVuY3Rpb24gY29udmVydFRvR2VtaW5pVG9vbHModG9vbHMpIHtcbiAgICBjb25zdCBnZW1pbmlUb29scyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtdLFxuICAgICAgICB9LFxuICAgIF07XG4gICAgdG9vbHMuZm9yRWFjaCgodG9vbCkgPT4ge1xuICAgICAgICBpZiAoXCJmdW5jdGlvbkRlY2xhcmF0aW9uc1wiIGluIHRvb2wgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmNzID0gdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgICAgIGdlbWluaVRvb2xzWzBdLmZ1bmN0aW9uRGVjbGFyYXRpb25zPy5wdXNoKC4uLmZ1bmNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgZnVuY3Rpb25fY2FsbGluZ18xLmlzTGFuZ0NoYWluVG9vbCkodG9vbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TY2hlbWEgPSAoMCwgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEuem9kVG9HZW1pbmlQYXJhbWV0ZXJzKSh0b29sLnNjaGVtYSk7XG4gICAgICAgICAgICBnZW1pbmlUb29sc1swXS5mdW5jdGlvbkRlY2xhcmF0aW9ucz8ucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uID8/IGBBIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsLmAsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoganNvblNjaGVtYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBiYXNlXzEuaXNPcGVuQUlUb29sKSh0b29sKSkge1xuICAgICAgICAgICAgZ2VtaW5pVG9vbHNbMF0uZnVuY3Rpb25EZWNsYXJhdGlvbnM/LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbiA/PyBgQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5gLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6ICgwLCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMS5qc29uU2NoZW1hVG9HZW1pbmlQYXJhbWV0ZXJzKSh0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VtaW5pVG9vbHM7XG59XG5leHBvcnRzLmNvbnZlcnRUb0dlbWluaVRvb2xzID0gY29udmVydFRvR2VtaW5pVG9vbHM7XG5mdW5jdGlvbiBjb3B5QUlNb2RlbFBhcmFtc0ludG8ocGFyYW1zLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICBjb25zdCByZXQgPSB0YXJnZXQgfHwge307XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zPy5tb2RlbCA/PyBwYXJhbXM/Lm1vZGVsID8/IHRhcmdldC5tb2RlbDtcbiAgICByZXQubW9kZWxOYW1lID1cbiAgICAgICAgbW9kZWwgPz8gb3B0aW9ucz8ubW9kZWxOYW1lID8/IHBhcmFtcz8ubW9kZWxOYW1lID8/IHRhcmdldC5tb2RlbE5hbWU7XG4gICAgcmV0Lm1vZGVsID0gbW9kZWw7XG4gICAgcmV0LnRlbXBlcmF0dXJlID1cbiAgICAgICAgb3B0aW9ucz8udGVtcGVyYXR1cmUgPz8gcGFyYW1zPy50ZW1wZXJhdHVyZSA/PyB0YXJnZXQudGVtcGVyYXR1cmU7XG4gICAgcmV0Lm1heE91dHB1dFRva2VucyA9XG4gICAgICAgIG9wdGlvbnM/Lm1heE91dHB1dFRva2VucyA/P1xuICAgICAgICAgICAgcGFyYW1zPy5tYXhPdXRwdXRUb2tlbnMgPz9cbiAgICAgICAgICAgIHRhcmdldC5tYXhPdXRwdXRUb2tlbnM7XG4gICAgcmV0LnRvcFAgPSBvcHRpb25zPy50b3BQID8/IHBhcmFtcz8udG9wUCA/PyB0YXJnZXQudG9wUDtcbiAgICByZXQudG9wSyA9IG9wdGlvbnM/LnRvcEsgPz8gcGFyYW1zPy50b3BLID8/IHRhcmdldC50b3BLO1xuICAgIHJldC5zdG9wU2VxdWVuY2VzID1cbiAgICAgICAgb3B0aW9ucz8uc3RvcFNlcXVlbmNlcyA/PyBwYXJhbXM/LnN0b3BTZXF1ZW5jZXMgPz8gdGFyZ2V0LnN0b3BTZXF1ZW5jZXM7XG4gICAgcmV0LnNhZmV0eVNldHRpbmdzID1cbiAgICAgICAgb3B0aW9ucz8uc2FmZXR5U2V0dGluZ3MgPz8gcGFyYW1zPy5zYWZldHlTZXR0aW5ncyA/PyB0YXJnZXQuc2FmZXR5U2V0dGluZ3M7XG4gICAgcmV0LmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPVxuICAgICAgICBvcHRpb25zPy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50ID8/XG4gICAgICAgICAgICBwYXJhbXM/LmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPz9cbiAgICAgICAgICAgIHRhcmdldD8uY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudDtcbiAgICByZXQucmVzcG9uc2VNaW1lVHlwZSA9XG4gICAgICAgIG9wdGlvbnM/LnJlc3BvbnNlTWltZVR5cGUgPz9cbiAgICAgICAgICAgIHBhcmFtcz8ucmVzcG9uc2VNaW1lVHlwZSA/P1xuICAgICAgICAgICAgdGFyZ2V0Py5yZXNwb25zZU1pbWVUeXBlO1xuICAgIHJldC5zdHJlYW1pbmcgPSBvcHRpb25zPy5zdHJlYW1pbmcgPz8gcGFyYW1zPy5zdHJlYW1pbmcgPz8gdGFyZ2V0Py5zdHJlYW1pbmc7XG4gICAgY29uc3QgdG9vbENob2ljZSA9IHByb2Nlc3NUb29sQ2hvaWNlKG9wdGlvbnM/LnRvb2xfY2hvaWNlLCBvcHRpb25zPy5hbGxvd2VkX2Z1bmN0aW9uX25hbWVzKTtcbiAgICBpZiAodG9vbENob2ljZSkge1xuICAgICAgICByZXQudG9vbF9jaG9pY2UgPSB0b29sQ2hvaWNlLnRvb2xfY2hvaWNlO1xuICAgICAgICByZXQuYWxsb3dlZF9mdW5jdGlvbl9uYW1lcyA9IHRvb2xDaG9pY2UuYWxsb3dlZF9mdW5jdGlvbl9uYW1lcztcbiAgICB9XG4gICAgY29uc3QgdG9vbHMgPSBvcHRpb25zPy50b29scztcbiAgICBpZiAodG9vbHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0LnRvb2xzID0gY29udmVydFRvR2VtaW5pVG9vbHModG9vbHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5jb3B5QUlNb2RlbFBhcmFtc0ludG8gPSBjb3B5QUlNb2RlbFBhcmFtc0ludG87XG5mdW5jdGlvbiBtb2RlbFRvRmFtaWx5KG1vZGVsTmFtZSkge1xuICAgIGlmICghbW9kZWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgZ2VtaW5pX2pzXzEuaXNNb2RlbEdlbWluaSkobW9kZWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJnZW1pbmlcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMubW9kZWxUb0ZhbWlseSA9IG1vZGVsVG9GYW1pbHk7XG5mdW5jdGlvbiB2YWxpZGF0ZU1vZGVsUGFyYW1zKHBhcmFtcykge1xuICAgIGNvbnN0IHRlc3RQYXJhbXMgPSBwYXJhbXMgPz8ge307XG4gICAgY29uc3QgbW9kZWwgPSB0ZXN0UGFyYW1zLm1vZGVsID8/IHRlc3RQYXJhbXMubW9kZWxOYW1lO1xuICAgIHN3aXRjaCAobW9kZWxUb0ZhbWlseShtb2RlbCkpIHtcbiAgICAgICAgY2FzZSBcImdlbWluaVwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBnZW1pbmlfanNfMS52YWxpZGF0ZUdlbWluaVBhcmFtcykodGVzdFBhcmFtcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB2ZXJpZnkgbW9kZWwgcGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KHBhcmFtcyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZU1vZGVsUGFyYW1zID0gdmFsaWRhdGVNb2RlbFBhcmFtcztcbmZ1bmN0aW9uIGNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIHRhcmdldCkge1xuICAgIGNvcHlBSU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICB2YWxpZGF0ZU1vZGVsUGFyYW1zKHRhcmdldCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMuY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvID0gY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureParams = exports.failedAttemptHandler = void 0;\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction failedAttemptHandler(error) {\n    const status = error?.response?.status ?? 0;\n    if (status === 0) {\n        // What is this?\n        console.error(\"failedAttemptHandler\", error);\n    }\n    // What errors shouldn't be retried?\n    if (STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    throw error;\n}\nexports.failedAttemptHandler = failedAttemptHandler;\nfunction ensureParams(params) {\n    const base = params ?? {};\n    return {\n        onFailedAttempt: failedAttemptHandler,\n        ...base,\n    };\n}\nexports.ensureParams = ensureParams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9mYWlsZWRfaGFuZGxlci5janM/ODEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5zdXJlUGFyYW1zID0gZXhwb3J0cy5mYWlsZWRBdHRlbXB0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsXG4gICAgNDAxLFxuICAgIDQwMixcbiAgICA0MDMsXG4gICAgNDA0LFxuICAgIDQwNSxcbiAgICA0MDYsXG4gICAgNDA3LFxuICAgIDQwOCxcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGZhaWxlZEF0dGVtcHRIYW5kbGVyKGVycm9yKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPz8gMDtcbiAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgIC8vIFdoYXQgaXMgdGhpcz9cbiAgICAgICAgY29uc29sZS5lcnJvcihcImZhaWxlZEF0dGVtcHRIYW5kbGVyXCIsIGVycm9yKTtcbiAgICB9XG4gICAgLy8gV2hhdCBlcnJvcnMgc2hvdWxkbid0IGJlIHJldHJpZWQ/XG4gICAgaWYgKFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5leHBvcnRzLmZhaWxlZEF0dGVtcHRIYW5kbGVyID0gZmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG5mdW5jdGlvbiBlbnN1cmVQYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgYmFzZSA9IHBhcmFtcyA/PyB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IGZhaWxlZEF0dGVtcHRIYW5kbGVyLFxuICAgICAgICAuLi5iYXNlLFxuICAgIH07XG59XG5leHBvcnRzLmVuc3VyZVBhcmFtcyA9IGVuc3VyZVBhcmFtcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/gemini.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageGeminiSafetyHandler = exports.DefaultGeminiSafetyHandler = exports.isModelGemini = exports.validateGeminiParams = exports.getGeminiAPI = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst safety_js_1 = __webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\");\nconst extractMimeType = (str) => {\n    if (str.startsWith(\"data:\")) {\n        return {\n            mimeType: str.split(\":\")[1].split(\";\")[0],\n            data: str.split(\",\")[1],\n        };\n    }\n    return null;\n};\nfunction getGeminiAPI(config) {\n    function messageContentText(content) {\n        if (content?.text && content?.text.length > 0) {\n            return {\n                text: content.text,\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    function messageContentImageUrl(content) {\n        const url = typeof content.image_url === \"string\"\n            ? content.image_url\n            : content.image_url.url;\n        if (!url) {\n            throw new Error(\"Missing Image URL\");\n        }\n        const mineTypeAndData = extractMimeType(url);\n        if (mineTypeAndData) {\n            return {\n                inlineData: mineTypeAndData,\n            };\n        }\n        else {\n            // FIXME - need some way to get mime type\n            return {\n                fileData: {\n                    mimeType: \"image/png\",\n                    fileUri: url,\n                },\n            };\n        }\n    }\n    async function blobToFileData(blob) {\n        return {\n            fileData: {\n                fileUri: blob.path,\n                mimeType: blob.mimetype,\n            },\n        };\n    }\n    async function fileUriContentToBlob(uri) {\n        return config?.mediaManager?.getMediaBlob(uri);\n    }\n    async function messageContentMedia(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content) {\n        if (\"mimeType\" in content && \"data\" in content) {\n            return {\n                inlineData: {\n                    mimeType: content.mimeType,\n                    data: content.data,\n                },\n            };\n        }\n        else if (\"mimeType\" in content && \"fileUri\" in content) {\n            return {\n                fileData: {\n                    mimeType: content.mimeType,\n                    fileUri: content.fileUri,\n                },\n            };\n        }\n        else {\n            const uri = content.fileUri;\n            const blob = await fileUriContentToBlob(uri);\n            if (blob) {\n                return await blobToFileData(blob);\n            }\n        }\n        throw new Error(\"Invalid media content\");\n    }\n    async function messageContentComplexToPart(content) {\n        switch (content.type) {\n            case \"text\":\n                if (\"text\" in content) {\n                    return messageContentText(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return messageContentImageUrl(content);\n                }\n                break;\n            case \"media\":\n                return await messageContentMedia(content);\n            default:\n                throw new Error(`Unsupported type received while converting message to message parts`);\n        }\n        throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n    }\n    async function messageContentComplexToParts(content) {\n        const contents = content.map(messageContentComplexToPart);\n        return Promise.all(contents);\n    }\n    async function messageContentToParts(content) {\n        // Convert a string to a text type MessageContent if needed\n        const messageContent = typeof content === \"string\"\n            ? [\n                {\n                    type: \"text\",\n                    text: content,\n                },\n            ]\n            : content;\n        // Get all of the parts, even those that don't correctly resolve\n        const allParts = await messageContentComplexToParts(messageContent);\n        // Remove any invalid parts\n        const parts = allParts.reduce((acc, val) => {\n            if (val) {\n                return [...acc, val];\n            }\n            else {\n                return acc;\n            }\n        }, []);\n        return parts;\n    }\n    function messageToolCallsToParts(toolCalls) {\n        if (!toolCalls || toolCalls.length === 0) {\n            return [];\n        }\n        return toolCalls.map((tool) => {\n            let args = {};\n            if (tool?.function?.arguments) {\n                const argStr = tool.function.arguments;\n                args = JSON.parse(argStr);\n            }\n            return {\n                functionCall: {\n                    name: tool.function.name,\n                    args,\n                },\n            };\n        });\n    }\n    function messageKwargsToParts(kwargs) {\n        const ret = [];\n        if (kwargs?.tool_calls) {\n            ret.push(...messageToolCallsToParts(kwargs.tool_calls));\n        }\n        return ret;\n    }\n    async function roleMessageToContent(role, message) {\n        const contentParts = await messageContentToParts(message.content);\n        let toolParts;\n        if ((0, messages_1.isAIMessage)(message) && !!message.tool_calls?.length) {\n            toolParts = message.tool_calls.map((toolCall) => ({\n                functionCall: {\n                    name: toolCall.name,\n                    args: toolCall.args,\n                },\n            }));\n        }\n        else {\n            toolParts = messageKwargsToParts(message.additional_kwargs);\n        }\n        const parts = [...contentParts, ...toolParts];\n        return [\n            {\n                role,\n                parts,\n            },\n        ];\n    }\n    async function systemMessageToContent(message, useSystemInstruction) {\n        return useSystemInstruction\n            ? roleMessageToContent(\"system\", message)\n            : [\n                ...(await roleMessageToContent(\"user\", message)),\n                ...(await roleMessageToContent(\"model\", new messages_1.AIMessage(\"Ok\"))),\n            ];\n    }\n    function toolMessageToContent(message, prevMessage) {\n        const contentStr = typeof message.content === \"string\"\n            ? message.content\n            : message.content.reduce((acc, content) => {\n                if (content.type === \"text\") {\n                    return acc + content.text;\n                }\n                else {\n                    return acc;\n                }\n            }, \"\");\n        // Hacky :(\n        const responseName = ((0, messages_1.isAIMessage)(prevMessage) && !!prevMessage.tool_calls?.length\n            ? prevMessage.tool_calls[0].name\n            : prevMessage.name) ?? message.tool_call_id;\n        try {\n            const content = JSON.parse(contentStr);\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n        catch (_) {\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content: contentStr },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n    }\n    async function baseMessageToContent(message, prevMessage, useSystemInstruction) {\n        const type = message._getType();\n        switch (type) {\n            case \"system\":\n                return systemMessageToContent(message, useSystemInstruction);\n            case \"human\":\n                return roleMessageToContent(\"user\", message);\n            case \"ai\":\n                return roleMessageToContent(\"model\", message);\n            case \"tool\":\n                if (!prevMessage) {\n                    throw new Error(\"Tool messages cannot be the first message passed to the model.\");\n                }\n                return toolMessageToContent(message, prevMessage);\n            default:\n                console.log(`Unsupported message type: ${type}`);\n                return [];\n        }\n    }\n    function textPartToMessageContent(part) {\n        return {\n            type: \"text\",\n            text: part.text,\n        };\n    }\n    function inlineDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,\n        };\n    }\n    function fileDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: part.fileData.fileUri,\n        };\n    }\n    function partsToMessageContent(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"text\" in part) {\n                return textPartToMessageContent(part);\n            }\n            else if (\"inlineData\" in part) {\n                return inlineDataPartToMessageContent(part);\n            }\n            else if (\"fileData\" in part) {\n                return fileDataPartToMessageContent(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolRawToTool(raw) {\n        return {\n            id: raw.id,\n            type: raw.type,\n            function: {\n                name: raw.function.name,\n                arguments: JSON.stringify(raw.function.arguments),\n            },\n        };\n    }\n    function functionCallPartToToolRaw(part) {\n        return {\n            id: (0, uuid_1.v4)().replace(/-/g, \"\"),\n            type: \"function\",\n            function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args ?? {},\n            },\n        };\n    }\n    function partsToToolsRaw(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"functionCall\" in part) {\n                return functionCallPartToToolRaw(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolsRawToTools(raws) {\n        return raws.map((raw) => toolRawToTool(raw));\n    }\n    function responseToGenerateContentResponseData(response) {\n        if (\"nextChunk\" in response.data) {\n            throw new Error(\"Cannot convert Stream to GenerateContentResponseData\");\n        }\n        else if (Array.isArray(response.data)) {\n            // Collapse the array of response data as if it was a single one\n            return response.data.reduce((acc, val) => {\n                // Add all the parts\n                // FIXME: Handle other candidates?\n                const valParts = val?.candidates?.[0]?.content?.parts ?? [];\n                acc.candidates[0].content.parts.push(...valParts);\n                // FIXME: Merge promptFeedback and safety settings\n                acc.promptFeedback = val.promptFeedback;\n                return acc;\n            });\n        }\n        else {\n            return response.data;\n        }\n    }\n    function responseToParts(response) {\n        const responseData = responseToGenerateContentResponseData(response);\n        const parts = responseData?.candidates?.[0]?.content?.parts ?? [];\n        return parts;\n    }\n    function partToText(part) {\n        return \"text\" in part ? part.text : \"\";\n    }\n    function responseToString(response) {\n        const parts = responseToParts(response);\n        const ret = parts.reduce((acc, part) => {\n            const val = partToText(part);\n            return acc + val;\n        }, \"\");\n        return ret;\n    }\n    function safeResponseTo(response, safetyHandler, responseTo) {\n        try {\n            const safeResponse = safetyHandler.handle(response);\n            return responseTo(safeResponse);\n        }\n        catch (xx) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                const ret = responseTo(xx.response);\n                xx.reply = ret;\n            }\n            throw xx;\n        }\n    }\n    function safeResponseToString(response, safetyHandler) {\n        return safeResponseTo(response, safetyHandler, responseToString);\n    }\n    function responseToGenerationInfo(response) {\n        if (!Array.isArray(response.data)) {\n            return {};\n        }\n        const data = response.data[0];\n        return {\n            usage_metadata: {\n                prompt_token_count: data.usageMetadata?.promptTokenCount,\n                candidates_token_count: data.usageMetadata?.candidatesTokenCount,\n                total_token_count: data.usageMetadata?.totalTokenCount,\n            },\n            safety_ratings: data.candidates[0]?.safetyRatings?.map((rating) => ({\n                category: rating.category,\n                probability: rating.probability,\n                probability_score: rating.probabilityScore,\n                severity: rating.severity,\n                severity_score: rating.severityScore,\n            })),\n            finish_reason: data.candidates[0]?.finishReason,\n        };\n    }\n    function responseToChatGeneration(response) {\n        return new outputs_1.ChatGenerationChunk({\n            text: responseToString(response),\n            message: partToMessageChunk(responseToParts(response)[0]),\n            generationInfo: responseToGenerationInfo(response),\n        });\n    }\n    function safeResponseToChatGeneration(response, safetyHandler) {\n        return safeResponseTo(response, safetyHandler, responseToChatGeneration);\n    }\n    function chunkToString(chunk) {\n        if (chunk === null) {\n            return \"\";\n        }\n        else if (typeof chunk.content === \"string\") {\n            return chunk.content;\n        }\n        else if (chunk.content.length === 0) {\n            return \"\";\n        }\n        else if (chunk.content[0].type === \"text\") {\n            return chunk.content[0].text;\n        }\n        else {\n            throw new Error(`Unexpected chunk: ${chunk}`);\n        }\n    }\n    function partToMessageChunk(part) {\n        const fields = partsToBaseMessageChunkFields([part]);\n        if (typeof fields.content === \"string\") {\n            return new messages_1.AIMessageChunk(fields);\n        }\n        else if (fields.content.every((item) => item.type === \"text\")) {\n            const newContent = fields.content\n                .map((item) => (\"text\" in item ? item.text : \"\"))\n                .join(\"\");\n            return new messages_1.AIMessageChunk({\n                ...fields,\n                content: newContent,\n            });\n        }\n        return new messages_1.AIMessageChunk(fields);\n    }\n    function partToChatGeneration(part) {\n        const message = partToMessageChunk(part);\n        const text = partToText(part);\n        return new outputs_1.ChatGenerationChunk({\n            text,\n            message,\n        });\n    }\n    function responseToChatGenerations(response) {\n        const parts = responseToParts(response);\n        if (parts.length === 0) {\n            return [];\n        }\n        let ret = parts.map((part) => partToChatGeneration(part));\n        if (ret.every((item) => typeof item.message.content === \"string\")) {\n            const combinedContent = ret.map((item) => item.message.content).join(\"\");\n            const combinedText = ret.map((item) => item.text).join(\"\");\n            const toolCallChunks = ret[ret.length - 1]?.message.additional_kwargs?.tool_calls?.map((toolCall, i) => ({\n                name: toolCall.function.name,\n                args: toolCall.function.arguments,\n                id: toolCall.id,\n                index: i,\n                type: \"tool_call_chunk\",\n            }));\n            let usageMetadata;\n            if (\"usageMetadata\" in response.data) {\n                usageMetadata = {\n                    input_tokens: response.data.usageMetadata.promptTokenCount,\n                    output_tokens: response.data.usageMetadata\n                        .candidatesTokenCount,\n                    total_tokens: response.data.usageMetadata.totalTokenCount,\n                };\n            }\n            ret = [\n                new outputs_1.ChatGenerationChunk({\n                    message: new messages_1.AIMessageChunk({\n                        content: combinedContent,\n                        additional_kwargs: ret[ret.length - 1]?.message.additional_kwargs,\n                        tool_call_chunks: toolCallChunks,\n                        usage_metadata: usageMetadata,\n                    }),\n                    text: combinedText,\n                    generationInfo: ret[ret.length - 1].generationInfo,\n                }),\n            ];\n        }\n        return ret;\n    }\n    function responseToBaseMessageFields(response) {\n        const parts = responseToParts(response);\n        return partsToBaseMessageChunkFields(parts);\n    }\n    function partsToBaseMessageChunkFields(parts) {\n        const fields = {\n            content: partsToMessageContent(parts),\n            tool_call_chunks: [],\n            tool_calls: [],\n            invalid_tool_calls: [],\n        };\n        const rawTools = partsToToolsRaw(parts);\n        if (rawTools.length > 0) {\n            const tools = toolsRawToTools(rawTools);\n            for (const tool of tools) {\n                fields.tool_call_chunks?.push({\n                    name: tool.function.name,\n                    args: tool.function.arguments,\n                    id: tool.id,\n                    type: \"tool_call_chunk\",\n                });\n                try {\n                    fields.tool_calls?.push({\n                        name: tool.function.name,\n                        args: JSON.parse(tool.function.arguments),\n                        id: tool.id,\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    fields.invalid_tool_calls?.push({\n                        name: tool.function.name,\n                        args: tool.function.arguments,\n                        id: tool.id,\n                        error: e.message,\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            fields.additional_kwargs = {\n                tool_calls: tools,\n            };\n        }\n        return fields;\n    }\n    function responseToBaseMessage(response) {\n        const fields = responseToBaseMessageFields(response);\n        return new messages_1.AIMessage(fields);\n    }\n    function safeResponseToBaseMessage(response, safetyHandler) {\n        return safeResponseTo(response, safetyHandler, responseToBaseMessage);\n    }\n    function responseToChatResult(response) {\n        const generations = responseToChatGenerations(response);\n        return {\n            generations,\n            llmOutput: responseToGenerationInfo(response),\n        };\n    }\n    function safeResponseToChatResult(response, safetyHandler) {\n        return safeResponseTo(response, safetyHandler, responseToChatResult);\n    }\n    return {\n        messageContentToParts,\n        baseMessageToContent,\n        safeResponseToString,\n        safeResponseToChatGeneration,\n        chunkToString,\n        safeResponseToBaseMessage,\n        safeResponseToChatResult,\n    };\n}\nexports.getGeminiAPI = getGeminiAPI;\nfunction validateGeminiParams(params) {\n    if (params.maxOutputTokens && params.maxOutputTokens < 0) {\n        throw new Error(\"`maxOutputTokens` must be a positive integer\");\n    }\n    if (params.temperature &&\n        (params.temperature < 0 || params.temperature > 2)) {\n        throw new Error(\"`temperature` must be in the range of [0.0,2.0]\");\n    }\n    if (params.topP && (params.topP < 0 || params.topP > 1)) {\n        throw new Error(\"`topP` must be in the range of [0.0,1.0]\");\n    }\n    if (params.topK && params.topK < 0) {\n        throw new Error(\"`topK` must be a positive integer\");\n    }\n}\nexports.validateGeminiParams = validateGeminiParams;\nfunction isModelGemini(modelName) {\n    return modelName.toLowerCase().startsWith(\"gemini\");\n}\nexports.isModelGemini = isModelGemini;\nclass DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        Object.defineProperty(this, \"errorFinish\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"SAFETY\", \"RECITATION\", \"OTHER\"]\n        });\n        this.errorFinish = settings?.errorFinish ?? this.errorFinish;\n    }\n    handleDataPromptFeedback(response, data) {\n        // Check to see if our prompt was blocked in the first place\n        const promptFeedback = data?.promptFeedback;\n        const blockReason = promptFeedback?.blockReason;\n        if (blockReason) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Prompt blocked: ${blockReason}`);\n        }\n        return data;\n    }\n    handleDataFinishReason(response, data) {\n        const firstCandidate = data?.candidates?.[0];\n        const finishReason = firstCandidate?.finishReason;\n        if (this.errorFinish.includes(finishReason)) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Finish reason: ${finishReason}`);\n        }\n        return data;\n    }\n    handleData(response, data) {\n        let ret = data;\n        ret = this.handleDataPromptFeedback(response, ret);\n        ret = this.handleDataFinishReason(response, ret);\n        return ret;\n    }\n    handle(response) {\n        let newdata;\n        if (\"nextChunk\" in response.data) {\n            // TODO: This is a stream. How to handle?\n            newdata = response.data;\n        }\n        else if (Array.isArray(response.data)) {\n            // If it is an array, try to handle every item in the array\n            try {\n                newdata = response.data.map((item) => this.handleData(response, item));\n            }\n            catch (xx) {\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                    throw new safety_js_1.GoogleAISafetyError(response, xx.message);\n                }\n                else {\n                    throw xx;\n                }\n            }\n        }\n        else {\n            const data = response.data;\n            newdata = this.handleData(response, data);\n        }\n        return {\n            ...response,\n            data: newdata,\n        };\n    }\n}\nexports.DefaultGeminiSafetyHandler = DefaultGeminiSafetyHandler;\nclass MessageGeminiSafetyHandler extends DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        super(settings);\n        Object.defineProperty(this, \"msg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"forceNewMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.msg = settings?.msg ?? this.msg;\n        this.forceNewMessage = settings?.forceNewMessage ?? this.forceNewMessage;\n    }\n    setMessage(data) {\n        const ret = data;\n        if (this.forceNewMessage ||\n            !data?.candidates?.[0]?.content?.parts?.length) {\n            ret.candidates = data.candidates ?? [];\n            ret.candidates[0] = data.candidates[0] ?? {};\n            ret.candidates[0].content = data.candidates[0].content ?? {};\n            ret.candidates[0].content = {\n                role: \"model\",\n                parts: [{ text: this.msg }],\n            };\n        }\n        return ret;\n    }\n    handleData(response, data) {\n        try {\n            return super.handleData(response, data);\n        }\n        catch (xx) {\n            return this.setMessage(data);\n        }\n    }\n}\nexports.MessageGeminiSafetyHandler = MessageGeminiSafetyHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZ2VtaW5pLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyxrQ0FBa0MsR0FBRyxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0I7QUFDckosZUFBZSxtQkFBTyxDQUFDLDhEQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEIsU0FBUyxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsWUFBWTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL2dlbWluaS5janM/ZThkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZUdlbWluaVNhZmV0eUhhbmRsZXIgPSBleHBvcnRzLkRlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyID0gZXhwb3J0cy5pc01vZGVsR2VtaW5pID0gZXhwb3J0cy52YWxpZGF0ZUdlbWluaVBhcmFtcyA9IGV4cG9ydHMuZ2V0R2VtaW5pQVBJID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmNvbnN0IG91dHB1dHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0c1wiKTtcbmNvbnN0IHNhZmV0eV9qc18xID0gcmVxdWlyZShcIi4vc2FmZXR5LmNqc1wiKTtcbmNvbnN0IGV4dHJhY3RNaW1lVHlwZSA9IChzdHIpID0+IHtcbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWltZVR5cGU6IHN0ci5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdLFxuICAgICAgICAgICAgZGF0YTogc3RyLnNwbGl0KFwiLFwiKVsxXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0R2VtaW5pQVBJKGNvbmZpZykge1xuICAgIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50VGV4dChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50Py50ZXh0ICYmIGNvbnRlbnQ/LnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LnRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZUNvbnRlbnRJbWFnZVVybChjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBjb250ZW50LmltYWdlX3VybCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBjb250ZW50LmltYWdlX3VybFxuICAgICAgICAgICAgOiBjb250ZW50LmltYWdlX3VybC51cmw7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEltYWdlIFVSTFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5lVHlwZUFuZERhdGEgPSBleHRyYWN0TWltZVR5cGUodXJsKTtcbiAgICAgICAgaWYgKG1pbmVUeXBlQW5kRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhOiBtaW5lVHlwZUFuZERhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgLSBuZWVkIHNvbWUgd2F5IHRvIGdldCBtaW1lIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVVcmk6IHVybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBibG9iVG9GaWxlRGF0YShibG9iKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgICAgIGZpbGVVcmk6IGJsb2IucGF0aCxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYmxvYi5taW1ldHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGVVcmlDb250ZW50VG9CbG9iKHVyaSkge1xuICAgICAgICByZXR1cm4gY29uZmlnPy5tZWRpYU1hbmFnZXI/LmdldE1lZGlhQmxvYih1cmkpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQ29udGVudE1lZGlhKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29udGVudCkge1xuICAgICAgICBpZiAoXCJtaW1lVHlwZVwiIGluIGNvbnRlbnQgJiYgXCJkYXRhXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBjb250ZW50Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb250ZW50LmRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJtaW1lVHlwZVwiIGluIGNvbnRlbnQgJiYgXCJmaWxlVXJpXCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogY29udGVudC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVVyaTogY29udGVudC5maWxlVXJpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXJpID0gY29udGVudC5maWxlVXJpO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGZpbGVVcmlDb250ZW50VG9CbG9iKHVyaSk7XG4gICAgICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBibG9iVG9GaWxlRGF0YShibG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lZGlhIGNvbnRlbnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydChjb250ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoY29udGVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIGlmIChcInRleHRcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQ29udGVudFRleHQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImltYWdlX3VybFwiOlxuICAgICAgICAgICAgICAgIGlmIChcImltYWdlX3VybFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBndWFyZCBmb3IgTWVzc2FnZUNvbnRlbnRJbWFnZVVybFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZUNvbnRlbnRJbWFnZVVybChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVkaWFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgbWVzc2FnZUNvbnRlbnRNZWRpYShjb250ZW50KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIHJlY2VpdmVkIHdoaWxlIGNvbnZlcnRpbmcgbWVzc2FnZSB0byBtZXNzYWdlIHBhcnRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29lcmNlIFwiJHtjb250ZW50LnR5cGV9XCIgbWVzc2FnZSBwYXJ0IGludG8gYSBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydHMoY29udGVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGNvbnRlbnQubWFwKG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjb250ZW50cyk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50VG9QYXJ0cyhjb250ZW50KSB7XG4gICAgICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSB0ZXh0IHR5cGUgTWVzc2FnZUNvbnRlbnQgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogY29udGVudDtcbiAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgcGFydHMsIGV2ZW4gdGhvc2UgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVzb2x2ZVxuICAgICAgICBjb25zdCBhbGxQYXJ0cyA9IGF3YWl0IG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydHMobWVzc2FnZUNvbnRlbnQpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGludmFsaWQgcGFydHNcbiAgICAgICAgY29uc3QgcGFydHMgPSBhbGxQYXJ0cy5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHZhbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZVRvb2xDYWxsc1RvUGFydHModG9vbENhbGxzKSB7XG4gICAgICAgIGlmICghdG9vbENhbGxzIHx8IHRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vbENhbGxzLm1hcCgodG9vbCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGlmICh0b29sPy5mdW5jdGlvbj8uYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnU3RyID0gdG9vbC5mdW5jdGlvbi5hcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgYXJncyA9IEpTT04ucGFyc2UoYXJnU3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VLd2FyZ3NUb1BhcnRzKGt3YXJncykge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgaWYgKGt3YXJncz8udG9vbF9jYWxscykge1xuICAgICAgICAgICAgcmV0LnB1c2goLi4ubWVzc2FnZVRvb2xDYWxsc1RvUGFydHMoa3dhcmdzLnRvb2xfY2FsbHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiByb2xlTWVzc2FnZVRvQ29udGVudChyb2xlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRQYXJ0cyA9IGF3YWl0IG1lc3NhZ2VDb250ZW50VG9QYXJ0cyhtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICBsZXQgdG9vbFBhcnRzO1xuICAgICAgICBpZiAoKDAsIG1lc3NhZ2VzXzEuaXNBSU1lc3NhZ2UpKG1lc3NhZ2UpICYmICEhbWVzc2FnZS50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvb2xQYXJ0cyA9IG1lc3NhZ2UudG9vbF9jYWxscy5tYXAoKHRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sUGFydHMgPSBtZXNzYWdlS3dhcmdzVG9QYXJ0cyhtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IFsuLi5jb250ZW50UGFydHMsIC4uLnRvb2xQYXJ0c107XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHN5c3RlbU1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSwgdXNlU3lzdGVtSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHVzZVN5c3RlbUluc3RydWN0aW9uXG4gICAgICAgICAgICA/IHJvbGVNZXNzYWdlVG9Db250ZW50KFwic3lzdGVtXCIsIG1lc3NhZ2UpXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAuLi4oYXdhaXQgcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJ1c2VyXCIsIG1lc3NhZ2UpKSxcbiAgICAgICAgICAgICAgICAuLi4oYXdhaXQgcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJtb2RlbFwiLCBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2UoXCJPa1wiKSkpLFxuICAgICAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9vbE1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSwgcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY29udGVudFN0ciA9IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gbWVzc2FnZS5jb250ZW50XG4gICAgICAgICAgICA6IG1lc3NhZ2UuY29udGVudC5yZWR1Y2UoKGFjYywgY29udGVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBjb250ZW50LnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwiXCIpO1xuICAgICAgICAvLyBIYWNreSA6KFxuICAgICAgICBjb25zdCByZXNwb25zZU5hbWUgPSAoKDAsIG1lc3NhZ2VzXzEuaXNBSU1lc3NhZ2UpKHByZXZNZXNzYWdlKSAmJiAhIXByZXZNZXNzYWdlLnRvb2xfY2FsbHM/Lmxlbmd0aFxuICAgICAgICAgICAgPyBwcmV2TWVzc2FnZS50b29sX2NhbGxzWzBdLm5hbWVcbiAgICAgICAgICAgIDogcHJldk1lc3NhZ2UubmFtZSkgPz8gbWVzc2FnZS50b29sX2NhbGxfaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShjb250ZW50U3RyKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZXNwb25zZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlc3BvbnNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHsgY29udGVudDogY29udGVudFN0ciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGJhc2VNZXNzYWdlVG9Db250ZW50KG1lc3NhZ2UsIHByZXZNZXNzYWdlLCB1c2VTeXN0ZW1JbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCB1c2VTeXN0ZW1JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJ1c2VyXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FzZSBcImFpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvbGVNZXNzYWdlVG9Db250ZW50KFwibW9kZWxcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgICAgIGlmICghcHJldk1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBtZXNzYWdlcyBjYW5ub3QgYmUgdGhlIGZpcnN0IG1lc3NhZ2UgcGFzc2VkIHRvIHRoZSBtb2RlbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b29sTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCBwcmV2TWVzc2FnZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGV4dFBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmxpbmVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgIGltYWdlX3VybDogYGRhdGE6JHtwYXJ0LmlubGluZURhdGEubWltZVR5cGV9O2Jhc2U2NCwke3BhcnQuaW5saW5lRGF0YS5kYXRhfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbGVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgIGltYWdlX3VybDogcGFydC5maWxlRGF0YS5maWxlVXJpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0c1RvTWVzc2FnZUNvbnRlbnQocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgICAgICAgICAubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwidGV4dFwiIGluIHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJpbmxpbmVEYXRhXCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZpbGVEYXRhXCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlRGF0YVBhcnRUb01lc3NhZ2VDb250ZW50KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvb2xSYXdUb1Rvb2wocmF3KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogcmF3LmlkLFxuICAgICAgICAgICAgdHlwZTogcmF3LnR5cGUsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHJhdy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocmF3LmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNhbGxQYXJ0VG9Ub29sUmF3KHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiAoMCwgdXVpZF8xLnY0KSgpLnJlcGxhY2UoLy0vZywgXCJcIiksXG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBwYXJ0LmZ1bmN0aW9uQ2FsbC5hcmdzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydHNUb1Rvb2xzUmF3KHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1xuICAgICAgICAgICAgLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBwYXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uQ2FsbFwiIGluIHBhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUGFydFRvVG9vbFJhdyhwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBjb250ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b29sc1Jhd1RvVG9vbHMocmF3cykge1xuICAgICAgICByZXR1cm4gcmF3cy5tYXAoKHJhdykgPT4gdG9vbFJhd1RvVG9vbChyYXcpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0dlbmVyYXRlQ29udGVudFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICAgICAgICBpZiAoXCJuZXh0Q2h1bmtcIiBpbiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBTdHJlYW0gdG8gR2VuZXJhdGVDb250ZW50UmVzcG9uc2VEYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIENvbGxhcHNlIHRoZSBhcnJheSBvZiByZXNwb25zZSBkYXRhIGFzIGlmIGl0IHdhcyBhIHNpbmdsZSBvbmVcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIHRoZSBwYXJ0c1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBIYW5kbGUgb3RoZXIgY2FuZGlkYXRlcz9cbiAgICAgICAgICAgICAgICBjb25zdCB2YWxQYXJ0cyA9IHZhbD8uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cyA/PyBbXTtcbiAgICAgICAgICAgICAgICBhY2MuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzLnB1c2goLi4udmFsUGFydHMpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBNZXJnZSBwcm9tcHRGZWVkYmFjayBhbmQgc2FmZXR5IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWNjLnByb21wdEZlZWRiYWNrID0gdmFsLnByb21wdEZlZWRiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZVRvR2VuZXJhdGVDb250ZW50UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSByZXNwb25zZURhdGE/LmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHMgPz8gW107XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydFRvVGV4dChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBcInRleHRcIiBpbiBwYXJ0ID8gcGFydC50ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb1N0cmluZyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHBhcnRzLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJ0VG9UZXh0KHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCBzYWZldHlIYW5kbGVyLCByZXNwb25zZVRvKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzYWZlUmVzcG9uc2UgPSBzYWZldHlIYW5kbGVyLmhhbmRsZShyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VUbyhzYWZlUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh4eCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKHh4IGluc3RhbmNlb2Ygc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHJlc3BvbnNlVG8oeHgucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHh4LnJlcGx5ID0gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgeHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG9TdHJpbmcocmVzcG9uc2UsIHNhZmV0eUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCBzYWZldHlIYW5kbGVyLCByZXNwb25zZVRvU3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0dlbmVyYXRpb25JbmZvKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRfdG9rZW5fY291bnQ6IGRhdGEudXNhZ2VNZXRhZGF0YT8ucHJvbXB0VG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzX3Rva2VuX2NvdW50OiBkYXRhLnVzYWdlTWV0YWRhdGE/LmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuX2NvdW50OiBkYXRhLnVzYWdlTWV0YWRhdGE/LnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYWZldHlfcmF0aW5nczogZGF0YS5jYW5kaWRhdGVzWzBdPy5zYWZldHlSYXRpbmdzPy5tYXAoKHJhdGluZykgPT4gKHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogcmF0aW5nLmNhdGVnb3J5LFxuICAgICAgICAgICAgICAgIHByb2JhYmlsaXR5OiByYXRpbmcucHJvYmFiaWxpdHksXG4gICAgICAgICAgICAgICAgcHJvYmFiaWxpdHlfc2NvcmU6IHJhdGluZy5wcm9iYWJpbGl0eVNjb3JlLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiByYXRpbmcuc2V2ZXJpdHksXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHlfc2NvcmU6IHJhdGluZy5zZXZlcml0eVNjb3JlLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogZGF0YS5jYW5kaWRhdGVzWzBdPy5maW5pc2hSZWFzb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHJlc3BvbnNlVG9TdHJpbmcocmVzcG9uc2UpLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFydFRvTWVzc2FnZUNodW5rKHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSlbMF0pLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHJlc3BvbnNlVG9HZW5lcmF0aW9uSW5mbyhyZXNwb25zZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlLCBzYWZldHlIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBzYWZlUmVzcG9uc2VUbyhyZXNwb25zZSwgc2FmZXR5SGFuZGxlciwgcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2h1bmtUb1N0cmluZyhjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmNvbnRlbnRbMF0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaHVuazogJHtjaHVua31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0VG9NZXNzYWdlQ2h1bmsocGFydCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBwYXJ0c1RvQmFzZU1lc3NhZ2VDaHVua0ZpZWxkcyhbcGFydF0pO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZHMuY29udGVudC5ldmVyeSgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcInRleHRcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBmaWVsZHMuY29udGVudFxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IChcInRleHRcIiBpbiBpdGVtID8gaXRlbS50ZXh0IDogXCJcIikpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBuZXdDb250ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRUb0NoYXRHZW5lcmF0aW9uKHBhcnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnRUb01lc3NhZ2VDaHVuayhwYXJ0KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHBhcnRUb1RleHQocGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb25zKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcmVzcG9uc2VUb1BhcnRzKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXQgPSBwYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnRUb0NoYXRHZW5lcmF0aW9uKHBhcnQpKTtcbiAgICAgICAgaWYgKHJldC5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0ubWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRDb250ZW50ID0gcmV0Lm1hcCgoaXRlbSkgPT4gaXRlbS5tZXNzYWdlLmNvbnRlbnQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFRleHQgPSByZXQubWFwKChpdGVtKSA9PiBpdGVtLnRleHQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbENodW5rcyA9IHJldFtyZXQubGVuZ3RoIC0gMV0/Lm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3M/LnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwsIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsZXQgdXNhZ2VNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChcInVzYWdlTWV0YWRhdGFcIiBpbiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdXNhZ2VNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiByZXNwb25zZS5kYXRhLnVzYWdlTWV0YWRhdGEucHJvbXB0VG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogcmVzcG9uc2UuZGF0YS51c2FnZU1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FuZGlkYXRlc1Rva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogcmVzcG9uc2UuZGF0YS51c2FnZU1ldGFkYXRhLnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gW1xuICAgICAgICAgICAgICAgIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbWJpbmVkQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiByZXRbcmV0Lmxlbmd0aCAtIDFdPy5tZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogdG9vbENhbGxDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbWJpbmVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHJldFtyZXQubGVuZ3RoIC0gMV0uZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9CYXNlTWVzc2FnZUZpZWxkcyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBwYXJ0c1RvQmFzZU1lc3NhZ2VDaHVua0ZpZWxkcyhwYXJ0cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRzVG9CYXNlTWVzc2FnZUNodW5rRmllbGRzKHBhcnRzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnRzVG9NZXNzYWdlQ29udGVudChwYXJ0cyksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmF3VG9vbHMgPSBwYXJ0c1RvVG9vbHNSYXcocGFydHMpO1xuICAgICAgICBpZiAocmF3VG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbHMgPSB0b29sc1Jhd1RvVG9vbHMocmF3VG9vbHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnRvb2xfY2FsbF9jaHVua3M/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMudG9vbF9jYWxscz8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLmludmFsaWRfdG9vbF9jYWxscz8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZF90b29sX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzID0ge1xuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQmFzZU1lc3NhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gcmVzcG9uc2VUb0Jhc2VNZXNzYWdlRmllbGRzKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZShmaWVsZHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0Jhc2VNZXNzYWdlKHJlc3BvbnNlLCBzYWZldHlIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBzYWZlUmVzcG9uc2VUbyhyZXNwb25zZSwgc2FmZXR5SGFuZGxlciwgcmVzcG9uc2VUb0Jhc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0NoYXRSZXN1bHQocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb25zKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbGxtT3V0cHV0OiByZXNwb25zZVRvR2VuZXJhdGlvbkluZm8ocmVzcG9uc2UpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0NoYXRSZXN1bHQocmVzcG9uc2UsIHNhZmV0eUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCBzYWZldHlIYW5kbGVyLCByZXNwb25zZVRvQ2hhdFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50VG9QYXJ0cyxcbiAgICAgICAgYmFzZU1lc3NhZ2VUb0NvbnRlbnQsXG4gICAgICAgIHNhZmVSZXNwb25zZVRvU3RyaW5nLFxuICAgICAgICBzYWZlUmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uLFxuICAgICAgICBjaHVua1RvU3RyaW5nLFxuICAgICAgICBzYWZlUmVzcG9uc2VUb0Jhc2VNZXNzYWdlLFxuICAgICAgICBzYWZlUmVzcG9uc2VUb0NoYXRSZXN1bHQsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0R2VtaW5pQVBJID0gZ2V0R2VtaW5pQVBJO1xuZnVuY3Rpb24gdmFsaWRhdGVHZW1pbmlQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5tYXhPdXRwdXRUb2tlbnMgJiYgcGFyYW1zLm1heE91dHB1dFRva2VucyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG1heE91dHB1dFRva2Vuc2AgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudGVtcGVyYXR1cmUgJiZcbiAgICAgICAgKHBhcmFtcy50ZW1wZXJhdHVyZSA8IDAgfHwgcGFyYW1zLnRlbXBlcmF0dXJlID4gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHRlbXBlcmF0dXJlYCBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiBbMC4wLDIuMF1cIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudG9wUCAmJiAocGFyYW1zLnRvcFAgPCAwIHx8IHBhcmFtcy50b3BQID4gMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHRvcFBgIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIFswLjAsMS4wXVwiKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50b3BLICYmIHBhcmFtcy50b3BLIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdG9wS2AgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUdlbWluaVBhcmFtcyA9IHZhbGlkYXRlR2VtaW5pUGFyYW1zO1xuZnVuY3Rpb24gaXNNb2RlbEdlbWluaShtb2RlbE5hbWUpIHtcbiAgICByZXR1cm4gbW9kZWxOYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImdlbWluaVwiKTtcbn1cbmV4cG9ydHMuaXNNb2RlbEdlbWluaSA9IGlzTW9kZWxHZW1pbmk7XG5jbGFzcyBEZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JGaW5pc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcIlNBRkVUWVwiLCBcIlJFQ0lUQVRJT05cIiwgXCJPVEhFUlwiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lcnJvckZpbmlzaCA9IHNldHRpbmdzPy5lcnJvckZpbmlzaCA/PyB0aGlzLmVycm9yRmluaXNoO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhUHJvbXB0RmVlZGJhY2socmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG91ciBwcm9tcHQgd2FzIGJsb2NrZWQgaW4gdGhlIGZpcnN0IHBsYWNlXG4gICAgICAgIGNvbnN0IHByb21wdEZlZWRiYWNrID0gZGF0YT8ucHJvbXB0RmVlZGJhY2s7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVhc29uID0gcHJvbXB0RmVlZGJhY2s/LmJsb2NrUmVhc29uO1xuICAgICAgICBpZiAoYmxvY2tSZWFzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzYWZldHlfanNfMS5Hb29nbGVBSVNhZmV0eUVycm9yKHJlc3BvbnNlLCBgUHJvbXB0IGJsb2NrZWQ6ICR7YmxvY2tSZWFzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGhhbmRsZURhdGFGaW5pc2hSZWFzb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDYW5kaWRhdGUgPSBkYXRhPy5jYW5kaWRhdGVzPy5bMF07XG4gICAgICAgIGNvbnN0IGZpbmlzaFJlYXNvbiA9IGZpcnN0Q2FuZGlkYXRlPy5maW5pc2hSZWFzb247XG4gICAgICAgIGlmICh0aGlzLmVycm9yRmluaXNoLmluY2x1ZGVzKGZpbmlzaFJlYXNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzYWZldHlfanNfMS5Hb29nbGVBSVNhZmV0eUVycm9yKHJlc3BvbnNlLCBgRmluaXNoIHJlYXNvbjogJHtmaW5pc2hSZWFzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGhhbmRsZURhdGEocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgbGV0IHJldCA9IGRhdGE7XG4gICAgICAgIHJldCA9IHRoaXMuaGFuZGxlRGF0YVByb21wdEZlZWRiYWNrKHJlc3BvbnNlLCByZXQpO1xuICAgICAgICByZXQgPSB0aGlzLmhhbmRsZURhdGFGaW5pc2hSZWFzb24ocmVzcG9uc2UsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGhhbmRsZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgbmV3ZGF0YTtcbiAgICAgICAgaWYgKFwibmV4dENodW5rXCIgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIHN0cmVhbS4gSG93IHRvIGhhbmRsZT9cbiAgICAgICAgICAgIG5ld2RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFycmF5LCB0cnkgdG8gaGFuZGxlIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld2RhdGEgPSByZXNwb25zZS5kYXRhLm1hcCgoaXRlbSkgPT4gdGhpcy5oYW5kbGVEYXRhKHJlc3BvbnNlLCBpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoeHgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgaWYgKHh4IGluc3RhbmNlb2Ygc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcihyZXNwb25zZSwgeHgubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB4eDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIG5ld2RhdGEgPSB0aGlzLmhhbmRsZURhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgIGRhdGE6IG5ld2RhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciA9IERlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyO1xuY2xhc3MgTWVzc2FnZUdlbWluaVNhZmV0eUhhbmRsZXIgZXh0ZW5kcyBEZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtc2dcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvcmNlTmV3TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXNnID0gc2V0dGluZ3M/Lm1zZyA/PyB0aGlzLm1zZztcbiAgICAgICAgdGhpcy5mb3JjZU5ld01lc3NhZ2UgPSBzZXR0aW5ncz8uZm9yY2VOZXdNZXNzYWdlID8/IHRoaXMuZm9yY2VOZXdNZXNzYWdlO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VOZXdNZXNzYWdlIHx8XG4gICAgICAgICAgICAhZGF0YT8uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQuY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcyA/PyBbXTtcbiAgICAgICAgICAgIHJldC5jYW5kaWRhdGVzWzBdID0gZGF0YS5jYW5kaWRhdGVzWzBdID8/IHt9O1xuICAgICAgICAgICAgcmV0LmNhbmRpZGF0ZXNbMF0uY29udGVudCA9IGRhdGEuY2FuZGlkYXRlc1swXS5jb250ZW50ID8/IHt9O1xuICAgICAgICAgICAgcmV0LmNhbmRpZGF0ZXNbMF0uY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICByb2xlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgcGFydHM6IFt7IHRleHQ6IHRoaXMubXNnIH1dLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBoYW5kbGVEYXRhKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuaGFuZGxlRGF0YShyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXNzYWdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlR2VtaW5pU2FmZXR5SGFuZGxlciA9IE1lc3NhZ2VHZW1pbmlTYWZldHlIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/index.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./palm.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMseUdBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsNkhBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMseUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHlGQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL2luZGV4LmNqcz9kODNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmFpbGVkX2hhbmRsZXIuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nZW1pbmkuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYWxtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2FmZXR5LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RyZWFtLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/palm.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvcGFsbS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvcGFsbS5janM/OGNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/safety.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAISafetyError = void 0;\nclass GoogleAISafetyError extends Error {\n    constructor(response, message) {\n        super(message);\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"reply\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        this.response = response;\n    }\n}\nexports.GoogleAISafetyError = GoogleAISafetyError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc2FmZXR5LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL3NhZmV0eS5janM/NDQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlQUlTYWZldHlFcnJvciA9IHZvaWQgMDtcbmNsYXNzIEdvb2dsZUFJU2FmZXR5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGx5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVBSVNhZmV0eUVycm9yID0gR29vZ2xlQUlTYWZldHlFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/stream.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadableJsonStream = exports.ComplexJsonStream = exports.JsonStream = exports.simpleValue = exports.complexValue = void 0;\nfunction complexValue(value) {\n    if (value === null || typeof value === \"undefined\") {\n        // I dunno what to put here. An error, probably\n        return undefined;\n    }\n    else if (typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            return {\n                list_val: value.map((avalue) => complexValue(avalue)),\n            };\n        }\n        else {\n            const ret = {};\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const v = value;\n            Object.keys(v).forEach((key) => {\n                ret[key] = complexValue(v[key]);\n            });\n            return { struct_val: ret };\n        }\n    }\n    else if (typeof value === \"number\") {\n        if (Number.isInteger(value)) {\n            return { int_val: value };\n        }\n        else {\n            return { float_val: value };\n        }\n    }\n    else {\n        return {\n            string_val: [value],\n        };\n    }\n}\nexports.complexValue = complexValue;\nfunction simpleValue(val) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (val.hasOwnProperty(\"stringVal\")) {\n            return val.stringVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"boolVal\")) {\n            return val.boolVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"listVal\")) {\n            const { listVal } = val;\n            return listVal.map((aval) => simpleValue(aval));\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"structVal\")) {\n            const ret = {};\n            const struct = val.structVal;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n        else {\n            const ret = {};\n            const struct = val;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n    }\n    else if (Array.isArray(val)) {\n        return val.map((aval) => simpleValue(aval));\n    }\n    else {\n        return val;\n    }\n}\nexports.simpleValue = simpleValue;\nclass JsonStream {\n    constructor() {\n        Object.defineProperty(this, \"_buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"_bufferOpen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"_firstRun\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set up a potential Promise that the handler can resolve.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkResolution\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If there is no Promise (it is null), the handler must add it to the queue\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        // A queue that will collect chunks while there is no Promise\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data) {\n        this._buffer += data;\n        // Our first time, skip to the opening of the array\n        if (this._firstRun) {\n            this._skipTo(\"[\");\n            this._firstRun = false;\n        }\n        this._parseBuffer();\n    }\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer() {\n        this._bufferOpen = false;\n        this._parseBuffer();\n    }\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer() {\n        let obj = null;\n        do {\n            this._skipTo(\"{\");\n            obj = this._getFullObject();\n            if (obj !== null) {\n                const chunk = this._simplifyObject(obj);\n                this._handleChunk(chunk);\n            }\n        } while (obj !== null);\n        if (!this._bufferOpen) {\n            // No more data will be added, and we have parsed everything we could,\n            // so everything else is garbage.\n            this._handleChunk(null);\n            this._buffer = \"\";\n        }\n    }\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start) {\n        const index = this._buffer.indexOf(start);\n        if (index > 0) {\n            this._buffer = this._buffer.slice(index);\n        }\n    }\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject() {\n        let ret = null;\n        // Loop while we don't have something to return AND we have something in the buffer\n        let index = 0;\n        while (ret === null && this._buffer.length > index) {\n            // Advance to the next close bracket after our current index\n            index = this._buffer.indexOf(\"}\", index + 1);\n            // If we don't find one, exit with null\n            if (index === -1) {\n                return null;\n            }\n            // If we have one, try to turn it into an object to return\n            try {\n                const objStr = this._buffer.substring(0, index + 1);\n                ret = JSON.parse(objStr);\n                // We only get here if it parsed it ok\n                // If we did turn it into an object, remove it from the buffer\n                this._buffer = this._buffer.slice(index + 1);\n            }\n            catch (xx) {\n                // It didn't parse it correctly, so we swallow the exception and continue\n            }\n        }\n        return ret;\n    }\n    _simplifyObject(obj) {\n        return obj;\n    }\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _handleChunk(chunk) {\n        if (this._chunkPending) {\n            this._chunkResolution(chunk);\n            this._chunkPending = null;\n        }\n        else {\n            this._chunkQueue.push(chunk);\n        }\n    }\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        if (this._chunkQueue.length > 0) {\n            // If there is data in the queue, return the next queue chunk\n            return this._chunkQueue.shift();\n        }\n        else {\n            // Otherwise, set up a promise that handleChunk will cause to be resolved\n            this._chunkPending = new Promise((resolve) => {\n                this._chunkResolution = resolve;\n            });\n            return this._chunkPending;\n        }\n    }\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone() {\n        return (!this._bufferOpen &&\n            this._buffer.length === 0 &&\n            this._chunkQueue.length === 0 &&\n            this._chunkPending === null);\n    }\n}\nexports.JsonStream = JsonStream;\nclass ComplexJsonStream extends JsonStream {\n    _simplifyObject(obj) {\n        return simpleValue(obj);\n    }\n}\nexports.ComplexJsonStream = ComplexJsonStream;\nclass ReadableJsonStream extends JsonStream {\n    constructor(body) {\n        super();\n        Object.defineProperty(this, \"decoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.decoder = new TextDecoder(\"utf-8\");\n        if (body) {\n            void this.run(body);\n        }\n        else {\n            console.error(\"Unexpected empty body while streaming\");\n        }\n    }\n    async run(body) {\n        const reader = body.getReader();\n        let isDone = false;\n        while (!isDone) {\n            const { value, done } = await reader.read();\n            if (!done) {\n                const svalue = this.decoder.decode(value, { stream: true });\n                this.appendBuffer(svalue);\n            }\n            else {\n                isDone = done;\n                this.closeBuffer();\n            }\n        }\n    }\n}\nexports.ReadableJsonStream = ReadableJsonStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL3N0cmVhbS5janM/NTljMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVhZGFibGVKc29uU3RyZWFtID0gZXhwb3J0cy5Db21wbGV4SnNvblN0cmVhbSA9IGV4cG9ydHMuSnNvblN0cmVhbSA9IGV4cG9ydHMuc2ltcGxlVmFsdWUgPSBleHBvcnRzLmNvbXBsZXhWYWx1ZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNvbXBsZXhWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gSSBkdW5ubyB3aGF0IHRvIHB1dCBoZXJlLiBBbiBlcnJvciwgcHJvYmFibHlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaXN0X3ZhbDogdmFsdWUubWFwKChhdmFsdWUpID0+IGNvbXBsZXhWYWx1ZShhdmFsdWUpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IGNvbXBsZXhWYWx1ZSh2W2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJ1Y3RfdmFsOiByZXQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnRfdmFsOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZmxvYXRfdmFsOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyaW5nX3ZhbDogW3ZhbHVlXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBsZXhWYWx1ZSA9IGNvbXBsZXhWYWx1ZTtcbmZ1bmN0aW9uIHNpbXBsZVZhbHVlKHZhbCkge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ1ZhbFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zdHJpbmdWYWxbMF07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLmhhc093blByb3BlcnR5KFwiYm9vbFZhbFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5ib29sVmFsWzBdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShcImxpc3RWYWxcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGlzdFZhbCB9ID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RWYWwubWFwKChhdmFsKSA9PiBzaW1wbGVWYWx1ZShhdmFsKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLmhhc093blByb3BlcnR5KFwic3RydWN0VmFsXCIpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IHZhbC5zdHJ1Y3RWYWw7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gc2ltcGxlVmFsdWUoc3RydWN0W2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0ge307XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSB2YWw7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gc2ltcGxlVmFsdWUoc3RydWN0W2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsLm1hcCgoYXZhbCkgPT4gc2ltcGxlVmFsdWUoYXZhbCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59XG5leHBvcnRzLnNpbXBsZVZhbHVlID0gc2ltcGxlVmFsdWU7XG5jbGFzcyBKc29uU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2J1ZmZlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2J1ZmZlck9wZW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9maXJzdFJ1blwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHVwIGEgcG90ZW50aWFsIFByb21pc2UgdGhhdCB0aGUgaGFuZGxlciBjYW4gcmVzb2x2ZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NodW5rUmVzb2x1dGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBQcm9taXNlIChpdCBpcyBudWxsKSwgdGhlIGhhbmRsZXIgbXVzdCBhZGQgaXQgdG8gdGhlIHF1ZXVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1BlbmRpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEEgcXVldWUgdGhhdCB3aWxsIGNvbGxlY3QgY2h1bmtzIHdoaWxlIHRoZXJlIGlzIG5vIFByb21pc2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NodW5rUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YSB0byB0aGUgYnVmZmVyLiBUaGlzIG1heSBjYXVzZSBjaHVua3MgdG8gYmUgZ2VuZXJhdGVkLCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBhcHBlbmRCdWZmZXIoZGF0YSkge1xuICAgICAgICB0aGlzLl9idWZmZXIgKz0gZGF0YTtcbiAgICAgICAgLy8gT3VyIGZpcnN0IHRpbWUsIHNraXAgdG8gdGhlIG9wZW5pbmcgb2YgdGhlIGFycmF5XG4gICAgICAgIGlmICh0aGlzLl9maXJzdFJ1bikge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFRvKFwiW1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGV4dCBidWZmZXIuXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gYWxsIHRoZSBkYXRhIGhhcyBiZWVuIHJlYWQgYW5kIGFkZGVkIHRvIGluZGljYXRlXG4gICAgICogdGhhdCB3ZSBzaG91bGQgcHJvY2VzcyBldmVyeXRoaW5nIHJlbWFpbmluZyBpbiB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGNsb3NlQnVmZmVyKCkge1xuICAgICAgICB0aGlzLl9idWZmZXJPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcnNlQnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgY2hhcmFjdGVycyBpbiB0aGUgYnVmZmVyIHRpbGwgd2UgZ2V0IHRvIHRoZSBzdGFydCBvZiBhbiBvYmplY3QuXG4gICAgICogVGhlbiBhdHRlbXB0IHRvIHJlYWQgYSBmdWxsIG9iamVjdC5cbiAgICAgKiBJZiB3ZSBkbyByZWFkIGEgZnVsbCBvYmplY3QsIHR1cm4gaXQgaW50byBhIGNodW5rIGFuZCBzZW5kIGl0IHRvIHRoZSBjaHVuayBoYW5kbGVyLlxuICAgICAqIFJlcGVhdCB0aGlzIGZvciBhcyBtdWNoIGFzIHdlIGNhbi5cbiAgICAgKi9cbiAgICBfcGFyc2VCdWZmZXIoKSB7XG4gICAgICAgIGxldCBvYmogPSBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLl9za2lwVG8oXCJ7XCIpO1xuICAgICAgICAgICAgb2JqID0gdGhpcy5fZ2V0RnVsbE9iamVjdCgpO1xuICAgICAgICAgICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fc2ltcGxpZnlPYmplY3Qob2JqKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaHVuayhjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9iaiAhPT0gbnVsbCk7XG4gICAgICAgIGlmICghdGhpcy5fYnVmZmVyT3Blbikge1xuICAgICAgICAgICAgLy8gTm8gbW9yZSBkYXRhIHdpbGwgYmUgYWRkZWQsIGFuZCB3ZSBoYXZlIHBhcnNlZCBldmVyeXRoaW5nIHdlIGNvdWxkLFxuICAgICAgICAgICAgLy8gc28gZXZlcnl0aGluZyBlbHNlIGlzIGdhcmJhZ2UuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDaHVuayhudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHN0cmluZyBpcyBwcmVzZW50LCBtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIHRvIHRoZSBmaXJzdCBvY2N1cnJlbmNlXG4gICAgICogb2YgdGhhdCBzdHJpbmcuIFRoaXMgaXMgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGVsZW1lbnRzIG9yIHBhcnRzIHRoYXQgd2UncmUgbm90XG4gICAgICogcmVhbGx5IGludGVyZXN0ZWQgaW4gcGFyc2luZy4gKGllIC0gdGhlIG9wZW5pbmcgY2hhcmFjdGVycywgY29tbWEgc2VwYXJhdG9ycywgZXRjLilcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIHN0cmluZyB0byBzdGFydCB0aGUgYnVmZmVyIHdpdGhcbiAgICAgKi9cbiAgICBfc2tpcFRvKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYnVmZmVyLmluZGV4T2Yoc3RhcnQpO1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2UoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHdoYXQgaXMgaW4gdGhlIGJ1ZmZlciwgcGFyc2UgYSBzaW5nbGUgb2JqZWN0IG91dCBvZiBpdC5cbiAgICAgKiBJZiBhIGNvbXBsZXRlIG9iamVjdCBpc24ndCBhdmFpbGFibGUsIHJldHVybiBudWxsLlxuICAgICAqIEFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGFuIG9iamVjdCB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBfZ2V0RnVsbE9iamVjdCgpIHtcbiAgICAgICAgbGV0IHJldCA9IG51bGw7XG4gICAgICAgIC8vIExvb3Agd2hpbGUgd2UgZG9uJ3QgaGF2ZSBzb21ldGhpbmcgdG8gcmV0dXJuIEFORCB3ZSBoYXZlIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChyZXQgPT09IG51bGwgJiYgdGhpcy5fYnVmZmVyLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NlIGJyYWNrZXQgYWZ0ZXIgb3VyIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fYnVmZmVyLmluZGV4T2YoXCJ9XCIsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIG9uZSwgZXhpdCB3aXRoIG51bGxcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgb25lLCB0cnkgdG8gdHVybiBpdCBpbnRvIGFuIG9iamVjdCB0byByZXR1cm5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqU3RyID0gdGhpcy5fYnVmZmVyLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHJldCA9IEpTT04ucGFyc2Uob2JqU3RyKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGdldCBoZXJlIGlmIGl0IHBhcnNlZCBpdCBva1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpZCB0dXJuIGl0IGludG8gYW4gb2JqZWN0LCByZW1vdmUgaXQgZnJvbSB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoeHgpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBkaWRuJ3QgcGFyc2UgaXQgY29ycmVjdGx5LCBzbyB3ZSBzd2FsbG93IHRoZSBleGNlcHRpb24gYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgX3NpbXBsaWZ5T2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciB0aGF0IHdlIGhhdmUgYW5vdGhlciBjaHVuayBhdmFpbGFibGUgZm9yIGNvbnN1bXB0aW9uLlxuICAgICAqIElmIHdlIGFyZSB3YWl0aW5nIGZvciBhIGNodW5rLCByZXNvbHZlIHRoZSBwcm9taXNlIHdhaXRpbmcgZm9yIGl0IGltbWVkaWF0ZWx5LlxuICAgICAqIElmIG5vdCwgdGhlbiBhZGQgaXQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBjaHVua1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2hhbmRsZUNodW5rKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua1BlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUmVzb2x1dGlvbihjaHVuayk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1BlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtRdWV1ZS5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgY2h1bmsgdGhhdCBpcyBjb21pbmcgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqIFRoaXMgY2h1bmsgbWF5IGJlIG51bGwsIHVzdWFsbHkgaW5kaWNhdGluZyB0aGUgbGFzdCBjaHVuayBpbiB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgbmV4dENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBkYXRhIGluIHRoZSBxdWV1ZSwgcmV0dXJuIHRoZSBuZXh0IHF1ZXVlIGNodW5rXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZXQgdXAgYSBwcm9taXNlIHRoYXQgaGFuZGxlQ2h1bmsgd2lsbCBjYXVzZSB0byBiZSByZXNvbHZlZFxuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua1Jlc29sdXRpb24gPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtQZW5kaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBzdHJlYW0gZG9uZT9cbiAgICAgKiBBIHN0cmVhbSBpcyBvbmx5IGRvbmUgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWU6XG4gICAgICogLSBUaGVyZSBpcyBubyBtb3JlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRleHQgYnVmZmVyXG4gICAgICogLSBUaGVyZSBpcyBubyBtb3JlIGRhdGEgaW4gdGhlIHRleHQgYnVmZmVyXG4gICAgICogLSBUaGVyZSBhcmUgbm8gY2h1bmtzIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgY29uc3VtZWRcbiAgICAgKi9cbiAgICBnZXQgc3RyZWFtRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy5fYnVmZmVyT3BlbiAmJlxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fY2h1bmtRdWV1ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUGVuZGluZyA9PT0gbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uU3RyZWFtID0gSnNvblN0cmVhbTtcbmNsYXNzIENvbXBsZXhKc29uU3RyZWFtIGV4dGVuZHMgSnNvblN0cmVhbSB7XG4gICAgX3NpbXBsaWZ5T2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gc2ltcGxlVmFsdWUob2JqKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBsZXhKc29uU3RyZWFtID0gQ29tcGxleEpzb25TdHJlYW07XG5jbGFzcyBSZWFkYWJsZUpzb25TdHJlYW0gZXh0ZW5kcyBKc29uU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3Rvcihib2R5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY29kZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMucnVuKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZW1wdHkgYm9keSB3aGlsZSBzdHJlYW1pbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcnVuKGJvZHkpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgbGV0IGlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWlzRG9uZSkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2YWx1ZSA9IHRoaXMuZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQnVmZmVyKHN2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSBkb25lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVKc29uU3RyZWFtID0gUmVhZGFibGVKc29uU3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jsonSchemaToGeminiParameters = exports.zodToGeminiParameters = exports.removeAdditionalProperties = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nfunction removeAdditionalProperties(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nobj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        const newObj = { ...obj };\n        if (\"additionalProperties\" in newObj) {\n            delete newObj.additionalProperties;\n        }\n        for (const key in newObj) {\n            if (key in newObj) {\n                if (Array.isArray(newObj[key])) {\n                    newObj[key] = newObj[key].map(removeAdditionalProperties);\n                }\n                else if (typeof newObj[key] === \"object\" && newObj[key] !== null) {\n                    newObj[key] = removeAdditionalProperties(newObj[key]);\n                }\n            }\n        }\n        return newObj;\n    }\n    return obj;\n}\nexports.removeAdditionalProperties = removeAdditionalProperties;\nfunction zodToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nzodObj) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties((0, zod_to_json_schema_1.zodToJsonSchema)(zodObj));\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.zodToGeminiParameters = zodToGeminiParameters;\nfunction jsonSchemaToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nschema) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties(schema);\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.jsonSchemaToGeminiParameters = jsonSchemaToGeminiParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQztBQUN6Ryw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janM/NmI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5qc29uU2NoZW1hVG9HZW1pbmlQYXJhbWV0ZXJzID0gZXhwb3J0cy56b2RUb0dlbWluaVBhcmFtZXRlcnMgPSBleHBvcnRzLnJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gdm9pZCAwO1xuY29uc3Qgem9kX3RvX2pzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiem9kLXRvLWpzb24tc2NoZW1hXCIpO1xuZnVuY3Rpb24gcmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxub2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gICAgICAgIGlmIChcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIgaW4gbmV3T2JqKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3T2JqLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld09iaikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBuZXdPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdPYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBuZXdPYmpba2V5XS5tYXAocmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmV3T2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiYgbmV3T2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyhuZXdPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLnJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXM7XG5mdW5jdGlvbiB6b2RUb0dlbWluaVBhcmFtZXRlcnMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuem9kT2JqKSB7XG4gICAgLy8gR2VtaW5pIGRvZXNuJ3QgYWNjZXB0IGVpdGhlciB0aGUgJHNjaGVtYSBvciBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgIC8vIGF0dHJpYnV0ZXMsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgdGhlbS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGpzb25TY2hlbWEgPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcygoMCwgem9kX3RvX2pzb25fc2NoZW1hXzEuem9kVG9Kc29uU2NoZW1hKSh6b2RPYmopKTtcbiAgICBjb25zdCB7ICRzY2hlbWEsIC4uLnJlc3QgfSA9IGpzb25TY2hlbWE7XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5leHBvcnRzLnpvZFRvR2VtaW5pUGFyYW1ldGVycyA9IHpvZFRvR2VtaW5pUGFyYW1ldGVycztcbmZ1bmN0aW9uIGpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuc2NoZW1hKSB7XG4gICAgLy8gR2VtaW5pIGRvZXNuJ3QgYWNjZXB0IGVpdGhlciB0aGUgJHNjaGVtYSBvciBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgIC8vIGF0dHJpYnV0ZXMsIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgdGhlbS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGpzb25TY2hlbWEgPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEpO1xuICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4ucmVzdCB9ID0ganNvblNjaGVtYTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmV4cG9ydHMuanNvblNjaGVtYVRvR2VtaW5pUGFyYW1ldGVycyA9IGpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/experimental/media.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/experimental/media.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2V4cGVyaW1lbnRhbC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUpBQTBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9leHBlcmltZW50YWwvbWVkaWEuY2pzPzZhNWEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2V4cGVyaW1lbnRhbC9tZWRpYS5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/google-common/index.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SEFBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2luZGV4LmNqcz85ZDkyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/auth.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GAuthClient = exports.NodeJsonStream = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nclass NodeJsonStream extends google_common_1.JsonStream {\n    constructor(data) {\n        super();\n        const decoder = new TextDecoder(\"utf-8\");\n        data.on(\"data\", (data) => {\n            const text = decoder.decode(data, { stream: true });\n            this.appendBuffer(text);\n        });\n        data.on(\"end\", () => {\n            const rest = decoder.decode();\n            this.appendBuffer(rest);\n            this.closeBuffer();\n        });\n    }\n}\nexports.NodeJsonStream = NodeJsonStream;\nclass GAuthClient {\n    constructor(fields) {\n        Object.defineProperty(this, \"gauth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const options = (0, google_common_1.ensureAuthOptionScopes)(fields?.authOptions, \"scopes\", fields?.platformType);\n        this.gauth = new google_auth_library_1.GoogleAuth(options);\n    }\n    get clientType() {\n        return \"gauth\";\n    }\n    async getProjectId() {\n        return this.gauth.getProjectId();\n    }\n    async request(opts) {\n        try {\n            const ret = await this.gauth.request(opts);\n            return opts.responseType !== \"stream\"\n                ? ret\n                : {\n                    ...ret,\n                    data: new NodeJsonStream(ret.data),\n                };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (xx) {\n            console.error(\"call to gauth.request\", JSON.stringify(xx, null, 2));\n            console.error(\"call to gauth.request opts=\", JSON.stringify(opts, null, 2));\n            console.error(\"call to gauth.request message:\", xx?.message);\n            throw xx;\n        }\n    }\n}\nexports.GAuthClient = GAuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9hdXRoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxzQkFBc0I7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELDhCQUE4QixtQkFBTyxDQUFDLHdGQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2F1dGguY2pzPzJjZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdBdXRoQ2xpZW50ID0gZXhwb3J0cy5Ob2RlSnNvblN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IGdvb2dsZV9jb21tb25fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2dvb2dsZS1jb21tb25cIik7XG5jb25zdCBnb29nbGVfYXV0aF9saWJyYXJ5XzEgPSByZXF1aXJlKFwiZ29vZ2xlLWF1dGgtbGlicmFyeVwiKTtcbmNsYXNzIE5vZGVKc29uU3RyZWFtIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkpzb25TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgICBkYXRhLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKGRhdGEsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCdWZmZXIodGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBkZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCdWZmZXIocmVzdCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZUpzb25TdHJlYW0gPSBOb2RlSnNvblN0cmVhbTtcbmNsYXNzIEdBdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2F1dGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9ICgwLCBnb29nbGVfY29tbW9uXzEuZW5zdXJlQXV0aE9wdGlvblNjb3BlcykoZmllbGRzPy5hdXRoT3B0aW9ucywgXCJzY29wZXNcIiwgZmllbGRzPy5wbGF0Zm9ybVR5cGUpO1xuICAgICAgICB0aGlzLmdhdXRoID0gbmV3IGdvb2dsZV9hdXRoX2xpYnJhcnlfMS5Hb29nbGVBdXRoKG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgY2xpZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2F1dGhcIjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXV0aC5nZXRQcm9qZWN0SWQoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLmdhdXRoLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5yZXNwb25zZVR5cGUgIT09IFwic3RyZWFtXCJcbiAgICAgICAgICAgICAgICA/IHJldFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5ldyBOb2RlSnNvblN0cmVhbShyZXQuZGF0YSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FsbCB0byBnYXV0aC5yZXF1ZXN0XCIsIEpTT04uc3RyaW5naWZ5KHh4LCBudWxsLCAyKSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FsbCB0byBnYXV0aC5yZXF1ZXN0IG9wdHM9XCIsIEpTT04uc3RyaW5naWZ5KG9wdHMsIG51bGwsIDIpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjYWxsIHRvIGdhdXRoLnJlcXVlc3QgbWVzc2FnZTpcIiwgeHg/Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgeHg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdBdXRoQ2xpZW50ID0gR0F1dGhDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/chat_models.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogle = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogle extends google_common_1.ChatGoogleBase {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.ChatGoogle = ChatGoogle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHdCQUF3QixtQkFBTyxDQUFDLHlGQUEwQjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9jaGF0X21vZGVscy5janM/YTE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhdEdvb2dsZSA9IHZvaWQgMDtcbmNvbnN0IGdvb2dsZV9jb21tb25fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2dvb2dsZS1jb21tb25cIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhIEdvb2dsZSBjaGF0IG1vZGVsLlxuICovXG5jbGFzcyBDaGF0R29vZ2xlIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkNoYXRHb29nbGVCYXNlIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRHb29nbGVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRHb29nbGUgPSBDaGF0R29vZ2xlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/embeddings.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleEmbeddings = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with an Google embeddings model.\n */\nclass GoogleEmbeddings extends google_common_1.BaseGoogleEmbeddings {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleEmbeddings\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleEmbeddings = GoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9lbWJlZGRpbmdzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2Rpc3QvZW1iZWRkaW5ncy5janM/MmU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlRW1iZWRkaW5ncyA9IHZvaWQgMDtcbmNvbnN0IGdvb2dsZV9jb21tb25fMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2dvb2dsZS1jb21tb25cIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhbiBHb29nbGUgZW1iZWRkaW5ncyBtb2RlbC5cbiAqL1xuY2xhc3MgR29vZ2xlRW1iZWRkaW5ncyBleHRlbmRzIGdvb2dsZV9jb21tb25fMS5CYXNlR29vZ2xlRW1iZWRkaW5ncyB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHb29nbGVFbWJlZGRpbmdzXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUVtYmVkZGluZ3MgPSBHb29nbGVFbWJlZGRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/index.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./media.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRGQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDBGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9pbmRleC5janM/M2Y0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoYXRfbW9kZWxzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGxtcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VtYmVkZGluZ3MuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZWRpYS5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/llms.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleLLM = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google LLM.\n */\nclass GoogleLLM extends google_common_1.GoogleBaseLLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleLLM = GoogleLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2Rpc3QvbGxtcy5janM/MTE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlTExNID0gdm9pZCAwO1xuY29uc3QgZ29vZ2xlX2NvbW1vbl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vblwiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuLyoqXG4gKiBJbnRlZ3JhdGlvbiB3aXRoIGEgR29vZ2xlIExMTS5cbiAqL1xuY2xhc3MgR29vZ2xlTExNIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkdvb2dsZUJhc2VMTE0ge1xuICAgIC8vIFVzZWQgZm9yIHRyYWNpbmcsIHJlcGxhY2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHlvdXIgY2xhc3NcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiR29vZ2xlTExNXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUxMTSA9IEdvb2dsZUxMTTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/media.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFile = exports.BlobStoreGoogleCloudStorage = void 0;\nconst media_1 = __webpack_require__(/*! @langchain/google-common/experimental/media */ \"(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\nclass BlobStoreGoogleCloudStorage extends media_1.BlobStoreGoogleCloudStorageBase {\n    buildClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreGoogleCloudStorage = BlobStoreGoogleCloudStorage;\nclass BlobStoreAIStudioFile extends media_1.BlobStoreAIStudioFileBase {\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreAIStudioFile = BlobStoreAIStudioFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsbUNBQW1DO0FBQ25FLGdCQUFnQixtQkFBTyxDQUFDLHlIQUE2QztBQUNyRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9tZWRpYS5janM/ZjU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlID0gZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBtZWRpYV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9leHBlcmltZW50YWwvbWVkaWFcIik7XG5jb25zdCBhdXRoX2pzXzEgPSByZXF1aXJlKFwiLi9hdXRoLmNqc1wiKTtcbmNsYXNzIEJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZSBleHRlbmRzIG1lZGlhXzEuQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlQmFzZSB7XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkdBdXRoQ2xpZW50KGZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2UgPSBCbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2U7XG5jbGFzcyBCbG9iU3RvcmVBSVN0dWRpb0ZpbGUgZXh0ZW5kcyBtZWRpYV8xLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2Uge1xuICAgIGJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JTdG9yZUFJU3R1ZGlvRmlsZSA9IEJsb2JTdG9yZUFJU3R1ZGlvRmlsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/index.cjs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLDJIQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9pbmRleC5janM/YjRiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9pbmRleC5janMnKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/index.cjs\n");

/***/ })

};
;